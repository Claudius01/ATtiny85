
AVRA   Ver. 1.4.2 ATtiny85_uOS+DS18B20.asm Wed Dec 17 23:41:55 2025


         ; "$Id: ATtiny85_uOS+DS18B20.asm,v 1.38 2025/12/17 12:45:07 administrateur Exp $"
         
         ; Programme de gestion des capteurs DS18B20
         ;
         ; A la mise sous tension du DS18B20, les 2 seuils Th et Tl sont respectivement a 70 et 75 degres
         ; et la temperature a 85 degres tant qu'une commande 'DS18B20_CMD_CONVERT_T' n'a pas ete emise
         ; => En concequence, le capteur presente une alarme dans le cas d'une temperature ambiante de 20 degres
         ;
         ; Remarque: L'alarme est presentee des lors que Tc <= Tl ou Tc >= Th avec une precision de 1 degre car
         ;           les 2 seuils Th et Tl sont definis au degres pres
         
          .include		"ATtiny85_uOS.asm"
         ; "$Id: ATtiny85_uOS.asm,v 1.35 2025/12/17 22:16:43 administrateur Exp $"
         
         ; - Projet: ATtiny85_uOS.asm
         ;
         ; - Avertissement: Etude pour l'utilisation d'un ATtiny85-20
         ;   => Le DigiSpark utilise un ATtiny85-10 cadence a 10 Mhz
         ;
         ; - TODO: Version minimaliste: Allumage fixe de la Led RED au RESET 
         
          .include		"tn85def.inc"              ; Labels and identifiers for tiny85
         ;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
         ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny85.xml ************
         ;*************************************************************************
         ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
         ;* 
         ;* Number            : AVR000
         ;* File Name         : "tn85def.inc"
         ;* Title             : Register/Bit Definitions for the ATtiny85
         ;* Date              : 2011-02-09
         ;* Version           : 2.35
         ;* Support E-mail    : avr@atmel.com
         ;* Target MCU        : ATtiny85
         ;* 
         ;* DESCRIPTION
         ;* When including this file in the assembly program file, all I/O register 
         ;* names and I/O register bit names appearing in the data book can be used.
         ;* In addition, the six registers forming the three data pointers X, Y and 
         ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
         ;* SRAM is also defined 
         ;* 
         ;* The Register names are represented by their hexadecimal address.
         ;* 
         ;* The Register Bit names are represented by their bit number (0-7).
         ;* 
         ;* Please observe the difference in using the bit names with instructions
         ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
         ;* (skip if bit in register set/cleared). The following example illustrates
         ;* this:
         ;* 
         ;* in    r16,PORTB             ;read PORTB latch
         ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
         ;* out   PORTB,r16             ;output to PORTB
         ;* 
         ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
         ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
         ;* rjmp  TOV0_is_set           ;jump if set
         ;* ...                         ;otherwise do something else
         ;*************************************************************************
         
          #ifndef _TN85DEF_INC_
          #define _TN85DEF_INC_
         
         
          #pragma partinc 0
         
         ; ***** SPECIFY DEVICE ***************************************************
          .device ATtiny85
          #pragma AVRPART ADMIN PART_NAME ATtiny85
          .equ	SIGNATURE_000	= 0x1e
          .equ	SIGNATURE_001	= 0x93
          .equ	SIGNATURE_002	= 0x0b
         
          #pragma AVRPART CORE CORE_VERSION V2
          #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
         
         
         ; ***** I/O REGISTER DEFINITIONS *****************************************
         ; NOTE:
         ; Definitions marked "MEMORY MAPPED"are extended I/O ports
         ; and cannot be used with IN/OUT instructions
          .equ	SREG	= 0x3f
          .equ	SPL	= 0x3d
          .equ	SPH	= 0x3e
          .equ	GIMSK	= 0x3b
          .equ	GIFR	= 0x3a
          .equ	TIMSK	= 0x39
          .equ	TIFR	= 0x38
          .equ	SPMCSR	= 0x37
          .equ	MCUCR	= 0x35
          .equ	MCUSR	= 0x34
          .equ	TCCR0B	= 0x33
          .equ	TCNT0	= 0x32
          .equ	OSCCAL	= 0x31
          .equ	TCCR1	= 0x30
          .equ	TCNT1	= 0x2f
          .equ	OCR1A	= 0x2e
          .equ	OCR1C	= 0x2d
          .equ	GTCCR	= 0x2c
          .equ	OCR1B	= 0x2b
          .equ	TCCR0A	= 0x2a
          .equ	OCR0A	= 0x29
          .equ	OCR0B	= 0x28
          .equ	PLLCSR	= 0x27
          .equ	CLKPR	= 0x26
          .equ	DT1A	= 0x25
          .equ	DT1B	= 0x24
          .equ	DTPS	= 0x23
          .equ	DWDR	= 0x22
          .equ	WDTCR	= 0x21
          .equ	PRR	= 0x20
          .equ	EEARH	= 0x1f
          .equ	EEARL	= 0x1e
          .equ	EEDR	= 0x1d
          .equ	EECR	= 0x1c
          .equ	PORTB	= 0x18
          .equ	DDRB	= 0x17
          .equ	PINB	= 0x16
          .equ	PCMSK	= 0x15
          .equ	DIDR0	= 0x14
          .equ	GPIOR2	= 0x13
          .equ	GPIOR1	= 0x12
          .equ	GPIOR0	= 0x11
          .equ	USIBR	= 0x10
          .equ	USIDR	= 0x0f
          .equ	USISR	= 0x0e
          .equ	USICR	= 0x0d
          .equ	ACSR	= 0x08
          .equ	ADMUX	= 0x07
          .equ	ADCSRA	= 0x06
          .equ	ADCH	= 0x05
          .equ	ADCL	= 0x04
          .equ	ADCSRB	= 0x03
         
         
         ; ***** BIT DEFINITIONS **************************************************
         
         ; ***** PORTB ************************
         ; PORTB - Data Register, Port B
          .equ	PORTB0	= 0	; 
          .equ	PB0	= 0	; For compatibility
          .equ	PORTB1	= 1	; 
          .equ	PB1	= 1	; For compatibility
          .equ	PORTB2	= 2	; 
          .equ	PB2	= 2	; For compatibility
          .equ	PORTB3	= 3	; 
          .equ	PB3	= 3	; For compatibility
          .equ	PORTB4	= 4	; 
          .equ	PB4	= 4	; For compatibility
          .equ	PORTB5	= 5	; 
          .equ	PB5	= 5	; For compatibility
         
         ; DDRB - Data Direction Register, Port B
          .equ	DDB0	= 0	; 
          .equ	DDB1	= 1	; 
          .equ	DDB2	= 2	; 
          .equ	DDB3	= 3	; 
          .equ	DDB4	= 4	; 
          .equ	DDB5	= 5	; 
         
         ; PINB - Input Pins, Port B
          .equ	PINB0	= 0	; 
          .equ	PINB1	= 1	; 
          .equ	PINB2	= 2	; 
          .equ	PINB3	= 3	; 
          .equ	PINB4	= 4	; 
          .equ	PINB5	= 5	; 
         
         
         ; ***** ANALOG_COMPARATOR ************
         ; ADCSRB - ADC Control and Status Register B
          .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
         
         ; ACSR - Analog Comparator Control And Status Register
          .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
          .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
          .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
          .equ	ACI	= 4	; Analog Comparator Interrupt Flag
          .equ	ACO	= 5	; Analog Compare Output
          .equ	ACBG	= 6	; Analog Comparator Bandgap Select
          .equ	AINBG	= ACBG	; For compatibility
          .equ	ACD	= 7	; Analog Comparator Disable
         
         ; DIDR0 - 
          .equ	AIN0D	= 0	; AIN0 Digital Input Disable
          .equ	AIN1D	= 1	; AIN1 Digital Input Disable
         
         
         ; ***** AD_CONVERTER *****************
         ; ADMUX - The ADC multiplexer Selection Register
          .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
          .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
          .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
          .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
          .equ	REFS2	= 4	; Reference Selection Bit 2
          .equ	ADLAR	= 5	; Left Adjust Result
          .equ	REFS0	= 6	; Reference Selection Bit 0
          .equ	REFS1	= 7	; Reference Selection Bit 1
         
         ; ADCSRA - The ADC Control and Status register
          .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
          .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
          .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
          .equ	ADIE	= 3	; ADC Interrupt Enable
          .equ	ADIF	= 4	; ADC Interrupt Flag
          .equ	ADATE	= 5	; ADC Auto Trigger Enable
          .equ	ADSC	= 6	; ADC Start Conversion
          .equ	ADEN	= 7	; ADC Enable
         
         ; ADCH - ADC Data Register High Byte
          .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
          .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
          .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
          .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
          .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
          .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
          .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
          .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
         
         ; ADCL - ADC Data Register Low Byte
          .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
          .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
          .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
          .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
          .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
          .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
          .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
          .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
         
         ; ADCSRB - ADC Control and Status Register B
          .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
          .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
          .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
          .equ	IPR	= 5	; Input Polarity Mode
          .equ	BIN	= 7	; Bipolar Input Mode
         
         ; DIDR0 - Digital Input Disable Register 0
          .equ	ADC1D	= 2	; ADC1 Digital input Disable
          .equ	ADC3D	= 3	; ADC3 Digital input Disable
          .equ	ADC2D	= 4	; ADC2 Digital input Disable
          .equ	ADC0D	= 5	; ADC0 Digital input Disable
         
         
         ; ***** USI **************************
         ; USIBR - USI Buffer Register
          .equ	USIBR0	= 0	; USI Buffer Register bit 0
          .equ	USIBR1	= 1	; USI Buffer Register bit 1
          .equ	USIBR2	= 2	; USI Buffer Register bit 2
          .equ	USIBR3	= 3	; USI Buffer Register bit 3
          .equ	USIBR4	= 4	; USI Buffer Register bit 4
          .equ	USIBR5	= 5	; USI Buffer Register bit 5
          .equ	USIBR6	= 6	; USI Buffer Register bit 6
          .equ	USIBR7	= 7	; USI Buffer Register bit 7
         
         ; USIDR - USI Data Register
          .equ	USIDR0	= 0	; USI Data Register bit 0
          .equ	USIDR1	= 1	; USI Data Register bit 1
          .equ	USIDR2	= 2	; USI Data Register bit 2
          .equ	USIDR3	= 3	; USI Data Register bit 3
          .equ	USIDR4	= 4	; USI Data Register bit 4
          .equ	USIDR5	= 5	; USI Data Register bit 5
          .equ	USIDR6	= 6	; USI Data Register bit 6
          .equ	USIDR7	= 7	; USI Data Register bit 7
         
         ; USISR - USI Status Register
          .equ	USICNT0	= 0	; USI Counter Value Bit 0
          .equ	USICNT1	= 1	; USI Counter Value Bit 1
          .equ	USICNT2	= 2	; USI Counter Value Bit 2
          .equ	USICNT3	= 3	; USI Counter Value Bit 3
          .equ	USIDC	= 4	; Data Output Collision
          .equ	USIPF	= 5	; Stop Condition Flag
          .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
          .equ	USISIF	= 7	; Start Condition Interrupt Flag
         
         ; USICR - USI Control Register
          .equ	USITC	= 0	; Toggle Clock Port Pin
          .equ	USICLK	= 1	; Clock Strobe
          .equ	USICS0	= 2	; USI Clock Source Select Bit 0
          .equ	USICS1	= 3	; USI Clock Source Select Bit 1
          .equ	USIWM0	= 4	; USI Wire Mode Bit 0
          .equ	USIWM1	= 5	; USI Wire Mode Bit 1
          .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
          .equ	USISIE	= 7	; Start Condition Interrupt Enable
         
         
         ; ***** EXTERNAL_INTERRUPT ***********
         ; MCUCR - MCU Control Register
          .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
          .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
         
         ; GIMSK - General Interrupt Mask Register
          .equ	GICR	= GIMSK	; For compatibility
          .equ	PCIE	= 5	; Pin Change Interrupt Enable
          .equ	INT0	= 6	; External Interrupt Request 0 Enable
         
         ; GIFR - General Interrupt Flag register
          .equ	PCIF	= 5	; Pin Change Interrupt Flag
          .equ	INTF0	= 6	; External Interrupt Flag 0
         
         ; PCMSK - Pin Change Enable Mask
          .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
          .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
          .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
          .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
          .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
          .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
         
         
         ; ***** EEPROM ***********************
         ; EEARL - EEPROM Address Register Low Byte
          .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
          .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
          .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
          .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
          .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
          .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
          .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
          .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
         
         ; EEARH - EEPROM Address Register High Byte
          .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
         
         ; EEDR - EEPROM Data Register
          .equ	EEDR0	= 0	; EEPROM Data Register bit 0
          .equ	EEDR1	= 1	; EEPROM Data Register bit 1
          .equ	EEDR2	= 2	; EEPROM Data Register bit 2
          .equ	EEDR3	= 3	; EEPROM Data Register bit 3
          .equ	EEDR4	= 4	; EEPROM Data Register bit 4
          .equ	EEDR5	= 5	; EEPROM Data Register bit 5
          .equ	EEDR6	= 6	; EEPROM Data Register bit 6
          .equ	EEDR7	= 7	; EEPROM Data Register bit 7
         
         ; EECR - EEPROM Control Register
          .equ	EERE	= 0	; EEPROM Read Enable
          .equ	EEPE	= 1	; EEPROM Write Enable
          .equ	EEMPE	= 2	; EEPROM Master Write Enable
          .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
          .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
          .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
         
         
         ; ***** WATCHDOG *********************
         ; WDTCR - Watchdog Timer Control Register
          .equ	WDTCSR	= WDTCR	; For compatibility
          .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
          .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
          .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
          .equ	WDE	= 3	; Watch Dog Enable
          .equ	WDCE	= 4	; Watchdog Change Enable
          .equ	WDTOE	= WDCE	; For compatibility
          .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
          .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
          .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
         
         
         ; ***** TIMER_COUNTER_0 **************
         ; TIMSK - Timer/Counter Interrupt Mask Register
          .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
          .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
          .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
         
         ; TIFR - Timer/Counter0 Interrupt Flag register
          .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
          .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
          .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
         
         ; TCCR0A - Timer/Counter  Control Register A
          .equ	WGM00	= 0	; Waveform Generation Mode
          .equ	WGM01	= 1	; Waveform Generation Mode
          .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
          .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
          .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
          .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
         
         ; TCCR0B - Timer/Counter Control Register B
          .equ	CS00	= 0	; Clock Select
          .equ	CS01	= 1	; Clock Select
          .equ	CS02	= 2	; Clock Select
          .equ	WGM02	= 3	; 
          .equ	FOC0B	= 6	; Force Output Compare B
          .equ	FOC0A	= 7	; Force Output Compare A
         
         ; TCNT0 - Timer/Counter0
          .equ	TCNT0_0	= 0	; 
          .equ	TCNT0_1	= 1	; 
          .equ	TCNT0_2	= 2	; 
          .equ	TCNT0_3	= 3	; 
          .equ	TCNT0_4	= 4	; 
          .equ	TCNT0_5	= 5	; 
          .equ	TCNT0_6	= 6	; 
          .equ	TCNT0_7	= 7	; 
         
         ; OCR0A - Timer/Counter0 Output Compare Register
          .equ	OCR0_0	= 0	; 
          .equ	OCR0_1	= 1	; 
          .equ	OCR0_2	= 2	; 
          .equ	OCR0_3	= 3	; 
          .equ	OCR0_4	= 4	; 
          .equ	OCR0_5	= 5	; 
          .equ	OCR0_6	= 6	; 
          .equ	OCR0_7	= 7	; 
         
         ; OCR0B - Timer/Counter0 Output Compare Register
         ;.equ	OCR0_0	= 0	; 
         ;.equ	OCR0_1	= 1	; 
         ;.equ	OCR0_2	= 2	; 
         ;.equ	OCR0_3	= 3	; 
         ;.equ	OCR0_4	= 4	; 
         ;.equ	OCR0_5	= 5	; 
         ;.equ	OCR0_6	= 6	; 
         ;.equ	OCR0_7	= 7	; 
         
         ; GTCCR - General Timer/Counter Control Register
          .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
          .equ	TSM	= 7	; Timer/Counter Synchronization Mode
         
         
         ; ***** TIMER_COUNTER_1 **************
         ; TCCR1 - Timer/Counter Control Register
          .equ	CS10	= 0	; Clock Select Bits
          .equ	CS11	= 1	; Clock Select Bits
          .equ	CS12	= 2	; Clock Select Bits
          .equ	CS13	= 3	; Clock Select Bits
          .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
          .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
          .equ	PWM1A	= 6	; Pulse Width Modulator Enable
          .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
         
         ; TCNT1 - Timer/Counter Register
          .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
          .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
          .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
          .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
          .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
          .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
          .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
          .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
         
         ; OCR1A - Output Compare Register
          .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
          .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
          .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
          .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
          .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
          .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
          .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
          .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
         
         ; OCR1B - Output Compare Register
          .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
          .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
          .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
          .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
          .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
          .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
          .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
          .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
         
         ; OCR1C - Output compare register
          .equ	OCR1C0	= 0	; 
          .equ	OCR1C1	= 1	; 
          .equ	OCR1C2	= 2	; 
          .equ	OCR1C3	= 3	; 
          .equ	OCR1C4	= 4	; 
          .equ	OCR1C5	= 5	; 
          .equ	OCR1C6	= 6	; 
          .equ	OCR1C7	= 7	; 
         
         ; TIMSK - Timer/Counter Interrupt Mask Register
          .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
          .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
          .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
         
         ; TIFR - Timer/Counter Interrupt Flag Register
          .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
          .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
          .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
         
         ; GTCCR - Timer counter control register
          .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
          .equ	FOC1A	= 2	; Force Output Compare 1A
          .equ	FOC1B	= 3	; Force Output Compare Match 1B
          .equ	COM1B0	= 4	; Comparator B Output Mode
          .equ	COM1B1	= 5	; Comparator B Output Mode
          .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
         
         ; DTPS - Dead time prescaler register
          .equ	DTPS0	= 0	; 
          .equ	DTPS1	= 1	; 
         
         ; DT1A - Dead time value register
          .equ	DTVL0	= 0	; 
          .equ	DTVL1	= 1	; 
          .equ	DTVL2	= 2	; 
          .equ	DTVL3	= 3	; 
          .equ	DTVH0	= 4	; 
          .equ	DTVH1	= 5	; 
          .equ	DTVH2	= 6	; 
          .equ	DTVH3	= 7	; 
         
         ; DT1B - Dead time value B
         ;.equ	DTVL0	= 0	; 
         ;.equ	DTVL1	= 1	; 
         ;.equ	DTVL2	= 2	; 
         ;.equ	DTVL3	= 3	; 
         ;.equ	DTVH0	= 4	; 
         ;.equ	DTVH1	= 5	; 
         ;.equ	DTVH2	= 6	; 
         ;.equ	DTVH3	= 7	; 
         
         
         ; ***** BOOT_LOAD ********************
         ; SPMCSR - Store Program Memory Control Register
          .equ	SPMEN	= 0	; Store Program Memory Enable
          .equ	PGERS	= 1	; Page Erase
          .equ	PGWRT	= 2	; Page Write
          .equ	RFLB	= 3	; Read fuse and lock bits
          .equ	CTPB	= 4	; Clear temporary page buffer
         
         
         ; ***** CPU **************************
         ; SREG - Status Register
          .equ	SREG_C	= 0	; Carry Flag
          .equ	SREG_Z	= 1	; Zero Flag
          .equ	SREG_N	= 2	; Negative Flag
          .equ	SREG_V	= 3	; Two's Complement Overflow Flag
          .equ	SREG_S	= 4	; Sign Bit
          .equ	SREG_H	= 5	; Half Carry Flag
          .equ	SREG_T	= 6	; Bit Copy Storage
          .equ	SREG_I	= 7	; Global Interrupt Enable
         
         ; MCUCR - MCU Control Register
         ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
         ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
          .equ	SM0	= 3	; Sleep Mode Select Bit 0
          .equ	SM1	= 4	; Sleep Mode Select Bit 1
          .equ	SE	= 5	; Sleep Enable
          .equ	PUD	= 6	; Pull-up Disable
         
         ; MCUSR - MCU Status register
          .equ	PORF	= 0	; Power-On Reset Flag
          .equ	EXTRF	= 1	; External Reset Flag
          .equ	BORF	= 2	; Brown-out Reset Flag
          .equ	WDRF	= 3	; Watchdog Reset Flag
         
         ; PRR - Power Reduction Register
          .equ	PRADC	= 0	; Power Reduction ADC
          .equ	PRUSI	= 1	; Power Reduction USI
          .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
          .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
         
         ; OSCCAL - Oscillator Calibration Register
          .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
          .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
          .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
          .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
          .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
          .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
          .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
          .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
         
         ; PLLCSR - PLL Control and status register
          .equ	PLOCK	= 0	; PLL Lock detector
          .equ	PLLE	= 1	; PLL Enable
          .equ	PCKE	= 2	; PCK Enable
          .equ	LSM	= 7	; Low speed mode
         
         ; CLKPR - Clock Prescale Register
          .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
          .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
          .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
          .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
          .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
         
         ; DWDR - debugWire data register
          .equ	DWDR0	= 0	; 
          .equ	DWDR1	= 1	; 
          .equ	DWDR2	= 2	; 
          .equ	DWDR3	= 3	; 
          .equ	DWDR4	= 4	; 
          .equ	DWDR5	= 5	; 
          .equ	DWDR6	= 6	; 
          .equ	DWDR7	= 7	; 
         
         ; GPIOR2 - General Purpose IO register 2
          .equ	GPIOR20	= 0	; 
          .equ	GPIOR21	= 1	; 
          .equ	GPIOR22	= 2	; 
          .equ	GPIOR23	= 3	; 
          .equ	GPIOR24	= 4	; 
          .equ	GPIOR25	= 5	; 
          .equ	GPIOR26	= 6	; 
          .equ	GPIOR27	= 7	; 
         
         ; GPIOR1 - General Purpose register 1
          .equ	GPIOR10	= 0	; 
          .equ	GPIOR11	= 1	; 
          .equ	GPIOR12	= 2	; 
          .equ	GPIOR13	= 3	; 
          .equ	GPIOR14	= 4	; 
          .equ	GPIOR15	= 5	; 
          .equ	GPIOR16	= 6	; 
          .equ	GPIOR17	= 7	; 
         
         ; GPIOR0 - General purpose register 0
          .equ	GPIOR00	= 0	; 
          .equ	GPIOR01	= 1	; 
          .equ	GPIOR02	= 2	; 
          .equ	GPIOR03	= 3	; 
          .equ	GPIOR04	= 4	; 
          .equ	GPIOR05	= 5	; 
          .equ	GPIOR06	= 6	; 
          .equ	GPIOR07	= 7	; 
         
         
         
         ; ***** LOCKSBITS ********************************************************
          .equ	LB1	= 0	; Lockbit
          .equ	LB2	= 1	; Lockbit
         
         
         ; ***** FUSES ************************************************************
         ; LOW fuse bits
          .equ	CKSEL0	= 0	; Select Clock source
          .equ	CKSEL1	= 1	; Select Clock source
          .equ	CKSEL2	= 2	; Select Clock source
          .equ	CKSEL3	= 3	; Select Clock source
          .equ	SUT0	= 4	; Select start-up time
          .equ	SUT1	= 5	; Select start-up time
          .equ	CKOUT	= 6	; Clock Output Enable
          .equ	CKDIV8	= 7	; Divide clock by 8
         
         ; HIGH fuse bits
          .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
          .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
          .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
          .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
          .equ	WDTON	= 4	; Watchdog Timer always on
          .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
          .equ	DWEN	= 6	; DebugWIRE Enable
          .equ	RSTDISBL	= 7	; External Reset disable
         
         ; EXTENDED fuse bits
          .equ	SELFPRGEN	= 0	; Self-Programming Enable
         
         
         
         ; ***** CPU REGISTER DEFINITIONS *****************************************
          .def	XH	= r27
          .def	XL	= r26
          .def	YH	= r29
          .def	YL	= r28
          .def	ZH	= r31
          .def	ZL	= r30
         
         
         
         ; ***** DATA MEMORY DECLARATIONS *****************************************
          .equ	FLASHEND	= 0x0fff	; Note: Word address
          .equ	IOEND	= 0x003f
          .equ	SRAM_START	= 0x0060
          .equ	SRAM_SIZE	= 512
          .equ	RAMEND	= 0x025f
          .equ	XRAMEND	= 0x0000
          .equ	E2END	= 0x01ff
          .equ	EEPROMEND	= 0x01ff
          .equ	EEADRBITS	= 9
          #pragma AVRPART MEMORY PROG_FLASH 8192
          #pragma AVRPART MEMORY EEPROM 512
          #pragma AVRPART MEMORY INT_SRAM SIZE 512
          #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
         
         
         
         ; ***** BOOTLOADER DECLARATIONS ******************************************
          .equ	NRWW_START_ADDR	= 0x0
          .equ	NRWW_STOP_ADDR	= 0xfff
          .equ	RWW_START_ADDR	= 0x0
          .equ	RWW_STOP_ADDR	= 0x0
          .equ	PAGESIZE	= 32
         
         
         
         ; ***** INTERRUPT VECTORS ************************************************
          .equ	INT0addr	= 0x0001	; External Interrupt 0
          .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
          .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
          .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
          .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
          .equ	ERDYaddr	= 0x0006	; EEPROM Ready
          .equ	ACIaddr	= 0x0007	; Analog comparator
          .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
          .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
          .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
          .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
          .equ	WDTaddr	= 0x000c	; Watchdog Time-out
          .equ	USI_STARTaddr	= 0x000d	; USI START
          .equ	USI_OVFaddr	= 0x000e	; USI Overflow
         
          .equ	INT_VECTORS_SIZE	= 15	; size in words
         
          #endif  /* _TN85DEF_INC_ */
         
         ; ***** END OF FILE ******************************************************
          ; ***** END OF FILE ******************************************************
         
          .include		"ATtiny85_uOS.h"
         ; "$Id: ATtiny85_uOS.h,v 1.13 2025/12/17 22:16:43 administrateur Exp $"
         
         ; Definition de la 'RAMEND'
          #define ATTINY85_RAMEND		0x25F
          #define ATTINY45_RAMEND		0x15F
         
         ; Implementation sur 'ATtiny45' si uOS et ADDONS compiles en mode 'Minimaliste'
         ; => Sinon: Implementation sur 'ATtiny85'
          #ifdef USE_MINIMALIST_UOS
          #endif
         
          #ifndef USE_MINIMALIST_UOS
          #define ATTINY_RAMEND		ATTINY85_RAMEND
          #else
          #endif
         ; Fin: Definition de la 'RAMEND'
         
          #ifdef USE_MINIMALIST_UOS
          #else
          #define USE_DUMP_SRAM			0
          #endif
         
         ; Registres de travail (dedies)
         ;
          .def		REG_R0				= r0
          .def		REG_R1				= r1
          .def		REG_R2				= r2
          .def		REG_R3				= r3
          .def		REG_R4				= r4
          .def		REG_R4				= r4
          .def		REG_R5				= r5		; Registre dedie a 'uos_delay_1uS'
          .def		REG_R7				= r7
          .def		REG_R8				= r8
          .def		REG_R9				= r9
          .def		REG_R10				= r10
          .def		REG_R11				= r11
         
          .def		REG_R12				= r12
          .def		REG_R13				= r13
          .def		REG_R14				= r14
         
          .def		REG_SAVE_SREG		= r15		; Sauvegarde temporaire de SREG dans les methodes ISR
         
         ; Fin: Registres de travail (dedies)
         
         ; Registres de travail temporaires (dedies et banalises)
          .def		REG_TEMP_R16		= r16
          .def		REG_TEMP_R17		= r17
          .def		REG_TEMP_R18		= r18
          .def		REG_TEMP_R19		= r19
          .def		REG_TEMP_R20		= r20
          .def		REG_TEMP_R21		= r21		; Warning: Utilise dans 'tim1_compa_isr' (Cf. TODO: @ Dysfonctionnement...)
          .def		REG_TEMP_R22		= r22		; Warning: Utilise dans 'tim1_compa_isr' (Cf. TODO: @ Dysfonctionnement...)
         
          .def		REG_PORTB_OUT		= r23		; Dedie a l'image du PORTB en sortie (Leds, Pulse, TXD, etc.)
          .def		REG_FLAGS_0			= r24		; Flags #0
          .def		REG_FLAGS_1			= r25		; Flags #1
         
          .def		REG_X_LSB			= r26		; XL
          .def		REG_X_MSB			= r27		; XH
          .def		REG_Y_LSB			= r28		; YL
          .def		REG_Y_MSB			= r29		; YH
          .def		REG_Z_LSB			= r30		; ZL
          .def		REG_Z_MSB			= r31		; ZH
         ; Fin: Registres de travail temporaires (dedies et banalises)
         
         ; Definition des masques de bits [0x00, 0x01, ..., 0xff] pour les opcodes suivants:
         ; - ori  -> Logical OR with Immediate
         ; - andi -> Logical AND with Immediate (Faire le complement a 1 ou (0xFF - MSK_BITX))
         ; - cbr  -> Clear Bits in Register (= andif avec constante complementee a (0xFF - K))
         ; - sbr  -> Set Bits in Register (= ori)
         ;
          #define	MSK_BIT7				(1 << 7)
          #define	MSK_BIT6				(1 << 6)
          #define	MSK_BIT5				(1 << 5)
          #define	MSK_BIT4				(1 << 4)
          #define	MSK_BIT3				(1 << 3)
          #define	MSK_BIT2				(1 << 2)
          #define	MSK_BIT1				(1 << 1)
          #define	MSK_BIT0				(1 << 0)
         
         ; Definition des index de bits [0, 1, ..., 7] pour les opcodes suivants:
         ; - bld       -> Bit Load from the T Flag in SREG to a Bit in Register
         ; - bst       -> Bit Store from Bit in Register to T Flag in SREG
         ; - cbi/sbi   -> Clear Bit in I/O Register / Set Bit in I/O Register
         ; - sbic/sbis -> Skip if Bit in I/O Register is Cleared / Skip if Bit in I/O Register is Set
         ; - sbrc/sbrs -> Skip if Bit in Register is Cleared / Skip if Bit in Register is Set
         ; - bclr/bset -> Bit Clear / Bit Set in SREG
         ; - brbc/brbs -> Branch if Bit in SREG is Cleared / Set
         ;
          #define	IDX_BIT7				7
          #define	IDX_BIT6				6
          #define	IDX_BIT5				5
          #define	IDX_BIT4				4
          #define	IDX_BIT3				3
          #define	IDX_BIT2				2
          #define	IDX_BIT1				1
          #define	IDX_BIT0				0
         
         ; Definitions pour le pilotage avec ori/and/cbr/sbr
         ; - PORTB<4>: Led RED								0/1: Eteinte/Allumee
         ; - PORTB<3>: Led GREEN								0/1: Eteinte/Allumee
         ; - PORTB<2>: Led YELLOW							0/1: Eteinte/Allumee
         ;             et I/O 1-Wire
         ; - PORTB<1>: Led RED Interne au DigiSpark	0/1: Allumee/Eteinte
         ;             et Uart/TXD -> Platine/TXD
         
          #define	MSK_BIT_LED_RED			MSK_BIT4
          #define	MSK_BIT_LED_GREEN			MSK_BIT3
          #define	MSK_BIT_LED_YELLOW		MSK_BIT2
          #define	MSK_BIT_LED_RED_INT		MSK_BIT1
         
          #define	MSK_BIT_TXD					MSK_BIT1		; Emission sur RXD du FT232R (Meme sortie que la Led RED Interne)
          #define	MSK_BIT_PULSE_IT			MSK_BIT4		; Remarque: Meme sortie que la Led RED Externe
         
          #define	IDX_BIT_LED_RED			IDX_BIT4
          #define	IDX_BIT_LED_GREEN			IDX_BIT3
         
         ; Definitions pour ajout comportemental:
          #define	FLG_BEHAVIOR_MARK_IN_TIM1_COMPA_IDX		IDX_BIT0	; Pulse --\__/--... en entree/sortie de l'It 'tim1_compa_isr'
          #define	FLG_BEHAVIOR_MARK_IN_PCINT0_IDX			IDX_BIT1	; Pulse --\__/--... en entree/sortie de l'It 'pcint0_isr'
          #define	FLG_BEHAVIOR_MARK_IN_RX_REC_BIT_IDX		IDX_BIT2	; Pulse --\__/--... en entree/sortie de 'tim1_compa_isr_rx_rec_bit'
         
          #define	FLG_BEHAVIOR_ADDON_FOUND_IDX				IDX_BIT4	; Programme ADDON trouve (prolongations traitements)
          #define	FLG_BEHAVIOR_ADDON_FOUND_MSK				MSK_BIT4
         
          #define	CPT_CALIBRATION								2
          #define	FLG_BEHAVIOR_CALIBRATION_1_uS				IDX_BIT7
         
         ; Gestion de l'UART
         ; -----------------
         ; - FLG_0_UART_DETECT_LINE_IDLE: Passage a 1 si ligne RXD a l'etat haut durant au moins 10 bits;
         ;   => Soit 40 acquisitions concecutives espacees de 13uS = 520uS correspondant a 10 bits a 9600 bauds
         ; - FLG_0_UART_DETECT_BIT_START: Si 'FLG_0_UART_DETECT_LINE_IDLE' a 1, passage a 1 sur detection du bit START
         ;   => Acquisition au moyen de la detection du front descendant sur RXD (cf. 'int0_isr')
         ;   => Conservation de 'FLG_0_UART_DETECT_LINE_IDLE' et de 'FLG_0_UART_DETECT_BIT_START' a 1 jusqu'a
         ;      la fin de l'acquisition d'un byte UART (1 start + 8 datas + 1 stop)
         ;      => Passage a 0 de 'FLG_0_UART_DETECT_BIT_START' pour relancer la detaction du bit START
         ; - FLG_0_UART_DETECT_BYTE: Passage a 1 pour indiquer donnee UART disponible jusqu'a sa lecture
         ;   pour traitement (ie. ecriture dans la FIFO/UART RX)
         ;
         ; => 1 - L'acquisition des donnees UART commence des que les 2 flags 'FLG_0_UART_DETECT_LINE_IDLE' et
         ;    'FLG_0_UART_DETECT_BIT_START' sont a 1
         ;
         ;    2 - A la fin de l'acquisition, le flag 'FLG_0_UART_DETECT_BIT_START' est remis a 0
         ;        pour une detection du bit START
         ;
         ;    => 'FLG_0_UART_DETECT_LINE_IDLE' est remis a 0 sur erreur de communication comme:
         ;       - Pas de bit START lu au 1st bit apres la detection --\__ (Frame Error)
         ;       - Pas de bit STOP lu au 10th bit (Frame Error)
         ;       - Donnee non attendue @ protocole
         ;       - A completer...
         ;
         ; Flags generaux REG_FLAGS_0 (masques et index) defini dans la registre r24
          #define	FLG_0_PERIODE_1MS_MSK					MSK_BIT0
          #define	FLG_0_UART_DETECT_LINE_IDLE_MSK		MSK_BIT1
          #define	FLG_0_UART_DETECT_BIT_START_MSK		MSK_BIT2
          #define	FLG_0_UART_RX_BYTE_RECEIVED_MSK		MSK_BIT3
          #define	FLG_0_UART_TX_TO_SEND_MSK				MSK_BIT4		; Donnees Data/Tx a emettre
          #define	FLG_0_PRINT_SKIP_MSK						MSK_BIT5		; Saut des methodes 'print_xxx' si affirme
          #define	FLG_0_UART_RX_BYTE_START_ERROR_MSK	MSK_BIT6
          #define	FLG_0_UART_RX_BYTE_STOP_ERROR_MSK	MSK_BIT7
         
          #define	FLG_0_PERIODE_1MS_IDX					IDX_BIT0
          #define	FLG_0_UART_DETECT_LINE_IDLE_IDX		IDX_BIT1
          #define	FLG_0_UART_DETECT_BIT_START_IDX		IDX_BIT2
          #define	FLG_0_UART_RX_BYTE_RECEIVED_IDX		IDX_BIT3
          #define	FLG_0_UART_TX_TO_SEND_IDX				IDX_BIT4		; Donnees Data/Tx a emettre
          #define	FLG_0_PRINT_SKIP_IDX						IDX_BIT5		; Saut des methodes 'print_xxx' si affirme
          #define	FLG_0_UART_RX_BYTE_START_ERROR_IDX	IDX_BIT6
          #define	FLG_0_UART_RX_BYTE_STOP_ERROR_IDX	IDX_BIT7
         
         ; Flags generaux REG_FLAGS_1 (masques et index) defini dans la registre r25
         ; Etats des FIFO/UART/Rx et Tx + Donnees Rx recues et Tx a emettre
          #define	FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK		MSK_BIT0
          #define	FLG_1_UART_FIFO_RX_FULL_MSK			MSK_BIT1
          #define	FLG_1_UART_RX_RECEIVE_MSK				MSK_BIT2		; Donnees Data/Rx recues
          #define	FLG_1_CONNECTED_MSK						MSK_BIT3
          #define	FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK		MSK_BIT4
          #define	FLG_1_UART_FIFO_TX_FULL_MSK			MSK_BIT5
          #define	FLG_1_UART_FIFO_TX_TO_SEND_MSK		MSK_BIT6
          #define	FLG_1_LED_RED_ON_MSK						MSK_BIT7
         
          #define	FLG_1_UART_FIFO_RX_NOT_EMPTY_IDX		IDX_BIT0
          #define	FLG_1_UART_FIFO_RX_FULL_IDX			IDX_BIT1
          #define	FLG_1_UART_RX_RECEIVE_IDX				IDX_BIT2		; Donnees Data/Rx recues
          #define	FLG_1_CONNECTED_IDX						IDX_BIT3	
          #define	FLG_1_UART_FIFO_TX_NOT_EMPTY_IDX		IDX_BIT4
          #define	FLG_1_UART_FIFO_TX_FULL_IDX			IDX_BIT5
          #define	FLG_1_UART_FIFO_TX_TO_SEND_IDX		IDX_BIT6
          #define	FLG_1_LED_RED_ON_IDX						IDX_BIT7
         
          #define EXTENSION_SETUP					0
          #define EXTENSION_BACKGROUND			1
          #define EXTENSION_1_MS					2
          #define EXTENSION_COMMANDS				3
          #define EXTENSION_BUTTON				4
         
         ; 1st adresse de la SRAM [0x60...0xFF]
          .dseg
D:000060    G_BEHAVIOR:						.byte		1		; Pilotage du comportement (pas d'ajout de comportement si egal a 0)
D:000061    G_CALIBRATION:					.byte		1
         
D:000062    G_TICK_1MS:						.byte		1		; Compatbilisation des 1mS
D:000063    G_TICK_1MS_INIT:				.byte		1
         
         ; Fin: Definitions pour ajout comportemental
         
D:000064    G_CHENILLARD_MSB:				.byte		1		; Chenillard d'allumage/extinction Led GREEN
D:000065    G_CHENILLARD_LSB:				.byte		1		; au travers d'un mot de 16 bits (16 x 125mS = 2 Sec)
         
D:000066    G_NBR_VALUE_TRACE:			.byte		1
D:000067    G_NBR_ERRORS:					.byte		1
         
         ; End of file
         
          
         
          .cseg
          .org	0x0000 
         	; Table des 15 vecteurs d'interruption
C:000000 c010      	rjmp		main					; Vector:  1 - reset
C:000001 c00e      	rjmp		int0_isr				; Vector:  2 - int0_isr
C:000002 c1f3      	rjmp		pcint0_isr			; Vector:  3 - pcint0_isr
C:000003 c142      	rjmp		tim1_compa_isr		; Vector:  4 - tim1_compa_isr
C:000004 c00b      	rjmp		tim1_ovf_isr		; Vector:  5 - tim1_ovf_isr
C:000005 c00a      	rjmp		tim0_ovf_isr		; Vector:  6 - tim0_ovf_isr
C:000006 c009      	rjmp		ee_rdy_isr			; Vector:  7 - ee_rdy_isr
C:000007 c008      	rjmp		ana_cmp_isr			; Vector:  8 - ana_cmp_isr
C:000008 c007      	rjmp		adc_isr				; Vector:  9 - adc_isr
C:000009 c006      	rjmp		tim1_compb_isr		; Vector: 10 - tim1_compb_isr
C:00000a c005      	rjmp		tim0_compa_isr		; Vector: 11 - tim0_compa_isr
C:00000b c004      	rjmp		tim0_compb_isr 	; Vector: 12 - tim0_compb_isr
C:00000c c003      	rjmp		wdt_isr				; Vector: 13 - wdt_isr
C:00000d c002      	rjmp		usi_start_isr		; Vector: 14 - usi_start_isr
C:00000e c001      	rjmp		usi_ovf_isr			; Vector: 15 - usi_ovf_isr
         
C:00000f 0000      	nop		; Evite le message "Warning : Improve: Skip equal to 0"
         
         ; Its non supportees => Mise sur voie de garage
          int0_isr:
          tim1_ovf_isr:
          tim0_ovf_isr:
          ee_rdy_isr:
          ana_cmp_isr:
          adc_isr:
          tim1_compb_isr:
          tim0_compa_isr:
          tim0_compb_isr:
          wdt_isr:
          usi_start_isr:
          usi_ovf_isr:
         
C:000010 c101      	rjmp		forever_2
         
         ; Fin: Its non supportees
         
         ; Entree du programme
         ; - Initialisation de la SRAM
         ; - Initialisation materielle
         ; - Test Leds
         ; - Print du bandeau et des infos EEPROM
         
         ; #1 Boucle avec:
         ;   - Comptabilisation de 1 mS
         ;   #2 Toutes les 1 mS    
         ;     - Gestion des timers
         ;     - Presentation
         ;     - Interpretation de la commande recue
         ;   #3 Sans attente de l'expiration de 1 mS
         ;     - Test et emission eventuelle d'un caractere de la FIFO de transmission
         ;     - Presentation des erreurs fugitives et persistante
         ;   #4 Retour en #1
         ;
         ; Le "tick" de cadencement fixe a 26uS, la reception avec la mise en FIFO des
         ; caracteres recus et la gestion du bouton sont effectues sous interruption
         ; en // des traitements executes dans la boucle #1
         ;
          main:
         
          setup:	; Remarque: Equivalent de la methode 'setup()' dans l'ecosysteme Arduino ;-)
         	; Forcage initialisation de SPH:SPL
C:000011 e002      	ldi		REG_TEMP_R16, high(ATTINY_RAMEND)
C:000012 bf0e      	out		SPH, REG_TEMP_R16
C:000013 0000      	nop
C:000014 e51f      	ldi		REG_TEMP_R17, low(ATTINY_RAMEND)
C:000015 bf1d      	out		SPL, REG_TEMP_R17
C:000016 0000      	nop
         	; Fin: Forcage initialisation de SPH:SPL
         
C:000017 d051      	rcall		init_sram_fill			; Initialisation de la SRAM
C:000018 d061      	rcall		init_sram_values		; Initialisation de valeurs particulieres
C:000019 d093      	rcall		init_hard				; Initialisation du materiel
C:00001a d0c9      	rcall		test_leds			 	; Test Leds
         
         	; Initialisation timer 'TIMER_LED_GREEN' pour le chenillard Led GREEN
C:00001b e012      	ldi		REG_TEMP_R17, TIMER_LED_GREEN
C:00001c e72d      	ldi		REG_TEMP_R18, (125 % 256)
C:00001d e030      	ldi		REG_TEMP_R19, (125 / 256)
C:00001e ec4e      	ldi		REG_TEMP_R20, low(exec_timer_led_green)
C:00001f e052      	ldi		REG_TEMP_R21, high(exec_timer_led_green)
C:000020 d243      	rcall		start_timer
         
          #if USE_DUMP_SRAM
          #endif
         
C:000021 9478      	sei						; Set all interrupts for send prompts
         
          setup_cold:
         	; Preparation emission des prompts d'accueil
         	; => Prompt d'accueil
C:000022 e0f0      	ldi		REG_Z_MSB, ((text_whoami << 1) / 256)
C:000023 eaee      	ldi		REG_Z_LSB, ((text_whoami << 1) % 256)
C:000024 d36e      	rcall		push_text_in_fifo_tx
         
         ;#ifndef USE_MINIMALIST_UOS
C:000025 d3c0      	rcall		set_infos_from_eeprom
         ;#endif
         
          #if USE_DUMP_SRAM
          #endif
         
C:000026 6490      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK
         	; Fin: Preparation emission des prompts d'accueil ('whoami' et 'eeprom')
         
          #if 1
C:000027 d014      	rcall		addon_search_methods
          #endif
         
C:000028 e010      	ldi		REG_TEMP_R17, EXTENSION_SETUP
C:000029 d022      	rcall		exec_extension_addon
         
          loop:		; Remarque: Equivalent de la methode 'loop()' dans l'ecosysteme Arduino ;-)
         	; Gestion de l'attente expiration des 1ms
C:00002a ff80      	sbrs		REG_FLAGS_0, FLG_0_PERIODE_1MS_IDX		; 1mS expiree ?
C:00002b c00b      	rjmp		loop_background								; Non -> Traitements en fond de tache
         
         	; Oui -> Traitements toutes les 1mS
         	; => Expiration de 1mS => Nouvelle periode de 1mS
         	; => call 'gestion_timer' (execution du traitement associe a chaque timer qui expire)
         	; => reinitialisation 'G_TICK_1MS' (copie atomique ;-)
         	; => Effacement 'FLG_0_PERIODE_1MS' -> Relance de la comptabilisation des 1mS
         
          loop_1_ms:
C:00002c 9110 0063 	lds		REG_TEMP_R17, G_TICK_1MS_INIT
C:00002e 9310 0062 	sts		G_TICK_1MS, REG_TEMP_R17
         
C:000030 7f8e      	cbr		REG_FLAGS_0, FLG_0_PERIODE_1MS_MSK
         
C:000031 d20b      	rcall		gestion_timer		; Gestion des timers
         
         	; Traitements toutes les 1mS
         	; ---
          #ifndef USE_MINIMALIST_UOS
         	; Presentation etat 'Detect Line Idle'
C:000032 d2c9      	rcall		test_detect_line_idle
          #endif
         
          #ifndef USE_MINIMALIST_UOS
         	; Presentation sur Led GREEN mode "Connecte/Non Connecte"
C:000033 d69a      	rcall		presentation_connexion
          #endif
         
          #ifndef USE_MINIMALIST_UOS
         	; Interpretation de la commande recue
C:000034 d3f3      	rcall		interpret_command
          #endif
         
C:000035 e012      	ldi		REG_TEMP_R17, EXTENSION_1_MS
C:000036 d015      	rcall		exec_extension_addon
         
         	; ---
         	; Fin: Traitements toutes les 1mS
         
          loop_background:
         	; Traitements en background
         	; Test et emission eventuelle d'un caractere de la FIFO/Tx
         	; => Effectue des que possible des lors que 'FLG_1_UART_FIFO_TX_TO_SEND'
         	;    est a 1 et que 'FLG_0_UART_TX_TO_SEND' est a 0
         	;    => Traitement en fond de tache pour cadencer l'emission au max des 9600 bauds
C:000037 d37a      	rcall		fifo_tx_to_send_async
         
         	; Presentation erreurs sur Led RED Externe
C:000038 d665      	rcall		presentation_error
         
C:000039 e011      	ldi		REG_TEMP_R17, EXTENSION_BACKGROUND
C:00003a d011      	rcall		exec_extension_addon
         
          loop_end:
C:00003b cfee      	rjmp		loop
         
         
         ; -----------
         ; Determination si les 5 vecteurs de "prolongation" definis dans le cas d'un ADDON
         ; -----------
          addon_search_methods:
C:00003c e8e6      	ldi		REG_Z_LSB, low(end_of_prg_uos << 1)
C:00003d e0fe      	ldi		REG_Z_MSB, high(end_of_prg_uos << 1)
         
C:00003e e01a      	ldi		REG_TEMP_R17, (2 * 5)
         
          addon_search_loop:
C:00003f 9105      	lpm		REG_TEMP_R16, Z+
C:000040 3f0f      	cpi		REG_TEMP_R16, 0xFF
C:000041 f421      	brne		addon_found
         
         	; Parcours de tous les bytes des 5 vecteurs
         	; => ADDON non trouve si tous les octets sont a 0xFF car 0xFFFF n'est
         	;    pas un opcode valide et correspond a la valeur apres un "erase"
C:000042 9631      	adiw		REG_Z_LSB, 1
C:000043 951a      	dec		REG_TEMP_R17
C:000044 f7d1      	brne		addon_search_loop
         
          addon_not_found:
C:000045 c005      	rjmp		addon_end
         
          addon_found:
C:000046 9100 0060 	lds		REG_TEMP_R16, G_BEHAVIOR
C:000048 6100      	sbr		REG_TEMP_R16, FLG_BEHAVIOR_ADDON_FOUND_MSK
C:000049 9300 0060 	sts		G_BEHAVIOR, REG_TEMP_R16
         
          addon_end:
C:00004b 9508      	ret
         ; -----------
         
         ; -----------
         ; Appel eventuel a l'extension contenue dans 'REG_TEMP_R17'
         ; 1 - EXTENSION_SETUP
         ; 2 - EXTENSION_BACKGROUND
         ; 3 - EXTENSION_1_MS
         ; 4 - EXTENSION_COMMANDS
         ; 5 - EXTENSION_BUTTON
         ; -----------
          exec_extension_addon:
C:00004c 9120 0060 	lds		REG_TEMP_R18, G_BEHAVIOR
C:00004e ff24      	sbrs		REG_TEMP_R18, FLG_BEHAVIOR_ADDON_FOUND_IDX
C:00004f c006      	rjmp		exec_extension_addon_rtn
         
         	; Appel au vecteur @ 'REG_TEMP_R17'
C:000050 e4e3      	ldi		REG_Z_LSB, low(end_of_prg_uos)
C:000051 e0f7      	ldi		REG_Z_MSB, high(end_of_prg_uos)
C:000052 0fe1      	add		REG_Z_LSB, REG_TEMP_R17
C:000053 2711      	clr		REG_TEMP_R17	
C:000054 1ff1      	adc		REG_Z_MSB, REG_TEMP_R17
         
C:000055 9509      	icall
         	; Fin: Appel au vecteur @ 'REG_TEMP_R17'
         
          exec_extension_addon_rtn:
C:000056 9508      	ret
         ; -----------
         
          text_whoami:
          #ifndef USE_MINIMALIST_UOS
          .db	"### ATtiny85_uOS $Revision: 1.35 $", CHAR_LF, CHAR_NULL
C:000057 23232320415474696E7938355F754F5320245265766973696F6E3A20312E333520240A00
          #else
          #endif
         
          .include		"ATtiny85_uOS_Macros.def"
         ; "$Id: ATtiny85_uOS_Macros.def,v 1.1 2025/11/25 17:29:59 administrateur Exp $
         
          .cseg
         ; --------
         ; Macros de pilotage du PORTB en sortie
          .macro setLedRedOff			; 0/1: On/Off
          	cbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	; Led RED Externe eteinte (Pulse --\_/--- possible)
          	sbr		REG_PORTB_OUT, MSK_BIT_LED_RED	
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedRedOn			; 0/1: On/Off
          	sbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	; Led RED Externe allumee (Pulse --\_/--- inhibee)
          	cbr		REG_PORTB_OUT, MSK_BIT_LED_RED
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedYellowOff		; 0/1: On/Off
          	sbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW	
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedYellowOn		; 0/1: On/Off
          	cbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedGreenOff		; 0/1: On/Off
          	sbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedGreenOn			; 0/1: On/Off
          	cbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN	
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedRedIntOn		; 0/1: Off/On
          	sbr		REG_PORTB_OUT, MSK_BIT_LED_RED_INT
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setLedRedIntOff		; 0/1: Off/On
          	cbr		REG_PORTB_OUT, MSK_BIT_LED_RED_INT
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setPulseItUp			; Sortie au niveau haut de la pulse It
          	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setPulseItDown		; Sortie au niveau bas de la pulse It
          	cbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setTxdLow				; 0: Low
          	cbr		REG_PORTB_OUT, MSK_BIT_TXD
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         
          .macro setTxdHigh				; 1: High
          	sbr		REG_PORTB_OUT, MSK_BIT_TXD
          	out		PORTB, REG_PORTB_OUT					; Raffraichissement du PORTB
          .endm
         ; Fin: Macros de pilotage du PORTB en sortie
         
         ; End of file
         
          
         
          .include		"ATtiny85_uOS_Misc.asm"
         ; "$Id: ATtiny85_uOS_Misc.asm,v 1.13 2025/12/17 12:45:46 administrateur Exp $"
         
          .include		"ATtiny85_uOS_Misc.h"
         ; "$Id: ATtiny85_uOS_Misc.h,v 1.3 2025/12/14 17:28:44 administrateur Exp $"
         
         ; Forcage des 'call' en 'rcall' dans la cas de la generation "minimaliste"
         ; => '_CALL' force un "rcall" (appel relatif)
         ;    => 
         
          #ifdef USE_MINIMALIST_UOS
          #else
          .macro _CALL
          call		@0
          .endm
          #endif
         ; Fin: Forcage des 'call' en 'rcall' dans la cas de la generation "minimaliste"
         
         ; Definitions pour le calcul du crc8-maxim
          #define	CRC8_POLYNOMIAL	0x8C			; Masque pour le calcul du CR8-MAXIM
         
          .dseg
D:000068    G_CALC_CRC8:		.byte		1				; Calcul du crc8-maxim cumulee byte par byte
         
         ; End of file
         
          
         
          .cseg
         ; ---------
         ; Initialisation de la SRAM
         ; - Pas d'initialisation des 2 derniers bytes (retour de la fonction)
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_TEMP_R16 -> Valeur d'initialisation de la SRAM
         ; ---------
          init_sram_fill:
C:000069 ef0f      	ldi		REG_TEMP_R16, 0xff
C:00006a e0b2      	ldi		REG_X_MSB, high(ATTINY_RAMEND - 2)
C:00006b e5ad      	ldi		REG_X_LSB, low(ATTINY_RAMEND - 2)
         
          init_sram_fill_loop_a:
         	; Initialisation a 0xff de la STACK
         	; => Permet de connaitre la profondeur maximale de la pile d'appel
C:00006c 930c      	st			X, REG_TEMP_R16
C:00006d 9711      	sbiw		REG_X_LSB, 1
C:00006e 30b2      	cpi		REG_X_MSB, high(G_SRAM_END_OF_USE)
C:00006f f7e1      	brne		init_sram_fill_loop_a
C:000070 30aa      	cpi		REG_X_LSB, low(G_SRAM_END_OF_USE - 1)	
C:000071 f7d1      	brne		init_sram_fill_loop_a
         
C:000072 2700      	clr		REG_TEMP_R16
         
         	; Initialisation a 0x00 du reste de la SRAM
         	; => Permet de connaitre la profondeur de la pile d'appel
          init_sram_fill_loop_b:
C:000073 930c      	st			X, REG_TEMP_R16
C:000074 9711      	sbiw		REG_X_LSB, 1
C:000075 30b0      	cpi		REG_X_MSB, high(SRAM_START - 1)
C:000076 f7e1      	brne		init_sram_fill_loop_b
C:000077 35af      	cpi		REG_X_LSB, low(SRAM_START - 1)	
C:000078 f7d1      	brne		init_sram_fill_loop_b
         
         	; Fin initialisation [SRAM_START, ..., (ATTINY_RAMEND - 2)]
C:000079 9508      	ret
         ; ---------
         
         ; ---------
         ; Initialisation de valeurs particulieres dans la SRAM
         ;
         ; Variables initialisees:
         ; - G_TICK_1MS_LSB:G_TICK_1MS_MSB -> Periode pour 1mS a partir de 13uS
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_TEMP_R16
         ;    REG_TEMP_R17 
         ; ---------
          init_sram_values:
         	; Initialisation periode de 1mS @ 26uS
C:00007a e206      	ldi		REG_TEMP_R16, PERIODE_1MS
C:00007b 9300 0063 	sts		G_TICK_1MS_INIT, REG_TEMP_R16
C:00007d 9300 0062 	sts		G_TICK_1MS, REG_TEMP_R16
         
         	; Initialisation du chenillard Led GREEN
         	; => 1 creneau de 125mS  _/--\________ toutes les 1 Sec (mode non connecte)
C:00007f e001      	ldi		REG_TEMP_R16, 0x01
C:000080 9300 0064 	sts		G_CHENILLARD_MSB, REG_TEMP_R16
C:000082 9300 0065 	sts		G_CHENILLARD_LSB, REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_UOS
         	; Preparation reception bit RXD
C:000084 9100 00ab 	lds		REG_TEMP_R16, G_DURATION_DETECT_LINE_IDLE_MSB
C:000086 9110 00ac 	lds		REG_TEMP_R17, G_DURATION_DETECT_LINE_IDLE_LSB
         
C:000088 9300 00af 	sts		G_UART_CPT_LINE_IDLE_MSB, REG_TEMP_R16
C:00008a 9310 00ae 	sts		G_UART_CPT_LINE_IDLE_LSB, REG_TEMP_R17
         	; Fin: Preparation reception bit RXD
          #endif
         
         	; Initialisation des definitions pour la vitesse UART/Rx et UART/Tx
         	; Reprise des definitions de 'const_for_bauds_rate'
         	; @ 'G_BAUDS_IDX' recopie de l'EEPROM
         
            ; Lecture de l'index des Bauds
C:00008c e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_BAUDS_IDX);
C:00008d e0aa      	ldi		REG_X_LSB, low(EEPROM_ADDR_BAUDS_IDX);
C:00008e d344      	rcall		eeprom_read_byte
         
         	; Test dans la plage [0, 1, ..., 6]
         	; => Forcage a 1 pour 9600 bauds si pas dans la plage
C:00008f 3007      	cpi		REG_TEMP_R16, (6 + 1)
C:000090 f008      	brlo		init_sram_values_set_bauds_index
C:000091 e001      	ldi		REG_TEMP_R16, 1
         
          init_sram_values_set_bauds_index:
C:000092 9300 00a9 	sts		G_BAUDS_IDX, REG_TEMP_R16
         
C:000094 e0f7      	ldi		REG_Z_MSB, high(const_for_bauds_rate << 1)
C:000095 e8ea      	ldi		REG_Z_LSB, low(const_for_bauds_rate << 1)
         
         	; Pointage sur l'adresse ('const_for_bauds_rate' + 4 * 'G_BAUDS_IDX')
C:000096 9100 00a9 	lds		REG_TEMP_R16, G_BAUDS_IDX
C:000098 0f00      	lsl		REG_TEMP_R16						; x 2
C:000099 0f00      	lsl		REG_TEMP_R16						; x 2
C:00009a 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:00009b 2700      	clr		REG_TEMP_R16						; Report de la Carry
C:00009c 1ff0      	adc		REG_Z_MSB, REG_TEMP_R16
         
         	; Lecture des 4 definitions...
C:00009d 9115      	lpm		REG_TEMP_R17, Z+
C:00009e 9310 00aa 	sts		G_BAUDS_VALUE, REG_TEMP_R17
         
          #ifndef USE_MINIMALIST_UOS
C:0000a0 9115      	lpm		REG_TEMP_R17, Z+
C:0000a1 9310 00ab 	sts		G_DURATION_DETECT_LINE_IDLE_MSB, REG_TEMP_R17
C:0000a3 9115      	lpm		REG_TEMP_R17, Z+
C:0000a4 9310 00ac 	sts		G_DURATION_DETECT_LINE_IDLE_LSB, REG_TEMP_R17
C:0000a6 9115      	lpm		REG_TEMP_R17, Z+
C:0000a7 9310 00ad 	sts		G_DURATION_WAIT_READ_BIT_START, REG_TEMP_R17
          #endif
         	; Fin: Initialisation des definitions pour la vitesse UART/Rx et UART/Tx
         
C:0000a9 e002      	ldi		REG_TEMP_R16, CPT_CALIBRATION
C:0000aa 9300 0061 	sts		G_CALIBRATION, REG_TEMP_R16
         
C:0000ac 9508      	ret
         ; ---------
         
         ; ---------
         ; Initialisation du materiel
         ; - Cadencement a 26uS par le timer materiel #1 (ATtiny85 cadence a 16 MHz - 62.5 nS / cycle)
         ; - Detection changement d'etat sur RXD sur la pin PINB<0> (PCINT0)
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_TEMP_R16 -> Valeur d'initialisation des registres materiels
         ;
         ; Calculs pour le cadencement @ a la vitesse de l'UART logiciel (ATtiny85 cadence a 16 MHz)
         ; - Periode de PCK et CK: 62.5 nS
         ;   => Le but est de cadencer par debordement Timer/Counter1 a 26 uS 
         ;      => 26 uS correspondent a 26000/62.5 = 416 cycles d'horloge a 16 MHz
         ;         => 416 etant > 255 -> le prescaler TCCR1 est requis avec CS1[3:0]: Clock Select Bits 3, 2, 1, and 0
         ;         => Prescaler sur PCK: 1/2, 1/4, 1/8, 1/16 et 1/32
         ;            avec 5 configurations possibles; a savoir:
         ;            - 208 si prescaler /2  CS1[3:0]: 0010
         ;            - 104 si prescaler /4  CS1[3:0]: 0011
         ;            -  52 si prescaler /8  CS1[3:0]: 0100
         ;            -  26 si prescaler /16 CS1[3:0]: 0101
         ;            -  13 si prescaler /32 CS1[3:0]: 0110
         ; ---------
          init_hard:
         	; Configuration du timer materiel #1 pour une It toutes les 26uS
C:0000ad e10e      	ldi		REG_TEMP_R16, (MSK_BIT_PULSE_IT | MSK_BIT_LED_RED | MSK_BIT_LED_GREEN | MSK_BIT_LED_YELLOW | MSK_BIT_LED_RED_INT)
C:0000ae bb07      	out		DDRB, REG_TEMP_R16
         
         	; Initialisation du cadencement a 26 uS
         	; TCCR1: Timer/Counter1 Control Register
         	; - CTC1: Set Timer/Counter on Compare Match
         	; OCR1C: Timer/Counter1 Output Compare RegisterC (value)
C:0000af e802      	ldi		REG_TEMP_R16, (1 << CTC1 | 1 << CS11)					; CS1[3:0]: 0010
C:0000b0 ed10      	ldi		REG_TEMP_R17, (416 / 2)										; prescaler /2
         
          #if 0		; Sequences d'initialisations a titre de documentation ;-)
          #endif
         
C:0000b1 bf00      	out		TCCR1, REG_TEMP_R16
C:0000b2 0000      	nop
C:0000b3 bd1d      	out		OCR1C, REG_TEMP_R17
         	; Fin: Initialisation du cadencement a 26 uS
         
         	; TIMSK: Timer/Counter Interrupt Mask Register
         	; - OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
C:0000b4 e400      	ldi		REG_TEMP_R16, (1 << OCIE1A)
C:0000b5 bf09      	out		TIMSK, REG_TEMP_R16
         
         	; TIFR: Timer/Counter Interrupt Flag Register
         	; - OCF1A: Set Output Compare Flag 1A
C:0000b6 e400      	ldi		REG_TEMP_R16, (1 << OCF1A)
C:0000b7 bf08      	out		TIFR, REG_TEMP_R16
         	; Fin: Configuration du timer #1 pour une It toutes les 13uS
         
         	; Configuration de PINB<0> (RXD) pour une interruption sur changement d'etat --\__ et __/--
C:0000b8 e001      	ldi		REG_TEMP_R16, (1 << PCINT0)
C:0000b9 bb05      	out		PCMSK, REG_TEMP_R16
         
C:0000ba e200      	ldi		REG_TEMP_R16, (1 << PCIE)
C:0000bb bf0b      	out		GIMSK, REG_TEMP_R16
         
            ; Configuration du PULLUP sur PORTB<0> (RXD et Button)
C:0000bc e001         ldi      REG_TEMP_R16, 0x01
C:0000bd bb08         out      PORTB, REG_TEMP_R16
         
C:0000be 9508      	ret
         ; ---------
         
         ; ---------
         ; delay_big
         ; => Delay "long" de duree fixe @ REG_TEMP_R16, REG_TEMP_R17 et REG_TEMP_R18
         ;
         ; delay_big_2(REG_TEMP_R16)
         ; => Ne doit pas etre appelee sous It
         ;
          delay_big:
C:0000bf e208      	ldi		REG_TEMP_R16, 40
         
          delay_big_2:
C:0000c0 e71d      	ldi		REG_TEMP_R17, 125
         
          delay_big_more:
C:0000c1 ef2a      	ldi		REG_TEMP_R18, 250
         
          delay_big_more_1:
C:0000c2 952a      	dec		REG_TEMP_R18
C:0000c3 0000      	nop									; Wait 1 cycle
C:0000c4 f7e9      	brne		delay_big_more_1
C:0000c5 951a      	dec		REG_TEMP_R17
C:0000c6 f7d1      	brne		delay_big_more
C:0000c7 950a      	dec		REG_TEMP_R16
C:0000c8 f7b9      	brne		delay_big_2
C:0000c9 9508      	ret
         ; ---------
         
         ; ---------
         ; delay_1uS avec un ATtiny85 16 MHz
         ; => Delai de 1uS
         ;
          delay_1uS:
C:0000ca 0000      	nop				; 4 + 1 Cycles (rcall ou call + nop)
C:0000cb 0000      	nop				;   +	1
C:0000cc 0000      	nop				;   + 1
C:0000cd 0000      	nop				;   + 1
C:0000ce 0000      	nop				;   + 1
C:0000cf 0000      	nop				;   + 1
         
          #if 1
C:0000d0 0000      	nop				;   + 1
C:0000d1 0000      	nop				;   + 1
C:0000d2 0000      	nop				;   + 1
          #endif
         
C:0000d3 9508      	ret				;   + 4 = 18 Cycles ~= 1uS
         ; ---------
         
         ; ---------
         ; delay_1uS avec un ATtiny85 cadence a 16 MHz (62.5 nS / cycle)
         ; avec calibration...
         ;
         ; Warning: 'G_CALIBRATION' != 0
         ;
         ; Nbr de cycles @ 'REG_R5'
         ; - REG_R1 = 1 -> 12 cycles
         ; - REG_R1 = 2 -> 15 cycles (+3 cycles) -> 15 * 62.5 nS = 0.9375 uS => Valeur mesuree de ~1uS ;-)
         ; - REG_R1 = 3 -> 18 cycles (+3 cycles) -> 18 * 65.5 nS = 1.125 uS
         ; - etc.
         ;
          uos_delay_1uS:
C:0000d4 9050 0061 	lds		REG_R5, G_CALIBRATION		;  4 (rcall ou call) + 2 cycles
         
          uos_delay_1uS_loop:
C:0000d6 945a      	dec		REG_R5							; Content of 'REG_R5' x cycle(s)
C:0000d7 f7f1      	brne		uos_delay_1uS_loop			; +2 ou +1 cycles
         
C:0000d8 9508      	ret											; +4 cycles
         ; ---------
         
         ; ---------
          uos_delay_10uS:
C:0000d9 dffa      	rcall		uos_delay_1uS					; #0
C:0000da dff9      	rcall		uos_delay_1uS					; #1
C:0000db dff8      	rcall		uos_delay_1uS					; #2
C:0000dc dff7      	rcall		uos_delay_1uS					; #3
C:0000dd dff6      	rcall		uos_delay_1uS					; #4
C:0000de dff5      	rcall		uos_delay_1uS					; #5
C:0000df dff4      	rcall		uos_delay_1uS					; #6
C:0000e0 dff3      	rcall		uos_delay_1uS					; #7
C:0000e1 dff2      	rcall		uos_delay_1uS					; #8
C:0000e2 dff1      	rcall		uos_delay_1uS					; #9
         
C:0000e3 9508      	ret
         ; ---------
         
         ; ---------
         ; test_leds
         ; => Allumage des 3 Leds RED, GREEN et RED Interne
         ;    puis extinction une par une
         ;
          test_leds:
C:0000e4 2777      	clr		REG_PORTB_OUT
         
C:0000e5   +  	setLedRedOn
C:0000e5 6890      sbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:0000e6 7e7f      cbr		REG_PORTB_OUT, MSK_BIT_LED_RED
C:0000e7 bb78      out		PORTB, REG_PORTB_OUT					

C:0000e8   +  	setLedGreenOn
C:0000e8 7f77      cbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN	
C:0000e9 bb78      out		PORTB, REG_PORTB_OUT					

C:0000ea   +  	setLedYellowOn
C:0000ea 7f7b      cbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW
C:0000eb bb78      out		PORTB, REG_PORTB_OUT					

         
C:0000ec e500      	ldi		REG_TEMP_R16, 80
C:0000ed dfd3      	rcall		delay_big_more
         
C:0000ee   +  	setLedRedOff
C:0000ee 779f      cbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:0000ef 6170      sbr		REG_PORTB_OUT, MSK_BIT_LED_RED	
C:0000f0 bb78      out		PORTB, REG_PORTB_OUT					

C:0000f1 e500      	ldi      REG_TEMP_R16, 80
C:0000f2 dfce      	rcall		delay_big_more
         
C:0000f3   +  	setLedGreenOff
C:0000f3 6078      sbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN
C:0000f4 bb78      out		PORTB, REG_PORTB_OUT					

C:0000f5 e500      	ldi      REG_TEMP_R16, 80
C:0000f6 dfca      	rcall		delay_big_more
         
C:0000f7   +  	setLedYellowOff
C:0000f7 6074      sbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW	
C:0000f8 bb78      out		PORTB, REG_PORTB_OUT					

C:0000f9 e500      	ldi      REG_TEMP_R16, 80
C:0000fa dfc6      	rcall		delay_big_more
         
C:0000fb 9508      	ret
         ; ---------
         
         ; ---------
         ; Trace par un double creneau --\__/--\__/------ sur la Pulse It
         ; ---------
          trace_in_it_double_1uS:
C:0000fc dfcd      	rcall		delay_1uS
C:0000fd dfcc      	rcall		delay_1uS
C:0000fe 6170      	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:0000ff bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
C:000100 dfc9      	rcall		delay_1uS
C:000101 dfc8      	rcall		delay_1uS
C:000102 7e7f      	cbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:000103 bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
C:000104 dfc5      	rcall		delay_1uS
C:000105 dfc4      	rcall		delay_1uS
C:000106 6170      	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:000107 bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
         
C:000108 9508      	ret
         ; ---------
         
         ; ---------
         ; Maj du compteur d'erreurs
         ; ---------
          update_errors:
C:000109 9100 0067 	lds		REG_TEMP_R16, G_NBR_ERRORS
C:00010b 9503      	inc		REG_TEMP_R16
C:00010c 9300 0067 	sts		G_NBR_ERRORS, REG_TEMP_R16
C:00010e 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise sur voie de garage avec clignotement Led RED
         ; ---------
          forever_1:
C:00010f 94f8      	cli
C:000110 e104      	ldi		REG_TEMP_R16, 20	; Clignotement rapide
C:000111 c002      	rjmp		forever_init
         
          forever_2:
C:000112 94f8      	cli
C:000113 e208      	ldi		REG_TEMP_R16, 40	; Clignotement lent
         
          forever_init:
         	; Extinction de toutes les Leds
C:000114   +  	setLedGreenOff
C:000114 6078      sbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN
C:000115 bb78      out		PORTB, REG_PORTB_OUT					

C:000116   +  	setLedYellowOff
C:000116 6074      sbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW	
C:000117 bb78      out		PORTB, REG_PORTB_OUT					

C:000118   +  	setLedRedOff
C:000118 779f      cbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:000119 6170      sbr		REG_PORTB_OUT, MSK_BIT_LED_RED	
C:00011a bb78      out		PORTB, REG_PORTB_OUT					

C:00011b   +  	setLedRedIntOff
C:00011b 7f7d      cbr		REG_PORTB_OUT, MSK_BIT_LED_RED_INT
C:00011c bb78      out		PORTB, REG_PORTB_OUT					

         
          forever_loop:
C:00011d 930f      	push		REG_TEMP_R16			; Save/Restore temporisation dans REG_TEMP_R16
C:00011e   +  	setLedRedOn
C:00011e 6890      sbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:00011f 7e7f      cbr		REG_PORTB_OUT, MSK_BIT_LED_RED
C:000120 bb78      out		PORTB, REG_PORTB_OUT					

C:000121 df9e      	rcall		delay_big_2
C:000122 910f      	pop		REG_TEMP_R16
C:000123 930f      	push		REG_TEMP_R16
C:000124   +  	setLedRedOff
C:000124 779f      cbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:000125 6170      sbr		REG_PORTB_OUT, MSK_BIT_LED_RED	
C:000126 bb78      out		PORTB, REG_PORTB_OUT					

C:000127 df98      	rcall		delay_big_2
C:000128 910f      	pop		REG_TEMP_R16
C:000129 cff3      	rjmp		forever_loop
         ; ---------
         
         ; ---------
         ; Calcul du CRC8-MAXIM
         ;
         ; Input:  G_CALC_CRC8 and REG_TEMP_R16
         ; Output: G_CALC_CRC8 updated for retry
         ; ---------
          calc_crc8_maxim:
C:00012a 930f      	push		REG_TEMP_R16
C:00012b 931f      	push		REG_TEMP_R17
C:00012c 932f      	push		REG_TEMP_R18
C:00012d 933f      	push		REG_TEMP_R19
         
C:00012e 2f10      	mov		REG_TEMP_R17, REG_TEMP_R16
C:00012f 9130 0068 	lds		REG_TEMP_R19, G_CALC_CRC8
         
C:000131 e028      	ldi		REG_TEMP_R18, 8
         
          calc_crc8_maxim_loop_bit:
C:000132 2f03      	mov		REG_TEMP_R16, REG_TEMP_R19	; 'REG_TEMP_R19' contient le CRC8 calcule
C:000133 2701      	eor		REG_TEMP_R16, REG_TEMP_R17	; 'REG_TEMP_R17' contient le byte a inserer dans le polynome
C:000134 7001      	andi		REG_TEMP_R16, 0x01			; carry = ((crc ^ i__byte) & 0x01);
         
C:000135 94e8      	clt											; 'T' determine le report de la carry	
C:000136 f009      	breq		calc_crc8_maxim_a
C:000137 9468      	set
         
          calc_crc8_maxim_a:
C:000138 9536      	lsr		REG_TEMP_R19					; crc >>= 1;
C:000139 f416      	brtc		calc_crc8_maxim_b
         
C:00013a e80c      	ldi		REG_TEMP_R16, CRC8_POLYNOMIAL
C:00013b 2730      	eor		REG_TEMP_R19, REG_TEMP_R16					; crc ^= (carry ? CRC8_POLYNOMIAL: 0x00);
         
          calc_crc8_maxim_b:
C:00013c 9330 0068 	sts		G_CALC_CRC8, REG_TEMP_R19
         
C:00013e 9516      	lsr		REG_TEMP_R17									; i__byte >>= 1
         
C:00013f 952a      	dec		REG_TEMP_R18
C:000140 f789      	brne		calc_crc8_maxim_loop_bit
         
C:000141 913f      	pop		REG_TEMP_R19
C:000142 912f      	pop		REG_TEMP_R18
C:000143 911f      	pop		REG_TEMP_R17
C:000144 910f      	pop		REG_TEMP_R16
         
C:000145 9508      	ret
         ; ---------
         
          #if USE_DUMP_SRAM
          #endif
         
         ; End of file
         
          
          .include		"ATtiny85_uOS_Interrupts.asm"
         ; "$Id: ATtiny85_uOS_Interrupts.asm,v 1.6 2025/12/14 17:28:44 administrateur Exp $"
         
          .include		"ATtiny85_uOS_Interrupts.h"
         ; "$Id: ATtiny85_uOS_Interrupts.h,v 1.1 2025/11/25 18:11:16 administrateur Exp $"
         
         ; Periode du tick materiel pour un ATtiny85 cadence a 20 Mhz
         ; Remarque: La duree de 26 uS permet un echantillonage pour gerer la liason
         ;           UART a 19200 bauds car 1 bit toutes les 52 uS
         ;           => Pour les vitesses 9600, 4800, ..., 600 et 300 bauds la duree
         ;              d'echantillonage est un multiple de 26 uS ;-)
         ;
          #define	PERIODE_1MS					(1000 / 26)		; Cadencement par TMR0 de 26 uS
         
         ; Definition de la pin PINB<0> (INT0) dediee a RXD
          #define	IDX_BIT_RXD					IDX_BIT0
         
         ; End of file
         
          
         
          .cseg
         ; ---------
         ; tim1_compa_isr
         ;
         ; Methode appele a chaque expiration du timer #1 interne (26 uS)
         ;
         ; => Traitements (Nbr de cycles maximal):
         ;    0 - Entree dans l'It + gestion de la pulse         -> 33 cycles max
         ;
         ;    1 - tim1_compa_isr_acq_rxd:     Acquisition de RXD pour detection ligne IDLE   -> 18 cycles max
         ;    2 - tim1_compa_isr_tx_send_bit: Emission d'un bit sur TXD + uart_fifo_rx_write -> 39 + 30 cycles max
         ;    3 - tim1_compa_isr_rx_rec_bit:  Reception d'un bit sur RXD                     -> 67 cycles max
         ;    4 - tim1_compa_isr_cpt_1ms:     Comptabilisation de 1 mS                       -> 15 cycles max
         ;
         ;      - Sortie de l'It + gestion de la pulse           -> 28 cycles max
         ;
         ;    => Total si les 4 traitements sont executes dans le meme tick: 28 + 169 + 33 = 230 cycles max
         ;
         ; Registres utilises:
         ;    REG_X_LSB:REG_X_MSB -> Comptabilisation des ticks dans 'G_TICK_1MS'
         ;    REG_TEMP_R16        -> Travail
         ;    REG_TEMP_R17        -> Travail
         ;    REG_TEMP_R18        -> Travail
         ;    REG_TEMP_R19        -> Travail
         ;    REG_PORTB_OUT       -> Image du PORTB
         ;    REG_SAVE_SREG       -> Sauvegarde temporaire de SREG
         ; ---------
          tim1_compa_isr:
C:000146 92ff      	push		REG_SAVE_SREG
C:000147 b6ff      	in			REG_SAVE_SREG, SREG
         
C:000148 93af      	push		REG_X_LSB
C:000149 93bf      	push		REG_X_MSB
C:00014a 930f      	push		REG_TEMP_R16
C:00014b 931f      	push		REG_TEMP_R17
C:00014c 932f      	push		REG_TEMP_R18
C:00014d 933f      	push		REG_TEMP_R19
C:00014e 934f      	push		REG_TEMP_R20
C:00014f 935f      	push		REG_TEMP_R21
C:000150 936f      	push		REG_TEMP_R22
         
         ; ---------
         	; Determination du comportement
C:000151 9100 0060 	lds		REG_TEMP_R16, G_BEHAVIOR
C:000153 ff00      	sbrs		REG_TEMP_R16, FLG_BEHAVIOR_MARK_IN_TIM1_COMPA_IDX
C:000154 c002      	rjmp		tim1_compa_isr_more
         
         	; Creneau --\_/--- pour indiquer la charge de travail dans l'It
         	; => Pas de maj de 'REG_PORTB_OUT' si Led RED Externe allumee (sortie a 0)
         	;    => Revient a ne pas generer la Pulse --\_/----
C:000155 ff97      	sbrs		REG_FLAGS_1, FLG_1_LED_RED_ON_IDX
C:000156 7e7f      	cbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
         
          tim1_compa_isr_more:
C:000157 bb78      	out		PORTB, REG_PORTB_OUT						; Raffraichissement du PORTB
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         	; Lecture RXD pour detecter la ligne IDLE si pas deja detectee
C:000158 fd81      	sbrc		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_IDX		; Line IDLE detectee ?
C:000159 c013      	rjmp		tim1_compa_isr_tx_send_bit								; Oui => Ignore acquisition
         
         ; ---------
         	; Acquisition de RXD pour detection ligne IDLE (RXD durant au moins 10 bits -> 10 * 104 uS)
          tim1_compa_isr_acq_rxd:
C:00015a 9bb0      	sbis		PINB, IDX_BIT_RXD
C:00015b c008      	rjmp		tim1_compa_isr_acq_rxd_low
         
          tim1_compa_isr_acq_rxd_high:
C:00015c 91b0 00af 	lds		REG_X_MSB, G_UART_CPT_LINE_IDLE_MSB		; Reprise du compteur
C:00015e 91a0 00ae 	lds		REG_X_LSB, G_UART_CPT_LINE_IDLE_LSB
         
C:000160 9711      	sbiw		REG_X_LSB, 1						; X -= 1 sur 16 bits
C:000161 f439      	brne		tim1_compa_isr_acq_rxd_end
         
         	; RXD a l'etat haut durant au moins 11 bits => Detection ligne IDLE
C:000162 6082      	sbr		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_MSK
C:000163 c005      	rjmp		tim1_compa_isr_acq_rxd_end
         
          tim1_compa_isr_acq_rxd_low:
C:000164 7f8d      	cbr		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_MSK
         
C:000165 91b0 00ab 	lds		REG_X_MSB, G_DURATION_DETECT_LINE_IDLE_MSB		; RXD a l'etat bas ->  Reinit compteur
C:000167 91a0 00ac 	lds		REG_X_LSB, G_DURATION_DETECT_LINE_IDLE_LSB
         
          tim1_compa_isr_acq_rxd_end:
C:000169 93b0 00af 	sts		G_UART_CPT_LINE_IDLE_MSB, REG_X_MSB		; Maj compteur d'acquisition
C:00016b 93a0 00ae 	sts		G_UART_CPT_LINE_IDLE_LSB, REG_X_LSB
         	; Fin: Acquisition de RXD pour detection ligne IDLE
          #endif
         
         ; ---------
         	; Emission d'un bit sur TXD
          tim1_compa_isr_tx_send_bit:
C:00016d ff84      	sbrs		REG_FLAGS_0, FLG_0_UART_TX_TO_SEND_IDX			; Byte a emettre TXD ?
         
          #ifndef USE_MINIMALIST_UOS
C:00016e c021      	rjmp		tim1_compa_isr_rx_rec_bit							; Non
          #else
          #endif
         
C:00016f 9120 00b3 	lds		REG_TEMP_R18, G_UART_CPT_NBR_BITS_TX			; Oui: Compteur de bits [11, 10, 9, ..., 0]
C:000171 9110 00b1 	lds		REG_TEMP_R17, G_UART_CPT_DURATION_1BIT_TX		;      Compteur d'attente 104 uS [3, 2, 1, 0]  
C:000173 2311      	tst		REG_TEMP_R17											; Fin de la duree d'attente de 104 uS ?
C:000174 f4b1      	brne		tim1_compa_isr_tx_send_bit_dec_duration
         
         	; Au 1st traitement, 'G_UART_CPT_DURATION_1BIT_TX' est initialise a 0 pour debuter
         	; immediatement la 1st attente de 104 uS -> reste donc 3 attentes a comptabiliser pour
         	; emettre le bit suivant
         	; 'G_UART_CPT_NBR_BITS_TX' est initialise a 11 pour 10 bits car represente 0 correspondra
         	; a la fin du 10th bits -> Effacement de 'FLG_0_UART_TX_TO_SEND' pour indiquer la fin
         	; de l'emission des 1 Bit Start + 8 Datas + 1, 2, ... Bit(s) Stop
         
         	; Initialisation pour un Baud Rate configurable
C:000175 9110 00aa 	lds		REG_TEMP_R17, G_BAUDS_VALUE
         
C:000177 9150 00b6 	lds		REG_TEMP_R21, G_UART_BYTE_TX_LSB	; Reprise de la serialisation
C:000179 9160 00b7 	lds		REG_TEMP_R22, G_UART_BYTE_TX_MSB
         
C:00017b 7f7d      	cbr		REG_PORTB_OUT, MSK_BIT_TXD			; Emission d'un '0' a priori
C:00017c fd50      	sbrc		REG_TEMP_R21, 0						; par rapport a REG_TEMP_R21<0>
         
C:00017d 6072      	sbr		REG_PORTB_OUT, MSK_BIT_TXD			; ... et non, emission d'un '1'
         
C:00017e bb78      	out		PORTB, REG_PORTB_OUT					; Ecriture PORTB sans attendre la sortie de l'It
         
C:00017f 9408      	sec													; Propagation Carry a 1 (MSB ne contient que des '1' ;-)
C:000180 9567      	ror		REG_TEMP_R22							; Serialisation...
C:000181 9557      	ror		REG_TEMP_R21							; Preparation nouveau REG_TEMP_R21<0> a emettre
         
C:000182 9350 00b6 	sts		G_UART_BYTE_TX_LSB, REG_TEMP_R21	; Maj pour la prochaine expiration des 104 uS
C:000184 9360 00b7 	sts		G_UART_BYTE_TX_MSB, REG_TEMP_R22
         
C:000186 952a      	dec		REG_TEMP_R18										; Test si les 10 bits ont ete emis ?
C:000187 f421      	brne		tim1_compa_isr_tx_send_bit_update
         
C:000188 7e8f      	cbr		REG_FLAGS_0, FLG_0_UART_TX_TO_SEND_MSK		; Oui: Fin de l'emission des 10 bits
         
C:000189 6072      	sbr		REG_PORTB_OUT, MSK_BIT_TXD    	; TXD a l'etat haut
C:00018a c005      	rjmp		tim1_compa_isr_tx_send_bit_end
         
          tim1_compa_isr_tx_send_bit_dec_duration:
C:00018b 951a      	dec		REG_TEMP_R17
         
          tim1_compa_isr_tx_send_bit_update:
C:00018c 9310 00b1 	sts		G_UART_CPT_DURATION_1BIT_TX, REG_TEMP_R17
C:00018e 9320 00b3 	sts		G_UART_CPT_NBR_BITS_TX, REG_TEMP_R18
         
          tim1_compa_isr_tx_send_bit_end:
         	; Fin: Emission d'un bit sur TXD
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         	; Reception d'un bit sur RXD
         	; => Acquisition si 'FLG_0_UART_DETECT_LINE_IDLE' et 'FLG_0_UART_DETECT_BIT_START' a 1 
          tim1_compa_isr_rx_rec_bit:
         
C:000190 ff81      	sbrs		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_IDX
C:000191 c041      	rjmp		tim1_compa_isr_rx_rec_bit_end
         
C:000192 ff82      	sbrs		REG_FLAGS_0, FLG_0_UART_DETECT_BIT_START_IDX
C:000193 c03f      	rjmp		tim1_compa_isr_rx_rec_bit_end
         
         	; Fin de la duree d'attente de 52uS (Bit Start) ou 104 uS (Data et Bit Stop) ?
C:000194 9110 00b0 	lds		REG_TEMP_R17, G_UART_CPT_DURATION_1BIT_RX
C:000196 9120 00b2 	lds		REG_TEMP_R18, G_UART_CPT_NBR_BITS_RX
         
C:000198 2311      	tst		REG_TEMP_R17
C:000199 f5b1      	brne		tim1_compa_isr_rx_rec_bit_dec_duration
         
         	; Marquage du moment d'acquisition
         	; Determination du comportement
C:00019a 9110 0060 	lds		REG_TEMP_R17, G_BEHAVIOR
C:00019c ff12      	sbrs		REG_TEMP_R17, FLG_BEHAVIOR_MARK_IN_RX_REC_BIT_IDX
C:00019d c003      	rjmp		tim1_compa_isr_rx_rec_bit_more
         
         	; => Pas de maj de 'REG_PORTB_OUT' si Led RED Externe allumee (sortie a 0)
         	;    => Revient a ne pas generer la Pulse --\_/----
C:00019e ff97      	sbrs		REG_FLAGS_1, FLG_1_LED_RED_ON_IDX
C:00019f 7e7f      	cbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:0001a0 bb78      	out		PORTB, REG_PORTB_OUT						; Raffraichissement du PORTB
         
          tim1_compa_isr_rx_rec_bit_more:
         	; Reinitialisation de la duree d'attente
C:0001a1 9110 00aa 	lds		REG_TEMP_R17, G_BAUDS_VALUE
C:0001a3 9310 00b0 	sts		G_UART_CPT_DURATION_1BIT_RX, REG_TEMP_R17
         
         	; Lecture RXD au milieu bit
C:0001a5 9488      	clc											; A priori RXD a 0
C:0001a6 99b0      	sbic		PINB, IDX_BIT_RXD
C:0001a7 9408      	sec											; et Non: RXD a 1
         
C:0001a8 9160 00b5 	lds		REG_TEMP_R22, G_UART_BYTE_RX_MSB		; Reprise du mot de reception RXD sur 16 bits
C:0001aa 9150 00b4 	lds		REG_TEMP_R21, G_UART_BYTE_RX_LSB
C:0001ac 9567      	ror		REG_TEMP_R22								; Construction de sDDD DDDD DS00 0000 ([S]tart/[s]top)
C:0001ad 9557      	ror		REG_TEMP_R21								; par propagation de la Carry (Bit LSB recu en premier)
C:0001ae 9360 00b5 	sts		G_UART_BYTE_RX_MSB, REG_TEMP_R22
C:0001b0 9350 00b4 	sts		G_UART_BYTE_RX_LSB, REG_TEMP_R21
         
         	; Fin: Marquage du moment d'acquisition
         	; => Pas de maj de 'REG_PORTB_OUT' si Led RED Externe allumee (sortie a 0)
         	;    => Revient a ne pas generer la Pulse --\_/----
C:0001b2 fd97      	sbrc		REG_FLAGS_1, FLG_1_LED_RED_ON_IDX
C:0001b3 c003      	rjmp		tim1_compa_isr_rx_rec_ignore_pulse
         
C:0001b4 df15      	rcall		delay_1uS
C:0001b5 df14      	rcall		delay_1uS
C:0001b6 6170      	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
         
          tim1_compa_isr_rx_rec_ignore_pulse:
C:0001b7 bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
         
         	; Comptabilisation du bit lu
C:0001b8 952a      	dec		REG_TEMP_R18
C:0001b9 9320 00b2 	sts		G_UART_CPT_NBR_BITS_RX, REG_TEMP_R18
         
C:0001bb f4b9      	brne		tim1_compa_isr_rx_rec_bit_end
         
         	; Les 10 ont ete lus...
         	; => Bit Start de nouveau a detecter
C:0001bc 7f8b      	cbr		REG_FLAGS_0, FLG_0_UART_DETECT_BIT_START_MSK
         
         	; Extraction des Bits Start/Stop et 8 bits de donnees
C:0001bd 0f55      	lsl		REG_TEMP_R21	; Recuperation des 8 bits dans 'REG_TEMP_R21' et Bit Stop dans la Carry
C:0001be 1f66      	rol		REG_TEMP_R22	; Donnees recues D7...D0 dans 'REG_TEMP_R22' et Bit Start dans 'REG_TEMP_R22<D7>'
         
         	; Reception complete (G_UART_BYTE_RX_MSB:LSB (R21:R22) ?= sDDD DDDD DS00 0000)
         	; => Test du bit Start ('0')
C:0001bf fd57      	sbrc		REG_TEMP_R21, IDX_BIT7			; Test du Bit Start dans 'REG_TEMP_R22<D7>' (erreur si a 1)
C:0001c0 c009      	rjmp		tim1_compa_isr_rx_rec_bit_start_err
         
         	; => Detection Break (Bit Stop a '0' et Datas a 0x00)
         	; => Test du bit Stop ('1')
C:0001c1 f020      	brcs		tim1_compa_isr_rx_rec_bit_ok	; Test du Bit Stop dans la Carry (Ok si a 1)
         
         	; => Test des Datas a 0x00
C:0001c2 2366      	tst		REG_TEMP_R22
C:0001c3 f441      	brne		tim1_compa_isr_rx_rec_bit_stop_err
         
          tim1_compa_isr_rx_rec_break:
         	; Detection d'un byte "break" (10 bits a 0 succedant un etat de RXD a 1)
C:0001c4 7f8e      	cbr		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_IDX		; Line Idle de nouveau a detecter
C:0001c5 c00d      	rjmp		tim1_compa_isr_rx_rec_bit_end
         
          tim1_compa_isr_rx_rec_bit_ok:
C:0001c6 2e16      	mov		REG_R1, REG_TEMP_R22
C:0001c7 d141      	rcall		uart_fifo_rx_write
          
C:0001c8 6088      	sbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_RECEIVED_MSK		; Donnee recue valide ou "Break" disponible
C:0001c9 c009      	rjmp		tim1_compa_isr_rx_rec_bit_end
         	; Reception complete sans erreur et byte recu disponible dans 'REG_TEMP_R21'
         
          tim1_compa_isr_rx_rec_bit_start_err:
C:0001ca 6480      	sbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_START_ERROR_MSK
C:0001cb c001      	rjmp		tim1_compa_isr_rx_rec_bit_err
         
          tim1_compa_isr_rx_rec_bit_stop_err:
C:0001cc 6880      	sbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_STOP_ERROR_MSK
         
          tim1_compa_isr_rx_rec_bit_err:
         	; Effacement des Flags pour une nouvelle reception correcte
C:0001cd 7f8c      	cbr		REG_FLAGS_0, (FLG_0_UART_DETECT_LINE_IDLE_IDX | FLG_0_UART_DETECT_BIT_START_IDX | FLG_0_UART_RX_BYTE_RECEIVED_IDX)
         
         	; Comptabilisation des erreurs RXD et FIFO
C:0001ce df3a      	rcall		update_errors
C:0001cf c003      	rjmp		tim1_compa_isr_rx_rec_bit_end
         
          tim1_compa_isr_rx_rec_bit_dec_duration:
C:0001d0 951a      	dec		REG_TEMP_R17
C:0001d1 9310 00b0 	sts		G_UART_CPT_DURATION_1BIT_RX, REG_TEMP_R17
         
          tim1_compa_isr_rx_rec_bit_end:
         	; Fin: Reception d'un bit sur RXD
         ; ---------
          #endif
         
         	; Comptabilisation de 1 mS
          tim1_compa_isr_cpt_1ms:
         	; => Si 'FLG_0_PERIODE_1MS' est a 1 (1mS atteinte a la precedente It) => Ne rien faire en attendre
         	;       que 'FLG_0_PERIODE_1MS' passe a 0
         	; => Sinon; si 'G_TICK_1MS' passe a 0 (1mS atteinte) => 'FLG_0_PERIODE_1MS' = 1 => Non maj 'G_TICK_1MS'
         	;    Sinon decrementation et maj 'G_TICK_1MS'
         	;
C:0001d3 fd80      	sbrc		REG_FLAGS_0, FLG_0_PERIODE_1MS_IDX
C:0001d4 c009      	rjmp		tim1_compa_isr_cpt_1ms_end
         
C:0001d5 91a0 0062 	lds		REG_X_LSB, G_TICK_1MS
C:0001d7 23aa      	tst		REG_X_LSB							; X ?= 0
C:0001d8 f411      	brne		tim1_compa_isr_cpt_1ms_dec		; 
         
C:0001d9 6081      	sbr		REG_FLAGS_0, FLG_0_PERIODE_1MS_MSK		; Oui: Set 'FLG_0_PERIODE_1MS'
C:0001da c003      	rjmp		tim1_compa_isr_cpt_1ms_end					; Fin sans maj de 'G_TICK_1MS'
         
          tim1_compa_isr_cpt_1ms_dec:
C:0001db 50a1      	subi		REG_X_LSB, 1			
C:0001dc 93a0 0062 	sts		G_TICK_1MS, REG_X_LSB
         
          tim1_compa_isr_cpt_1ms_end:
         	; Fin: Comptabilisation de 1 mS
         
         ; ---------
         	; Reecriture des flags generaux
         
         	; Fin: Creneau --\_/---
         	; => Pas de maj de 'REG_PORTB_OUT' si Led RED Externe allumee (sortie a 0)
         	;    => Revient a ne pas generer la Pulse --\_/----
C:0001de ff97      	sbrs		REG_FLAGS_1, FLG_1_LED_RED_ON_IDX
C:0001df 6170      	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:0001e0 bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
         
         	; Qualification 'delay_1uS'
C:0001e1 9110 0060 	lds		REG_TEMP_R17, G_BEHAVIOR
C:0001e3 ff17      	sbrs		REG_TEMP_R17, FLG_BEHAVIOR_CALIBRATION_1_uS
C:0001e4 c005      	rjmp		tim1_compa_isr_cpt_1ms_rtn
         
C:0001e5 7e7f      	cbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:0001e6 bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
         
C:0001e7 def1      	rcall		uos_delay_10uS
         
C:0001e8 6170      	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:0001e9 bb78      	out		PORTB, REG_PORTB_OUT				; Raffraichissement du PORTB
         	; Fin: Qualification 'delay_1uS'
         
          tim1_compa_isr_cpt_1ms_rtn:
C:0001ea 916f      	pop		REG_TEMP_R22
C:0001eb 915f      	pop		REG_TEMP_R21
C:0001ec 914f      	pop		REG_TEMP_R20
C:0001ed 913f      	pop		REG_TEMP_R19
C:0001ee 912f      	pop		REG_TEMP_R18
C:0001ef 911f      	pop		REG_TEMP_R17
C:0001f0 910f      	pop		REG_TEMP_R16
C:0001f1 91bf      	pop		REG_X_MSB
C:0001f2 91af      	pop		REG_X_LSB
         
C:0001f3 beff      	out		SREG, REG_SAVE_SREG
C:0001f4 90ff      	pop		REG_SAVE_SREG
         
C:0001f5 9518      	reti
         ; ---------
         
         ; ---------
         ; pcint0_isr
         ;
         ; Methode appelee sur changement d'etat sur PINB<0> (RXD)
         ; => Detection du Bit UART/START si REG_FLAGS_0<FLG_0_UART_DETECT_BIT_START> a 0
         ;    apres une detection reussie d'une ligne IDLE REG_FLAGS_0<FLG_0_UART_DETECT_LINE_IDLE> a 1
         ;    ou la reception d'un byte UART (1 Start + 8 Datas + 1 ou 2 Stop)
         ;
         ; Registres utilises (sauvegardes/restaures):
         ;    REG_TEMP_R16 -> Travail
         ;
         ; => Retour immediat si la directive 'USE_MINIMALIST_UOS' est definie
         ; ---------
          pcint0_isr:
         
          #ifndef USE_MINIMALIST_UOS
C:0001f6 92ff      	push		REG_SAVE_SREG
C:0001f7 b6ff      	in			REG_SAVE_SREG, SREG
         
C:0001f8 93bf      	push		REG_X_MSB
C:0001f9 93af      	push		REG_X_LSB
C:0001fa 93df      	push		REG_Y_MSB
C:0001fb 93cf      	push		REG_Y_LSB
C:0001fc 930f      	push		REG_TEMP_R16
C:0001fd 931f      	push		REG_TEMP_R17
C:0001fe 932f      	push		REG_TEMP_R18
C:0001ff 933f      	push		REG_TEMP_R19
         
         	; Fronts montant et descendant detectes sur RXD
C:000200 99b0      	sbic		PINB, IDX_BIT_RXD
C:000201 c001      	rjmp		pcint0_isr_rising			; RXD a 1
C:000202 c003      	rjmp		pcint0_isr_falling		; RXD a 0
         
          pcint0_isr_rising:
         
         	; Detection du front montant sur RXD __/--
         	; => Arret du timer 'TIMER_APPUI_BOUTON_DETECT'
C:000203 e014      	ldi		REG_TEMP_R17, TIMER_APPUI_BOUTON_DETECT
C:000204 d072      	rcall		stop_timer
         
C:000205 c02c      	rjmp		pcint0_isr_rtn
         
          pcint0_isr_falling:
C:000206 ff81      	sbrs		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_IDX		; Line IDLE detectee ?
C:000207 c02a      	rjmp		pcint0_isr_rtn												; Non => Ignore --\__ sur RXD
         
C:000208 fd82      	sbrc		REG_FLAGS_0, FLG_0_UART_DETECT_BIT_START_IDX		; Bit START detecte ?
C:000209 c028      	rjmp		pcint0_isr_rtn												; Oui => Ignore --\__ sur RXD
         
         	; Marquage du moment d'acquisition
         	; Determination du comportement
C:00020a 9110 0060 	lds		REG_TEMP_R17, G_BEHAVIOR
C:00020c ff11      	sbrs		REG_TEMP_R17, FLG_BEHAVIOR_MARK_IN_PCINT0_IDX
C:00020d c003      	rjmp		pcint0_isr_falling_more
         
         	; => Pas de maj de 'REG_PORTB_OUT' si Led RED Externe allumee (sortie a 0)
         	;    => Revient a ne pas generer la Pulse --\_/----
C:00020e ff97      	sbrs		REG_FLAGS_1, FLG_1_LED_RED_ON_IDX
C:00020f 7e7f      	cbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
C:000210 bb78      	out		PORTB, REG_PORTB_OUT						; Raffraichissement du PORTB
         
          pcint0_isr_falling_more:
         	; Raz erreurs Bits Start et Bit Stop
C:000211 7b8f      	cbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_START_ERROR_MSK
C:000212 778f      	cbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_STOP_ERROR_MSK
         
C:000213 6084      	sbr		REG_FLAGS_0, FLG_0_UART_DETECT_BIT_START_MSK		; Bit Start detecte
C:000214 7f87      	cbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_RECEIVED_MSK		; Donnee valide a recevoir
         
         	; Rearmement timer pour "annuler" tous les rebonds < 50mS
C:000215 e015      	ldi		REG_TEMP_R17, TIMER_RXD_ANTI_REBONDS
C:000216 e322      	ldi		REG_TEMP_R18, (50 % 256)
C:000217 e030      	ldi		REG_TEMP_R19, (50 / 256)
C:000218 ec4c      	ldi		REG_TEMP_R20, low(exec_timer_anti_rebound)
C:000219 e052      	ldi		REG_TEMP_R21, high(exec_timer_anti_rebound)
C:00021a d049      	rcall		start_timer
         
         	; Rearmement timer 'TIMER_APPUI_BOUTON_DETECT'
C:00021b e014      	ldi		REG_TEMP_R17, TIMER_APPUI_BOUTON_DETECT
C:00021c e624      	ldi		REG_TEMP_R18, (100 % 256)
C:00021d e030      	ldi		REG_TEMP_R19, (100 / 256)
C:00021e eb4b      	ldi		REG_TEMP_R20, low(exec_timer_push_button_detect)
C:00021f e052      	ldi		REG_TEMP_R21, high(exec_timer_push_button_detect)
C:000220 d043      	rcall		start_timer
         
         	; Preparation reception bit RXD
C:000221 9100 00ad 	lds		REG_TEMP_R16, G_DURATION_WAIT_READ_BIT_START		; Attente de 26uS * x avant de lire le Bit Start
C:000223 9300 00b0 	sts		G_UART_CPT_DURATION_1BIT_RX, REG_TEMP_R16
         
C:000225 e00a      	ldi		REG_TEMP_R16, 10			; 10 bits: 1 Bit Start + 8 Datas + 1 Bit Stop
C:000226 9300 00b2 	sts		G_UART_CPT_NBR_BITS_RX, REG_TEMP_R16
         
C:000228 2700      	clr		REG_TEMP_R16
C:000229 9300 00b5 	sts		G_UART_BYTE_RX_MSB, REG_TEMP_R16
C:00022b 9300 00b4 	sts		G_UART_BYTE_RX_LSB, REG_TEMP_R16
         	; Fin: Preparation reception bit RXD (a supprimer a terme)
         
         	; Fin: Marquage du moment d'acquisition
         	; => Pas de maj de 'REG_PORTB_OUT' si Led RED Externe allumee (sortie a 0)
         	;    => Revient a ne pas generer la Pulse --\_/----
C:00022d fd97      	sbrc		REG_FLAGS_1, FLG_1_LED_RED_ON_IDX
C:00022e c002      	rjmp		pcint0_isr_ignore_pulse
         
C:00022f decc      	rcall		trace_in_it_double_1uS
C:000230 6170      	sbr		REG_PORTB_OUT, MSK_BIT_PULSE_IT
         
          pcint0_isr_ignore_pulse:
C:000231 bb78      	out		PORTB, REG_PORTB_OUT						; Raffraichissement du PORTB
         
          pcint0_isr_rtn:
C:000232 913f      	pop		REG_TEMP_R19
C:000233 912f      	pop		REG_TEMP_R18
C:000234 911f      	pop		REG_TEMP_R17
C:000235 910f      	pop		REG_TEMP_R16
C:000236 91cf      	pop		REG_Y_LSB
C:000237 91df      	pop		REG_Y_MSB
C:000238 91af      	pop		REG_X_LSB
C:000239 91bf      	pop		REG_X_MSB
         
C:00023a beff      	out		SREG, REG_SAVE_SREG
C:00023b 90ff      	pop		REG_SAVE_SREG
         
          #endif
         
C:00023c 9518      	reti
         ; ---------
          ; ---------
          .include		"ATtiny85_uOS_Timers.asm"
         ; "$Id: ATtiny85_uOS_Timers.asm,v 1.23 2025/12/15 22:42:20 administrateur Exp $"
         
          .include		"ATtiny85_uOS_Timers.h"
         ; "$Id: ATtiny85_uOS_Timers.h,v 1.12 2025/12/17 22:16:43 administrateur Exp $"
         
         ; Attribution des 'NBR_TIMER' timers #0, #1, ..., #15
         ; => Limitation a 8 timers dans la cas 'USE_MINIMALIST_UOS' (#0, #1, ..., #7)
         ; => Le traitement associe a chaque timer est effectue dans l'ordre de son index
          #ifndef USE_MINIMALIST_UOS
          #define	NBR_TIMER							16
          #else
          #endif
         
          #define	TIMER_CONNECT						0
          #define	TIMER_ERROR							1
          #define	TIMER_LED_GREEN					2
         
          #ifndef USE_MINIMALIST_UOS
         ; Pas de gestion de UART/Rx et des Commandes dans le cas 'USE_MINIMALIST_UOS' ;-)
          #define	TIMER_APPUI_BOUTON_LED			3
          #define	TIMER_APPUI_BOUTON_DETECT		4
          #define	TIMER_RXD_ANTI_REBONDS			5
          #endif
         
          #if USE_DUMP_SRAM
          #endif
         
          .dseg
         
         ; Valeurs sur 16 bits des 'NBR_TIMER' accedees par indexation @ G_TIMER_0_LSB:G_TIMER_0_MSB
D:000069    G_TIMER_0:						.byte		2
D:00006b    G_TIMER_SPACE:					.byte		2 * (NBR_TIMER - 1)
         
         ; Contextes sur 16 bits des 'NBR_TIMER' accedees par indexation @ 'G_TIMER_ADDRESS_0'
         ; => Le contexte est en fait l'adresse d'execution du callback
         ;    => TODO: A renommer...
D:000089    G_TIMER_ADDRESS_0:			.byte		2	; 2 bytes pour le contexte
D:00008b    G_TIMER_ADDRESS_SPACE_0:	.byte		2 * (NBR_TIMER - 1)
         
         ; End of file
         
          
         
          .cseg
         
         ; ---------
         ; Gestion des timers 16 bits; Durees [0, 1 mS, ..., ~65 Sec]
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_X_LSB:REG_X_MSB -> Valeur du timer #N et decrementation sur 16 bits
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_Z_LSB:REG_Z_MSB -> Adresse d'execution a l'expiration du timer #N (au moyen de 'icall' @Z)
         ;    REG_TEMP_R16        -> Compteur Timer #N dans la plage [#0, #1, #(NBR_TIMER - 1)]
         ; ---------
          gestion_timer:
         	; Comptabilisation dans tous les timers armes
C:00023d 2700      	clr		REG_TEMP_R16
         
C:00023e e6c9      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)			; Table des valeurs sur 16 bits des timers
C:00023f e0d0      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)	
         
          gestion_timer_loop:
C:000240 81a8      	ldd		REG_X_LSB, Y+0					; X = Duree du Timer #N
C:000241 81b9      	ldd		REG_X_MSB, Y+1
C:000242 9610      	adiw		REG_X_LSB, 0					; Duree ?= 0
C:000243 f0d1      	breq		gestion_timer_next			; Passage au prochain timer si duree a 0
         
          gestion_timer_decrement:
         	; Le Timer #N est arme et non expire => Decrementation sur 16 bits et mise a jour duree
C:000244 9711      	sbiw		REG_X_LSB, 1
         
C:000245 83a8      	std		Y+0, REG_X_LSB
C:000246 83b9      	std		Y+1, REG_X_MSB
         
C:000247 f4b1      	brne		gestion_timer_next
         
         	; Sauvegarde du contexte
C:000248 930f      	push		REG_TEMP_R16
C:000249 93ef      	push		REG_Z_LSB
C:00024a 93ff      	push		REG_Z_MSB
C:00024b 93cf      	push		REG_Y_LSB
C:00024c 93df      	push		REG_Y_MSB
C:00024d 93af      	push		REG_X_LSB
C:00024e 93bf      	push		REG_X_MSB
         
         	; Timer #N expire => Execution la methode initialisee dans le contexte si != 0x0000
C:00024f d049      	rcall		get_address_timer	
         
C:000250 2344      	tst		REG_TEMP_R20
C:000251 f419      	brne		gestion_timer_execute
C:000252 2355      	tst		REG_TEMP_R21
C:000253 f409      	brne		gestion_timer_execute
         
         	; L'adresse est a 0x0000 -> Ignore
C:000254 c002      	rjmp		gestion_timer_restore
         
          gestion_timer_execute:
         	; L'adresse n'est pas a 0x0000 -> Execution effective @ Z ...
C:000255 01fa      	movw		REG_Z_LSB, REG_TEMP_R20			; Adresse d'execution
C:000256 9509      	icall
         
          gestion_timer_restore:
         	; Restauration du contexte
C:000257 91bf      	pop		REG_X_MSB
C:000258 91af      	pop		REG_X_LSB
C:000259 91df      	pop		REG_Y_MSB
C:00025a 91cf      	pop		REG_Y_LSB
C:00025b 91ff      	pop		REG_Z_MSB
C:00025c 91ef      	pop		REG_Z_LSB
C:00025d 910f      	pop		REG_TEMP_R16
         
          gestion_timer_next:
         	; Passage au prochain timer
C:00025e 9631      	adiw		REG_Z_LSB, 1					; Adresse du traitement associe au prochain timer
C:00025f 9622      	adiw		REG_Y_LSB, 2					; Acces au prochain timer de 16 bits
C:000260 9503      	inc		REG_TEMP_R16					; +1 dans le compteur de timer
C:000261 3100      	cpi		REG_TEMP_R16, NBR_TIMER		; Tous les timers sont maj [#0, #1, #(NBR_TIMER - 1)] ?
C:000262 f6e9      	brne		gestion_timer_loop			; TBC: brmi
         
          gestion_timer_rtn:
C:000263 9508      	ret
         ; ---------
         
         ; ---------
         ; Armement d'un timer #N avec une duree sur 16 bits
         ; => La duree est ajoutee a celle restante permettant ainsi un rearmement
         ;    avant l'expiration a l'image d'un watchdog
         ;    => Warning: le timer peut ne jamais expirer si plusieurs armement sans un 'stop_timer'
         ;                car la duree est augmentee a chaque armement
         ;
         ; Usage:
         ;      ldi        REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      ldi			REG_TEMP_R18, <timer_value_lsb>   ; LSB value
         ;      ldi			REG_TEMP_R19, <timer_value_msb>   ; MSB value
         ;      ldi			REG_TEMP_R20, <address_lsb>   	 ; LSB value
         ;      ldi			REG_TEMP_R21, <address_msb>   	 ; MSB value
         ;      rcall      start_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N (1st argument inchange apres execution)
         ;    REG_TEMP_R18        -> Duration LSB (2nd argument)
         ;    REG_TEMP_R19        -> Duration MSB (3rd argument)
         ;    REG_TEMP_R20        -> Adresse LSB de la methode callback
         ;    REG_TEMP_R21        -> Adresse MSB de la methode callback
         ; ---------
          start_timer:
C:000264 931f      	push		REG_TEMP_R17
         
C:000265 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:000266 f470      	brsh		start_timer_rtn				; Ignore si REG_TEMP_R17 >= NBR_TIMER
         
         	; Calcul de l'offset...
C:000267 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
C:000268 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
         
C:000269 e6c9      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Adresse de base des timers
C:00026a e0d0      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:00026b 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:00026c 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
C:00026d 8328      	std		Y+0, REG_TEMP_R18					; Set duration LSB
C:00026e 8339      	std		Y+1, REG_TEMP_R19					; Set duration MSB
         
C:00026f e8c9      	ldi		REG_Y_LSB, (G_TIMER_ADDRESS_0 % 256)	; Adresse de base des adresses callback
C:000270 e0d0      	ldi		REG_Y_MSB, (G_TIMER_ADDRESS_0 / 256)
         
C:000271 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:000272 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:000273 8348      	std		Y+0, REG_TEMP_R20					; Set address LSB
C:000274 8359      	std		Y+1, REG_TEMP_R21					; Set address MSB
         
          start_timer_rtn:
C:000275 911f      	pop		REG_TEMP_R17
C:000276 9508      	ret
         ; ---------
         
         ; ---------
         ; Arret d'un timer #N
         ;
         ; Usage:
         ;      ldi     REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      rcall   stop_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16          -> Registre de travail
         ;    REG_TEMP_R17          -> Num timer #N (1st argument)
         ; ---------
          stop_timer:
C:000277 931f      	push		REG_TEMP_R17
         
C:000278 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:000279 f448      	brsh		stop_timer_rtn					; Ignore si REG_TEMP_R17 >= NBR_TIMER
         
C:00027a e6c9      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Non: Adresse de base des timers
C:00027b e0d0      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:00027c 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
C:00027d 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:00027e 9488      	clc
C:00027f 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:000280 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:000281 8308      	std		Y+0, REG_TEMP_R16				; Raz duration LSB
C:000282 8309      	std		Y+1, REG_TEMP_R16				; Raz duration MSB
         
          stop_timer_rtn:
C:000283 911f      	pop		REG_TEMP_R17
C:000284 9508      	ret
         ; ---------
         
         ; ---------
         ; Test d'un timer #N
         ;
         ; => La duree est retournee (a zero si time non arme ou expire)
         ;
         ; Usage:
         ;      ldi        REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      rcall      start_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N (1st argument inchange apres execution)
         ;    REG_TEMP_R20        -> Duration LSB restante ou 0
         ;    REG_TEMP_R21        -> Duration MSB restante ou 0
         ;
         ; Retour:
         ;    Bit T de SREG   -> 0/1: Non arme ou expire / Arme en cours de decrementation
         ; ---------
          test_timer:
C:000285 931f      	push		REG_TEMP_R17
         
C:000286 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:000287 f478      	brsh		test_timer_rtn					; Ignore si REG_TEMP_R17 >= NBR_TIMER
         
C:000288 e6c9      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Non: Adresse de base des timers
C:000289 e0d0      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:00028a 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
C:00028b 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:00028c 9488      	clc
C:00028d 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:00028e 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:00028f 8148      	ldd		REG_TEMP_R20, Y+0				; Maj dans R20:R21 de la duree restante du timer indexe par Y
C:000290 8159      	ldd		REG_TEMP_R21, Y+1
         
C:000291 9468      	set											; Timer a priori arme et non expire ...
C:000292 2344      	tst		REG_TEMP_R20
C:000293 f419      	brne		test_timer_rtn
C:000294 2355      	tst		REG_TEMP_R21
C:000295 f409      	brne		test_timer_rtn
         
C:000296 94e8      	clt											; ... et non => Timer non arme ou expire
         
          test_timer_rtn:
C:000297 911f      	pop		REG_TEMP_R17
C:000298 9508      	ret
         ; ---------
         
         ; ---------
         ; Get address de callback d'un timer #N
         ;
         ; Usage:
         ;      ldi        REG_TEMP_R16, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      rcall      get_address_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N
         ;
         ; Retour:
         ;    REG_TEMP_R20        -> Adresse LSB de la methode callback
         ;    REG_TEMP_R21        -> Adresse MSB de la methode callback
         ; ---------
          get_address_timer:
C:000299 3100      	cpi		REG_TEMP_R16, NBR_TIMER			; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:00029a f458      	brcc		get_address_timer_err			; Saut si REG_TEMP_R17 >= NBR_TIMER
         
C:00029b 930f      	push		REG_TEMP_R16						; Sauvegarde Num Timer
         
C:00029c e8c9      	ldi		REG_Y_LSB, (G_TIMER_ADDRESS_0 % 256)	; Non: Adresse de base des adresses callback
C:00029d e0d0      	ldi		REG_Y_MSB, (G_TIMER_ADDRESS_0 / 256)
         
C:00029e 0f00      	lsl		REG_TEMP_R16						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:00029f 2711      	clr		REG_TEMP_R17						; Indexation du timer #N
C:0002a0 0fc0      	add		REG_Y_LSB, REG_TEMP_R16			; YL += 2*N
C:0002a1 1fd1      	adc		REG_Y_MSB, REG_TEMP_R17			; Report C -> YH => Y contient l'adresse du timer #N
         
C:0002a2 8148      	ldd		REG_TEMP_R20, Y+0					; Maj dans R18:R19 du contexte
C:0002a3 8159      	ldd		REG_TEMP_R21, Y+1
         
          get_address_timer_end:
C:0002a4 910f      	pop		REG_TEMP_R16						; Restauration Num Timer
C:0002a5 9508      	ret
         
          get_address_timer_err:
C:0002a6 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         ; TIMER_CONNECT
         ; ---------
          exec_timer_connect:
         	; Passage en mode connecte pour une presentation Led GREEN --\__/-----
C:0002a7 7f97      	cbr		REG_FLAGS_1, FLG_1_CONNECTED_MSK
C:0002a8 7b8f      	cbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_START_ERROR_MSK		; Effacement erreur de reception
C:0002a9 778f      	cbr		REG_FLAGS_0, FLG_0_UART_RX_BYTE_STOP_ERROR_MSK		; Effacement erreur de reception
         
         	; Retour a la presentation "Non Connecte"
C:0002aa e001      	ldi		REG_TEMP_R16, 0x01
C:0002ab 9300 0064 	sts		G_CHENILLARD_MSB, REG_TEMP_R16
C:0002ad 9300 0065 	sts		G_CHENILLARD_LSB, REG_TEMP_R16
         
C:0002af 9508      	ret
         ; ---------
          #endif
         
         ; ---------
         ; TIMER_ERROR
         ; ---------
          exec_timer_error:
         	; Fin de la presentation des erreurs Bits Start et Bit Stop
C:0002b0 94f8      	cli
C:0002b1   +  	setLedRedOff
C:0002b1 779f      cbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:0002b2 6170      sbr		REG_PORTB_OUT, MSK_BIT_LED_RED	
C:0002b3 bb78      out		PORTB, REG_PORTB_OUT					

C:0002b4 9478      	sei
         
C:0002b5 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         ; TIMER_APPUI_BOUTON_LED
         ; ---------
          exec_timer_push_button_led:
C:0002b6 94f8      	cli
C:0002b7   +  	setLedYellowOff
C:0002b7 6074      sbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW	
C:0002b8 bb78      out		PORTB, REG_PORTB_OUT					

C:0002b9 9478      	sei
         
C:0002ba 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_APPUI_BOUTON_DETECT
         ; ---------
          exec_timer_push_button_detect:
         	; Presentation flash de 300mS sur Led YELLOW
C:0002bb 94f8      	cli
C:0002bc   +  	setLedYellowOn
C:0002bc 7f7b      cbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW
C:0002bd bb78      out		PORTB, REG_PORTB_OUT					

C:0002be 9478      	sei
         
C:0002bf e013      	ldi		REG_TEMP_R17, TIMER_APPUI_BOUTON_LED
C:0002c0 e22c      	ldi		REG_TEMP_R18, (300 % 256)
C:0002c1 e031      	ldi		REG_TEMP_R19, (300 / 256)
C:0002c2 eb46      	ldi		REG_TEMP_R20, low(exec_timer_push_button_led)
C:0002c3 e052      	ldi		REG_TEMP_R21, high(exec_timer_push_button_led)
C:0002c4 df9f      	rcall		start_timer
         	; Fin: Presentation flash de 300mS sur Led YELLOW
         
         	; Emission du prompt de l'appui button
C:0002c5 e0f5      	ldi		REG_Z_MSB, ((text_appui_bouton << 1) / 256)
C:0002c6 ecee      	ldi		REG_Z_LSB, ((text_appui_bouton << 1) % 256)
C:0002c7 d0cb      	rcall		push_text_in_fifo_tx
         
C:0002c8 6490      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK
         
         	; Prolongement si module ADDON detecte
C:0002c9 e014      	ldi		REG_TEMP_R17, EXTENSION_BUTTON
C:0002ca dd81      	rcall		exec_extension_addon
         
          exec_timer_push_button_detect_rtn:
C:0002cb 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_RXD_ANTI_REBONDS
         ; ---------
          exec_timer_anti_rebound:
C:0002cc 7f8b      	cbr		REG_FLAGS_0, FLG_0_UART_DETECT_BIT_START_MSK
C:0002cd 9508      	ret
         ; ---------
          #endif
         
         ; ---------
         ; TIMER_LED_GREEN
         ; ---------
          exec_timer_led_green:
         	; Recuperation du chenillard de presentation de la Led GREEN
C:0002ce 9100 0064 	lds		REG_TEMP_R16, G_CHENILLARD_MSB
C:0002d0 9110 0065 	lds		REG_TEMP_R17, G_CHENILLARD_LSB
         
         	; Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0>
C:0002d2 94f8      	cli
C:0002d3 6078      	sbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN		; Extinction a priori Led GREEN ...
C:0002d4 fd10      	sbrc		REG_TEMP_R17, IDX_BIT0
C:0002d5 7f77      	cbr		REG_PORTB_OUT, MSK_BIT_LED_GREEN		; ... en fait, Allumage Led GREEN
C:0002d6 9478      	sei
         	; Fin: Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0>
         
         	; Progression du chenillard
C:0002d7 9506      	lsr		REG_TEMP_R16							; G_CHENILLARD_MSB<0> -> Carry
C:0002d8 9517      	ror		REG_TEMP_R17							; Carry -> G_CHENILLARD_LSB<7> et G_CHENILLARD_LSB<0> -> Carry
         
C:0002d9 770f      	cbr		REG_TEMP_R16, MSK_BIT7				; Preparation '0' dans G_CHENILLARD_MSB<7> a priori ...
C:0002da f408      	brcc		exec_timer_led_green_more
C:0002db 6800      	sbr		REG_TEMP_R16, MSK_BIT7				; ... et non, '1' dans G_CHENILLARD_MSB<7>
         
          exec_timer_led_green_more:									; Ici, G_CHENILLARD_MSB<7> reflete la Carry
C:0002dc 9300 0064 	sts		G_CHENILLARD_MSB, REG_TEMP_R16
C:0002de 9310 0065 	sts		G_CHENILLARD_LSB, REG_TEMP_R17
         	; Fin: Chenillard de presentation de la Led GREEN
         
         	; Rearmement du Timer 'TIMER_LED_GREEN'
C:0002e0 e012      	ldi		REG_TEMP_R17, TIMER_LED_GREEN
C:0002e1 e72d      	ldi		REG_TEMP_R18, (125 % 256)
C:0002e2 e030      	ldi		REG_TEMP_R19, (125 / 256)
C:0002e3 ec4e      	ldi		REG_TEMP_R20, low(exec_timer_led_green)
C:0002e4 e052      	ldi		REG_TEMP_R21, high(exec_timer_led_green)
C:0002e5 df7e      	rcall		start_timer
         
C:0002e6 9508      	ret
         ; ---------
         
          #if USE_DUMP_SRAM
          #endif
         
          #ifndef USE_MINIMALIST_UOS
          text_appui_bouton:
          .db	"### uOS: Button action", CHAR_LF, CHAR_NULL
C:0002E7 23232320754F533A20427574746F6E20616374696F6E0A00
          #endif
         
          #if 1
          text_dump_sram:
          .db	"### Dump SRAM...", CHAR_LF, CHAR_NULL
C:0002F3 2323232044756D70205352414D2E2E2E0A00
          #endif
         
         ; End of file
         
          
          .include		"ATtiny85_uOS_Uart.asm"
         ; "$Id: ATtiny85_uOS_Uart.asm,v 1.7 2025/12/14 17:28:44 administrateur Exp $"
         
          .include    "ATtiny85_uOS_Uart.h"
         ; "$Id: ATtiny85_uOS_Uart.h,v 1.6 2025/12/14 17:28:44 administrateur Exp $"
         
          #ifndef USE_MINIMALIST_UOS
          #define	SIZE_UART_FIFO_RX		(1 << 5)		; 32 bytes -> Puissance de 2 pour un modulo par masque avec (SIZE_UART_FIFO_RX -1)
          #define	SIZE_UART_FIFO_TX		(1 << 6)		; 64 bytes -> Puissance de 2 pour un modulo par masque avec (SIZE_UART_FIFO_TX - 1)
          #else
          #endif
         
         ; Constantes pour les Bauds Rate:
         ; - DURATION_WAIT_READ_BIT_START: Lecture 26 uS * x apres le front descendant
         ;   - 9600 bauds: 1
         ;   - 4800 bauds: 2
         ;   ...
          #define	DURATION_WAIT_READ_BIT_START			(1)
         ;#define	DURATION_WAIT_READ_BIT_START			(2)
         ;   
         ; - NBR_BAUDS_VALUE:
         ;   - 9600 bauds: 104 uS / 26 uS = 4 -> 3
         ;   - 4800 bauds: 208 uS / 26 uS = 8 -> 7
         ;   ...
          #define	NBR_BAUDS_VALUE							(4 - 1)
         ;#define	NBR_BAUDS_VALUE							(7 - 1)
         
         ; - DURATION_DETECT_LINE_IDLE:
         ;   - 9600 bauds: (11 * 4 * 26) 			-> RXD a l'etat haut/bas pendant au moins 11 * 104 uS
         ;   - 4800 bauds: (11 * 4 * 26 * 2)		-> RXD a l'etat haut/bas pendant au moins 11 * 208 uS
         ;   ...
          #define	DURATION_DETECT_LINE_IDLE				(11 * 4 * 26)
         ;#define	DURATION_DETECT_LINE_IDLE				(11 * 4 * 26 * 2)
         
          .dseg
D:0000a9    G_BAUDS_IDX:								.byte		1	; Index des valeurs de bauds dans 'const_for_bauds_rate'
D:0000aa    G_BAUDS_VALUE:								.byte		1
         
          #ifndef USE_MINIMALIST_UOS
D:0000ab    G_DURATION_DETECT_LINE_IDLE_MSB:		.byte		1
D:0000ac    G_DURATION_DETECT_LINE_IDLE_LSB:		.byte		1
D:0000ad    G_DURATION_WAIT_READ_BIT_START:		.byte		1
         
D:0000ae    G_UART_CPT_LINE_IDLE_LSB:	.byte		1		; Compteur de 16 bits pour la detection de la ligne IDLE
D:0000af    G_UART_CPT_LINE_IDLE_MSB:	.byte		1
         
D:0000b0    G_UART_CPT_DURATION_1BIT_RX:	.byte		1	; Compteur pour l'attente avant nouvelle acquisition RXD
D:0000b1    G_UART_CPT_DURATION_1BIT_TX:	.byte		1	; Compteur pour l'attente avant emission prochain bit TXD
         
D:0000b2    G_UART_CPT_NBR_BITS_RX:			.byte		1	; Nommbre de bits pour l'acquisition RXD
D:0000b3    G_UART_CPT_NBR_BITS_TX:		.byte		1	; Nommbre de bits pour l'emission TXD
         
D:0000b4    G_UART_BYTE_RX_LSB:			.byte		1		; Mot LSB:MSB recu sur RXD (1 Start + 8 Datas + 1 ou 2 Stop)
D:0000b5    G_UART_BYTE_RX_MSB:			.byte		1		; apres serialisation a droite: 1111 11sD DDDD DDDS ([S]tart/[s]top)
         
D:0000b6    G_UART_BYTE_TX_LSB:			.byte		1		; Mot LSB:MSB a emettre sur TXD (1 Start + 8 Datas + 1 ou 2 Stop) avec une
D:0000b7    G_UART_BYTE_TX_MSB:			.byte		1		; serialisation a droite via la Carry: 1111 11sD DDDD DDDS ([S]tart/[s]top)
         
         ; FIFO UART/Rx
D:0000b8    G_UART_FIFO_RX_WRITE:		.byte		1
D:0000b9    G_UART_FIFO_RX_READ:			.byte		1
D:0000ba    G_UART_FIFO_RX_DATA:			.byte		(SIZE_UART_FIFO_RX - 1)		; 1st byte de la FIFO/Rx
D:0000d9    G_UART_FIFO_RX_DATA_END:	.byte		1									; Last byte de la FIFO/Rx
         
         ; FIFO UART/Tx
D:0000da    G_UART_FIFO_TX_WRITE:		.byte		1
D:0000db    G_UART_FIFO_TX_READ:			.byte		1
D:0000dc    G_UART_FIFO_TX_DATA:			.byte		(SIZE_UART_FIFO_TX - 1)		; 1st byte de la FIFO/Tx
D:00011b    G_UART_FIFO_TX_DATA_END:	.byte		1									; Last byte de la FIFO/Tx
         
          #else
          #endif
         
         ; End of file
         
          
         
          .cseg
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
          test_detect_line_idle:
C:0002fc fd81      	sbrc		REG_FLAGS_0, FLG_0_UART_DETECT_LINE_IDLE_IDX
C:0002fd c00a      	rjmp		test_detect_line_idle_rtn
         
         	; Presentation flash de 100mS sur Led YELLOW
C:0002fe 94f8      	cli
C:0002ff   +  	setLedYellowOn
C:0002ff 7f7b      cbr		REG_PORTB_OUT, MSK_BIT_LED_YELLOW
C:000300 bb78      out		PORTB, REG_PORTB_OUT					

C:000301 9478      	sei
         
         	; Presentation flash de 100mS sur Led YELLOW
C:000302 e013      	ldi		REG_TEMP_R17, TIMER_APPUI_BOUTON_LED
C:000303 e624      	ldi		REG_TEMP_R18, (100 % 256)
C:000304 e030      	ldi		REG_TEMP_R19, (100 / 256)
C:000305 eb46      	ldi		REG_TEMP_R20, low(exec_timer_push_button_led)
C:000306 e052      	ldi		REG_TEMP_R21, high(exec_timer_push_button_led)
C:000307 df5c      	rcall		start_timer
         	; Fin: Presentation flash de 100mS sur Led YELLOW
         
          test_detect_line_idle_rtn:
C:000308 9508      	ret
         ; ---------
         
         ; ---------
         ; Gestion des FIFOs UART/Rx et UART/Tx
         ;
         ; Usages:
         ;      mov		REG_R1, <data>			; Donnee a ecrire
         ;      rcall   uart_fifo_rx|tx_write
         ;      => Retour: SREG<Bit> = 1 si FIFO/Rx|Tx pleine
         ;
         ;      rcall	uart_fifo_rx|tx_read
         ;      => Retour: Donnee dans G_STACK_RESULTS si SREG<Bit> = 1
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_X_LSB:REG_X_LSB -> Pointeur sur les pointeurs ecriture/lecture/data
         ;    REG_TEMP_R16        -> Working register
         ;    REG_TEMP_R17        -> Pointeur d'ecriture courant
         ;    REG_TEMP_R18        -> Pointeur de lecture courant
         ;
         ; Warning: Methode appelee sous l'It 'tim1_compa_isr'
         ; ---------
          uart_fifo_rx_write:
C:000309 e0b0      	ldi		REG_X_MSB, (G_UART_FIFO_RX_DATA / 256)		; Indexation dans la FIFO/Rx
C:00030a ebaa      	ldi		REG_X_LSB, (G_UART_FIFO_RX_DATA % 256)
C:00030b 9110 00b8 	lds		REG_TEMP_R17, G_UART_FIFO_RX_WRITE			; Pointeur d'ecriture courant
C:00030d 9120 00b9 	lds		REG_TEMP_R18, G_UART_FIFO_RX_READ			; Pointeur de lecture courant
         
C:00030f 2700      	clr		REG_TEMP_R16
C:000310 0fa1      	add		REG_X_LSB, REG_TEMP_R17	; XL += REG_TEMP_R17
C:000311 1fb0      	adc		REG_X_MSB, REG_TEMP_R16	; XH += 0 + Carry
         
C:000312 921c      	st			X, REG_R1			; Ecriture donnee dans [G_UART_FIFO_RX_DATA, ..., G_UART_FIFO_RX_DATA_END]
         
C:000313 9513      	inc		REG_TEMP_R17
C:000314 711f      	andi		REG_TEMP_R17, (SIZE_UART_FIFO_RX - 1)		; Pointeur d'ecriture dans [0, ..., [SIZE_UART_FIFO_RX - 1)]
C:000315 9310 00b8 	sts		G_UART_FIFO_RX_WRITE, REG_TEMP_R17			; Maj pointeur d'ecriture
         
         	; Indication FIFO/Rx non vide
C:000317 6091      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK
         
         	; Indication si FIFO/Rx pleine
         	; => FIFO/Rx pleine si le pointeur d'ecriture "rejoint" le pointeur de lecture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
C:000318 7f9d      	cbr		REG_FLAGS_1, FLG_1_UART_FIFO_RX_FULL_MSK 		; FIFO/Rx a priori non pleine ...
C:000319 94e8      	clt																	; SREG<T> = 0
C:00031a 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:00031b f419      	brne		uart_fifo_rx_write_rtn
C:00031c 6092      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_RX_FULL_MSK		; ... et non, FIFO/Rx pleine
C:00031d 9468      	set																	; SREG<T> = 1
         
         	; Maj compteur d'erreurs
C:00031e ddea      	rcall		update_errors
         
          uart_fifo_rx_write_rtn:
C:00031f 9508      	ret
         ; ---------
         
         ; ---------
          uart_fifo_rx_read:
C:000320 e0b0      	ldi		REG_X_MSB, (G_UART_FIFO_RX_DATA / 256)		; Indexation dans la FIFO/Rx
C:000321 ebaa      	ldi		REG_X_LSB, (G_UART_FIFO_RX_DATA % 256)
C:000322 9110 00b8 	lds		REG_TEMP_R17, G_UART_FIFO_RX_WRITE			; Pointeur d'ecriture courant
C:000324 9120 00b9 	lds		REG_TEMP_R18, G_UART_FIFO_RX_READ			; Pointeur de lecture courant
         
         	; Sortie prematuree si rien a lire
C:000326 94e8      	clt													; A priori pas de donnee a lire
C:000327 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:000328 f061      	breq		uart_fifo_rx_read_end				; Pointeurs egaux => FIFO/Rx trouvee vide
         
C:000329 2700      	clr		REG_TEMP_R16
C:00032a 0fa2      	add		REG_X_LSB, REG_TEMP_R18	; XL += REG_TEMP_R18
C:00032b 1fb0      	adc		REG_X_MSB, REG_TEMP_R16	; XH += 0 + Carry
         
C:00032c 902c      	ld			REG_R2, X					; Lecture de la donnee dans [G_UART_FIFO_RX_DATA, ..., G_UART_FIFO_RX_DATA_END]
C:00032d 9468      	set										; Indication donnee disponible
         
C:00032e 9523      	inc		REG_TEMP_R18
C:00032f 712f      	andi		REG_TEMP_R18, (SIZE_UART_FIFO_RX - 1)		; Pointeur de lecture dans [0, ..., [SIZE_UART_FIFO_RX - 1)]
C:000330 9320 00b9 	sts		G_UART_FIFO_RX_READ, REG_TEMP_R18
         
         	; Indication FIFO/Rx vide ou non vide apres la lecture
         	; => FIFO/Rx vide si le pointeur de lecture "rejoint" le pointeur ecriture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
          uart_fifo_rx_read_test_empty:
C:000332 6091      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK		; FIFO/Rx a priori non vide...
C:000333 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:000334 f409      	brne		uart_fifo_rx_read_rtn
         
          uart_fifo_rx_read_end:
C:000335 7f9e      	cbr		REG_FLAGS_1, FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK		; ... et non, FIFO/Rx vide
         
          uart_fifo_rx_read_rtn:
C:000336 9508      	ret
         ; ---------
          #endif
         
         ; ---------
          uart_fifo_tx_write:
C:000337 93bf      	push		REG_X_MSB
C:000338 93af      	push		REG_X_LSB
C:000339 931f      	push		REG_TEMP_R17
C:00033a 932f      	push		REG_TEMP_R18
         
C:00033b e0b0      	ldi		REG_X_MSB, (G_UART_FIFO_TX_DATA / 256)	; Indexation dans la FIFO/Tx et ses 2 pointeurs
C:00033c edac      	ldi		REG_X_LSB, (G_UART_FIFO_TX_DATA % 256)
C:00033d 9110 00da 	lds		REG_TEMP_R17, G_UART_FIFO_TX_WRITE			; Pointeur d'ecriture courant
C:00033f 9120 00db 	lds		REG_TEMP_R18, G_UART_FIFO_TX_READ			; Pointeur de lecture courant
         
C:000341 2700      	clr		REG_TEMP_R16
C:000342 0fa1      	add		REG_X_LSB, REG_TEMP_R17			; XL += REG_TEMP_R17
C:000343 1fb0      	adc		REG_X_MSB, REG_TEMP_R16			; XH += 0 + Carry
         
C:000344 923c      	st			X, REG_R3			; Ecriture donnee dans [G_UART_FIFO_TX_DATA, ..., G_UART_FIFO_TX_DATA_END]
         
C:000345 9513      	inc		REG_TEMP_R17
C:000346 731f      	andi		REG_TEMP_R17, (SIZE_UART_FIFO_TX - 1)		; Pointeur d'ecriture dans [0, ..., [SIZE_UART_FIFO_TX - 1)]
C:000347 9310 00da 	sts		G_UART_FIFO_TX_WRITE, REG_TEMP_R17			; Maj pointeur d'ecriture
         
         	; Indication FIFO/Tx non vide
C:000349 6190      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK
         
         	; Emision de tous les caracteres de la FIFO/Tx jusqu'au dernier des que le pointeur d'ecriture (REG_TEMP_R17)
         	; atteint le pointeur de lecture (REG_TEMP_R18) -(SIZE_UART_FIFO_TX / 2) modulo SIZE_UART_FIFO_TX
         	; => Revient a vider la FIFO/Tx des que celle-ci est pleine a 50%
         	;    => Au dessous des 50%, les caracteres seront emis en fond de tache grace a l'appel de 'fifo_tx_to_send_async'
         	;    => Evite d'appeler dans le code la methode 'fifo_tx_to_send_sync' pour ne pas saturer la FIFO/Tx ;-)
C:00034a 2f02      	mov		REG_TEMP_R16, REG_TEMP_R18
C:00034b 5200      	subi		REG_TEMP_R16, (SIZE_UART_FIFO_TX / 2)		; Seuil a 50 % d'occupation de la FIFO/Tx
C:00034c 730f      	andi		REG_TEMP_R16, (SIZE_UART_FIFO_TX - 1)		; Modulo SIZE_UART_FIFO_TX
C:00034d 1701      	cp			REG_TEMP_R16, REG_TEMP_R17
C:00034e f409      	brne		uart_fifo_tx_write_skip
         
C:00034f d06d      	rcall		fifo_tx_to_send_sync
         
          uart_fifo_tx_write_skip:
         	; Fin: Emision de tous les caracteres de la FIFO/Tx...
         
         	; Indication si FIFO pleine
         	; => FIFO pleine si le pointeur d'ecriture "rejoint" le pointeur de lecture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
C:000350 7d9f      	cbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_FULL_MSK 		; FIFO/Rx a priori non pleine ...
C:000351 94e8      	clt																	; SREG<T> = 0
C:000352 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:000353 f419      	brne		uart_fifo_tx_write_rtn
C:000354 6290      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_FULL_MSK		; ... et non, FIFO/Rx pleine
C:000355 9468      	set																	; SREG<T> = 1
         
         	; Ne doit jamais arrive ;-)...
         	; Mise sur voie de garage si FIFO/Tx pleine
C:000356 cdb8      	rjmp		forever_1
         
          uart_fifo_tx_write_rtn:
C:000357 912f      	pop		REG_TEMP_R18
C:000358 911f      	pop		REG_TEMP_R17
C:000359 91af      	pop		REG_X_LSB
C:00035a 91bf      	pop		REG_X_MSB
C:00035b 9508      	ret
         ; ---------
         
         ; ---------
          uart_fifo_tx_read:
C:00035c 93bf      	push		REG_X_MSB
C:00035d 93af      	push		REG_X_LSB
C:00035e 931f      	push		REG_TEMP_R17
C:00035f 932f      	push		REG_TEMP_R18
         
C:000360 e0b0      	ldi		REG_X_MSB, (G_UART_FIFO_TX_DATA / 256)	; Indexation dans la FIFO/Tx et ses 2 pointeurs
C:000361 edac      	ldi		REG_X_LSB, (G_UART_FIFO_TX_DATA % 256)
C:000362 9110 00da 	lds		REG_TEMP_R17, G_UART_FIFO_TX_WRITE			; Pointeur d'ecriture courant
C:000364 9120 00db 	lds		REG_TEMP_R18, G_UART_FIFO_TX_READ			; Pointeur d'ecriture courant
         
         	; Sortie prematuree si rien a lire
C:000366 94e8      	clt														; A priori pas de donnee a lire
C:000367 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:000368 f061      	breq		uart_fifo_tx_read_end					; Pas de lecture => maj flags
         
C:000369 2700      	clr		REG_TEMP_R16
C:00036a 0fa2      	add		REG_X_LSB, REG_TEMP_R18	; XL += REG_TEMP_R18
C:00036b 1fb0      	adc		REG_X_MSB, REG_TEMP_R16	; XH += 0 + Carry
         
C:00036c 904c      	ld			REG_R4, X			; Lecture de la donnee dans [G_UART_FIFO_TX_DATA, ..., G_UART_FIFO_TX_DATA_END]
C:00036d 9468      	set								; Indication donnee disponible
         
C:00036e 9523      	inc		REG_TEMP_R18
C:00036f 732f      	andi		REG_TEMP_R18, (SIZE_UART_FIFO_TX - 1)		; Pointeur de lecture dans [0, ..., [SIZE_UART_FIFO_TX - 1)]
C:000370 9320 00db 	sts		G_UART_FIFO_TX_READ, REG_TEMP_R18
         
         	; Indication FIFO/Tx vide ou non vide apres la lecture
         	; => FIFO/Tx vide si le pointeur de lecture "rejoint" le pointeur ecriture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
          uart_fifo_tx_read_test_empty:
C:000372 6190      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK		; FIFO/Rx a priori non vide...
C:000373 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:000374 f409      	brne		uart_fifo_tx_read_rtn
         
          uart_fifo_tx_read_end:
C:000375 7e9f      	cbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK		; ... et non, FIFO/Rx vide
         
          uart_fifo_tx_read_rtn:
C:000376 912f      	pop		REG_TEMP_R18
C:000377 911f      	pop		REG_TEMP_R17
C:000378 91af      	pop		REG_X_LSB
C:000379 91bf      	pop		REG_X_MSB
C:00037a 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission d'un caractere sur Tx
         ; => Initialise 'G_UART_BYTE_TX_LSB:G_UART_BYTE_TX_MSB' et positionne 'FLG_1_UART_TX_TO_SEND' a 1
         ;    => Le mot constitue du Bit Start + 8 Datas + 1 ou 2 Bits Stop sera emis sous
         ;       l'It 'tim1_compa_isr' au moyen de 'G_UART_CPT_DURATION_1BIT_TX' @ 26uS et
         ;       'G_UART_CPT_NBR_BITS_TX' initialise a ((1+8+1) + x) (x Bits Stop)
         ;
         ; Usage:
         ;      mov		REG_TEMP_R16, <data>
         ;      rcall   uart_tx_send
         ;
         ; Registres utilises (sauvegardes/restaures):
         ;    REG_TEMP_R16        -> Byte a emettre
         ;    REG_TEMP_R17        -> Working register
         ; ---------
          uart_tx_send:
C:00037b 930f      	push		REG_TEMP_R16
C:00037c 931f      	push		REG_TEMP_R17
         
         	; Construction du mot a emettre avec '1111 11sD DDDD DDDS' ([S]tart/[s]top)
         	; R17:R16 = MSB:LSB = '1111 111D DDDD DDD0'
C:00037d ef1f      	ldi		REG_TEMP_R17, 0xFF	; Preparation MSB avec les 1, 2, 3, ... Bits Stop
C:00037e 0f00      	lsl		REG_TEMP_R16			; 'DDDD DDD0':  Bit Start a 0 et C = D7
C:00037f 1f11      	rol		REG_TEMP_R17			; '1111 111D':  Propagation de la Carry et des Bits Stop
         
C:000380 94f8      	cli		; Copie atomique
C:000381 9300 00b6 	sts		G_UART_BYTE_TX_LSB, REG_TEMP_R16
C:000383 9310 00b7 	sts		G_UART_BYTE_TX_MSB, REG_TEMP_R17
C:000385 9478      	sei		; Fin: Copie atomique
         
         	;ldi		REG_TEMP_R16, ((1+8+1) + 1)	; 1 Bit START + 8 Datas + 1 Bit  STOP (11)
C:000386 e00c      	ldi		REG_TEMP_R16, ((1+8+1) + 2)	; 1 Bit START + 8 Datas + 2 Bits STOP (12)
         	;ldi		REG_TEMP_R16, ((1+8+1) + 3)	; 1 Bit START + 8 Datas + 3 Bits STOP (13)
C:000387 9300 00b3 	sts		G_UART_CPT_NBR_BITS_TX, REG_TEMP_R16
         
C:000389 2700         clr		REG_TEMP_R16			; Initialisation a 0 pour faire partir l'emission immediatement
C:00038a 9300 00b1    sts		G_UART_CPT_DURATION_1BIT_TX, REG_TEMP_R16
         
C:00038c 6072      	sbr		REG_PORTB_OUT, MSK_BIT_TXD						; TXD a l'etat haut avant lancement emission
C:00038d 6180      	sbr		REG_FLAGS_0, FLG_0_UART_TX_TO_SEND_MSK		; Positionnement donnee a emettre
         
C:00038e 911f      	pop		REG_TEMP_R17
C:00038f 910f      	pop		REG_TEMP_R16
C:000390 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un texte termine par '\0'
         ;
         ; Usage:
         ;      ldi		REG_Z_MSB, <address MSB>
         ;      ldi		REG_Z_LSB, <address LSB>
         ;      rcall   push_text_in_fifo_tx
         ;
         ; Registres utilises
         ;    REG_Z_LSB:REG_Z_LSB -> Pointeur sur le texte en memoire programme (preserve)
         ;    REG_TEMP_R16        -> Working register (preserve)
         ; ---------
          #ifndef USE_MINIMALIST_UOS
          uos_push_text_in_fifo_tx_skip:
          push_text_in_fifo_tx_skip:
C:000391 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:000392 9508      	ret
          #endif
         
          uos_push_text_in_fifo_tx:
          push_text_in_fifo_tx:
C:000393 93ff      	push		REG_Z_MSB
C:000394 93ef      	push		REG_Z_LSB
C:000395 930f      	push		REG_TEMP_R16
         
          push_text_in_fifo_tx_loop:
C:000396 9105      	lpm		REG_TEMP_R16, Z+
C:000397 3000      	cpi		REG_TEMP_R16, CHAR_NULL		; '\0' terminal ?
C:000398 f019      	breq		push_text_in_fifo_tx_end
         
C:000399 2e30      	mov		REG_R3, REG_TEMP_R16
C:00039a df9c      	rcall		uart_fifo_tx_write
         
C:00039b cffa      	rjmp		push_text_in_fifo_tx_loop
         
          push_text_in_fifo_tx_end:
C:00039c 910f      	pop		REG_TEMP_R16
C:00039d 91ef      	pop		REG_Z_LSB
C:00039e 91ff      	pop		REG_Z_MSB
C:00039f 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un char
         ;
         ; Usage:
         ;      ldi		REG_TEMP_R16, <value>
         ;      rcall   push_1_char_in_fifo_tx
         ;
         ; Registres utilises
         ;    REG_TEMP_R16 -> Working register
         ; ---------
          #ifndef USE_MINIMALIST_UOS
          uos_push_1_char_in_fifo_tx_skip:
          push_1_char_in_fifo_tx_skip:
C:0003a0 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:0003a1 9508      	ret
          #endif
         
          uos_push_1_char_in_fifo_tx:
          push_1_char_in_fifo_tx:
C:0003a2 2e30      	mov		REG_R3, REG_TEMP_R16
C:0003a3 df93      	rcall		uart_fifo_tx_write
         
C:0003a4 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un texte lu de l'EEPROM et termine par '\0'
         ; => Si un 0xff est lu (EEPROM non initialisee), abandon de la lecture
         ; => Limitation a 8 caracteres lus pour eviter un bouclage ;-)
         ;
         ; Usage:
         ;      ldi		REG_TEMP_R18, 8
         ;      ldi		REG_X_MSB, <address MSB>
         ;      ldi		REG_X_LSB, <address LSB>
         ;      rcall   push_text_in_fifo_tx_from_eeprom
         ;
         ; ---------
          #ifndef USE_MINIMALIST_UOS
          push_text_in_fifo_tx_from_eeprom_skip:
C:0003a5 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:0003a6 9508      	ret
          #endif
         
          push_text_in_fifo_tx_from_eeprom:
          push_text_in_fifo_tx_from_eeprom_loop:
C:0003a7 d02b      	rcall		eeprom_read_byte
         
C:0003a8 3f0f      	cpi		REG_TEMP_R16, 0xff
C:0003a9 f031      	breq		push_text_in_fifo_tx_from_eeprom_end
         
C:0003aa 2300      	tst		REG_TEMP_R16
C:0003ab f021      	breq		push_text_in_fifo_tx_from_eeprom_end
         
C:0003ac dff5      	rcall		push_1_char_in_fifo_tx
         
C:0003ad 9611      	adiw		REG_X_LSB, 1
C:0003ae 952a      	dec		REG_TEMP_R18
C:0003af f7b9      	brne		push_text_in_fifo_tx_from_eeprom_loop
         
          push_text_in_fifo_tx_from_eeprom_end:
C:0003b0 9508      	ret
         ; ---------
         
C:0003b1 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission asynchrone caractere par caractere de la FIFO/Tx
         ;
         ; Remarque: Methode a appeler en fond de tache permettant de vider et
         ;           emettre tous les caracteres de la FIFO/Tx jusqu'au dernier
         ;
         ; Usage:
         ;      rcall   fifo_tx_to_send_async
         ;
         ; Registres utilises
         ;    REG_TEMP_R16        -> Working register (non preserve)
         ; ---------
          fifo_tx_to_send_async:
         	; Caractere de la FIFO/Tx a emettre ?
C:0003b2 ff96      	sbrs		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_IDX
C:0003b3 c008      	rjmp		fifo_tx_to_send_async_rtn
         
C:0003b4 fd84      	sbrc		REG_FLAGS_0, FLG_0_UART_TX_TO_SEND_IDX		; Caractere emis ?
C:0003b5 c006      	rjmp		fifo_tx_to_send_async_rtn
         
C:0003b6 dfa5      	rcall		uart_fifo_tx_read					; Oui => Lecture du caractere suivant dans FIFO/Tx
C:0003b7 f41e      	brtc		fifo_tx_to_send_async_end		; Caractere disponible ?
         
C:0003b8 2d04      	mov		REG_TEMP_R16, REG_R4				; Oui => Emission de celui-ci
C:0003b9 dfc1      	rcall		uart_tx_send
C:0003ba c001      	rjmp		fifo_tx_to_send_async_rtn		; Retour et attente que ce caractere soit emis...
         
          fifo_tx_to_send_async_end:
C:0003bb 7b9f      	cbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK		; Non => Arret de la demande d'emission
         
          fifo_tx_to_send_async_rtn:
C:0003bc 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission synchrone caractere par caractere jusqu'a vidage de la FIFO/Tx
         ;
         ; Remarque: Methode a appeler apres un appel a 'push_1_char_in_fifo_tx'
         ;           => Emision de tous les caracteres de la FIFO/Tx jusqu'au dernier
         ;
         ; Permet un forcage emission pour eviter la saturation de la FIFO/Tx
         ; => En effet, la lecture de la FIFO/Tx et l'emission ne commence qu'au
         ;    retour en fond de tache (cf. 'rcall fifo_tx_to_send_async')
         ;
         ; Usage:
         ;      rcall   fifo_tx_to_send_sync
         ;
         ; Registres utilises
         ;    REG_TEMP_R16        -> Working register (non preserve)
         ; ---------
          uos_fifo_tx_to_send_sync:
          fifo_tx_to_send_sync:
C:0003bd 0000      	nop
         
          fifo_tx_to_send_sync_retry:
C:0003be 6490      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK
C:0003bf dff2      	rcall		fifo_tx_to_send_async
         
C:0003c0 fd84      	sbrc		REG_FLAGS_0, FLG_0_UART_TX_TO_SEND_IDX				; Caractere emis ?
C:0003c1 cffc      	rjmp		fifo_tx_to_send_sync_retry								; Non => Retry
         
C:0003c2 fd94      	sbrc		REG_FLAGS_1, FLG_1_UART_FIFO_TX_NOT_EMPTY_IDX	; FIFO/Tx vide ?
C:0003c3 cffa      	rjmp		fifo_tx_to_send_sync_retry								; Non => Retry
         	; Fin: Emission, attente FIFO/Tx vide et dernier caractere emis
         
          fifo_tx_to_send_sync_rtn:
C:0003c4 9508      	ret
         ; ---------
         
          const_for_bauds_rate:
          .db	0x01, 0x02, 0x3C, 0x01	; 19200 bauds	; TODO: Erreur de reception cote cible non systematique
C:0003C5 01023C01
          .db	0x03, 0x04, 0x78, 0x02	;  9600 bauds
C:0003C7 03047802
          .db	0x07, 0x08, 0xF0, 0x04	;  4800 bauds
C:0003C9 0708F004
          .db	0x0F, 0x11, 0xE0, 0x08	;  2400 bauds
C:0003CB 0F11E008
          .db	0x1F, 0x23, 0xC0, 0x10	;  1200 bauds
C:0003CD 1F23C010
          .db	0x3E, 0x47, 0x80, 0x20	;   600 bauds
C:0003CF 3E478020
          .db	0x7C, 0x8F, 0x00, 0x40	;   300 bauds
C:0003D1 7C8F0040
          const_for_bauds_rate_end:
         
         ; End of file
         
          
          .include		"ATtiny85_uOS_Eeprom.asm"
         ; "$Id: ATtiny85_uOS_Eeprom.asm,v 1.9 2025/12/15 17:19:43 administrateur Exp $"
         
          .include		"ATtiny85_uOS_Eeprom.h"
         ; "$Id: ATtiny85_uOS_Eeprom.h,v 1.2 2025/12/05 17:18:56 administrateur Exp $"
         
          #define	EEPROM_ADDR_VERSION		0
          #define	EEPROM_ADDR_TYPE			8
          #define	EEPROM_ADDR_ID				9
          #define	EEPROM_ADDR_BAUDS_IDX	10
         
         ; End of file
         
          
         
          .cseg
         ; ---------
         ; Lecture d'un byte de l'EEPROM a l'adresse 'REG_X_MSB:REG_X_LSB'
         ; => Valeur retournee dans 'REG_TEMP_R16'
         ; ---------
          eeprom_read_byte:
         	; Set address
C:0003d3 bbae      	out		EEARL, REG_X_LSB
C:0003d4 bbbf      	out		EEARH, REG_X_MSB
         
         	; Lecture a l'adresse 'REG_X_MSB:REG_X_LSB'
          eeprom_read_byte_wait:
C:0003d5 99e1      	sbic		EECR, EEPE
C:0003d6 cffe      	rjmp		eeprom_read_byte_wait
         
C:0003d7 9ae0      	sbi		EECR, EERE
C:0003d8 b30d      	in			REG_TEMP_R16, EEDR
         	; Fin: Lecture a l'adresse 'REG_X_MSB:REG_X_LSB'
         
C:0003d9 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         ; Ecriture d'un byte contenu dans 'REG_TEMP_R16' a l'adresse 'REG_X_MSB:REG_X_LSB' de l'EEPROM
         ; ---------
          eeprom_write_byte:
         	; Set address
C:0003da bbae      	out		EEARL, REG_X_LSB
C:0003db bbbf      	out		EEARH, REG_X_MSB
         
         	; Set data
C:0003dc bb0d      	out		EEDR, REG_TEMP_R16
         
         	; Ecriture a l'adresse 'REG_X_MSB:REG_X_LSB' d'un byte
C:0003dd 98e5      	cbi		EECR, EEPM1
C:0003de 98e4      	cbi		EECR, EEPM0
         
         	; Sequence interruptible
C:0003df 94f8      	cli
C:0003e0 9ae2      	sbi		EECR, EEMPE		; Start EEPROM write
C:0003e1 9ae1      	sbi		EECR, EEPE
C:0003e2 9478      	sei
         	; Fin: Sequence interruptible
         	; Fin: Ecriture a l'adresse 'REG_X_MSB:REG_X_LSB' d'un byte
         
          eeprom_write_byte_wait:
C:0003e3 99e1      	sbic		EECR, EEPE
C:0003e4 cffe      	rjmp		eeprom_write_byte_wait
         
C:0003e5 9508      	ret
         ; ---------
          #endif
         
         ;#ifndef USE_MINIMALIST_UOS
         ;--------------------
         ; Lecture et impression des informations de l'EEPROM
         ;--------------------
          set_infos_from_eeprom:
         	; => Prompt "### EEPROM..."
C:0003e6 e028      	ldi		REG_TEMP_R18, 8
C:0003e7 e0f8      	ldi		REG_Z_MSB, ((text_prompt_eeprom_version << 1) / 256)
C:0003e8 e1e2      	ldi		REG_Z_LSB, ((text_prompt_eeprom_version << 1) % 256)
C:0003e9 dfa9      	rcall		push_text_in_fifo_tx
         
         	; Lecture de la version de l'EEPROM definie dans l'EEPROM
C:0003ea e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_VERSION)
C:0003eb e0a0      	ldi		REG_X_LSB, low(EEPROM_ADDR_VERSION)
C:0003ec dfba      	rcall		push_text_in_fifo_tx_from_eeprom
C:0003ed d2f3      	rcall		print_line_feed
         
         	; => Prompt "### Type..."
C:0003ee e0f8      	ldi		REG_Z_MSB, ((text_prompt_type << 1) / 256)
C:0003ef e2e0      	ldi		REG_Z_LSB, ((text_prompt_type << 1) % 256)
C:0003f0 dfa2      	rcall		push_text_in_fifo_tx
         
         	; Lecture du type de la platine defini dans l'EEPROM
C:0003f1 e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_TYPE);
C:0003f2 e0a8      	ldi		REG_X_LSB, low(EEPROM_ADDR_TYPE);
C:0003f3 dfdf      	rcall		eeprom_read_byte
         
C:0003f4 9300 0166 	sts		G_HEADER_TYPE_PLATINE, REG_TEMP_R16
         
C:0003f6 d2cf      	rcall		convert_and_put_fifo_tx
C:0003f7 d2e9      	rcall		print_line_feed
         
         	; => Prompt "### Id..."
C:0003f8 e0f8      	ldi		REG_Z_MSB, ((text_prompt_id << 1) / 256)
C:0003f9 e2ec      	ldi		REG_Z_LSB, ((text_prompt_id << 1) % 256)
C:0003fa df98      	rcall		push_text_in_fifo_tx
         	
         	; Lecture de l'Id de la platine defini dans l'EEPROM
C:0003fb e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_ID);
C:0003fc e0a9      	ldi		REG_X_LSB, low(EEPROM_ADDR_ID);
C:0003fd dfd5      	rcall		eeprom_read_byte
         
C:0003fe 9300 0167 	sts		G_HEADER_INDEX_PLATINE, REG_TEMP_R16
         
C:000400 d2c5      	rcall		convert_and_put_fifo_tx
C:000401 d2df      	rcall		print_line_feed
         
          #ifndef USE_MINIMALIST_UOS
C:000402 e0f8      	ldi		REG_Z_MSB, ((text_osccal << 1) / 256)
C:000403 e4e6      	ldi		REG_Z_LSB, ((text_osccal << 1) % 256)
C:000404 df8e      	rcall		push_text_in_fifo_tx
         
C:000405 b701      	in			REG_TEMP_R16, OSCCAL
C:000406 d2bf      	rcall		convert_and_put_fifo_tx
C:000407 d2d9      	rcall		print_line_feed
         	; Fin: Preparation emission des prompts d'accueil
          #endif
         
C:000408 9508      	ret
         ; ---------
         ;#endif
         
          text_prompt_eeprom_version:
          .db	"### EEPROM: ", CHAR_NULL, CHAR_NULL
C:000409 23232320454550524F4D3A200000
         
          text_prompt_type:
          .db	"### Type: ", CHAR_NULL, CHAR_NULL
C:000410 23232320547970653A200000
         
          text_prompt_id:
          .db	"### Id: ", CHAR_NULL, CHAR_NULL
C:000416 2323232049643A200000
         
          #ifndef USE_MINIMALIST_UOS
          text_eeprom_error:
          .db	"Err: EEPROM at ", CHAR_NULL
C:00041B 4572723A20454550524F4D2061742000
         
          text_osccal:
          .db	"OSCCAL [", CHAR_NULL, CHAR_NULL
C:000423 4F534343414C205B0000
          #endif
         
         ; End of file
         
          
         
          #ifndef USE_MINIMALIST_UOS
          .include		"ATtiny85_uOS_Commands.asm"
         ; "$Id: ATtiny85_uOS_Commands.asm,v 1.14 2025/12/12 15:41:46 administrateur Exp $"
         
          .include		"ATtiny85_uOS_Commands.h"
         ; "$Id: ATtiny85_uOS_Commands.h,v 1.2 2025/12/01 17:36:27 administrateur Exp $"
         
          #define	CHAR_COMMAND_REC		'<'
          #define	CHAR_COMMAND_SEND		'>'
          #define	CHAR_COMMAND_MORE		'-'
          #define	CHAR_COMMAND_PLUS		'+'
          #define	CHAR_COMMAND_UNKNOWN	'?'
         
          #define	CHAR_TYPE_COMMAND_A_MIN		'a'	; Calcul du CRC8-MAXIM du programme		: "<a"
          #define	CHAR_TYPE_COMMAND_B_MAJ		'B'	; Set the Bauds rate (300, ..., 19200) : "B0|1|2|3|4|5|6"
          #define	CHAR_TYPE_COMMAND_E_READ	'e'	; Dump de l'EEPROM                     : "<eHHHH..."
          #define	CHAR_TYPE_COMMAND_F_MIN		'f'	; Lecture de la signature et des fuses : "<f"
          #define	CHAR_TYPE_COMMAND_E_WRITE	'E'	; Ecriture d'un byte dans l'EEPROM     : "<EHHHH..."
          #define	CHAR_TYPE_COMMAND_P_READ	'p'	; Dump du Programme                    : "<pHHHH..."
          #define	CHAR_TYPE_COMMAND_S_READ	's'	; Dump de la SRAM                      : "<sHHHH..."
          #define	CHAR_TYPE_COMMAND_S_WRITE	'S'	; Ecriture d'un byte dans la SRAM      : "<SHHHH..."
          #define	CHAR_TYPE_COMMAND_X			'x'	; Execution d'un programme de test     : "<xHHHH"
         
         ; Flags propres aux tests (masques et index)
          #define	FLG_TEST_COMMAND_TYPE_MSK				MSK_BIT0
          #define	FLG_TEST_COMMAND_IN_PROGRESS_MSK		MSK_BIT1
          #define	FLG_TEST_COMMAND_MORE_MSK				MSK_BIT2
          #define	FLG_TEST_COMMAND_PLUS_MSK				MSK_BIT3
          #define	FLG_TEST_COMMAND_ERROR_MSK				MSK_BIT4
          #define	FLG_TEST_SPARE_1_MSK						MSK_BIT5
          #define	FLG_TEST_EEPROM_ERROR_MSK				MSK_BIT6
          #define	FLG_TEST_SPARE_2_MSK						MSK_BIT7
         
          #define	FLG_TEST_COMMAND_TYPE_IDX				IDX_BIT0
          #define	FLG_TEST_COMMAND_IN_PROGRESS_IDX		IDX_BIT1
          #define	FLG_TEST_COMMAND_MORE_IDX				IDX_BIT2
          #define	FLG_TEST_COMMAND_PLUS_IDX				IDX_BIT3
          #define	FLG_TEST_COMMAND_ERROR_IDX				IDX_BIT4
          #define	FLG_TEST_SPARE_1_IDX						IDX_BIT5
          #define	FLG_TEST_EEPROM_ERROR_IDX				IDX_BIT6
          #define	FLG_TEST_SPARE_2_IDX						IDX_BIT7
         
          .dseg
         ; Variables specifiques aux saisies de commandes a executer
D:00011c    G_TEST_FLAGS:					.byte		1
D:00011d    G_TEST_COMMAND_TYPE:			.byte		1
D:00011e    G_TEST_VALUE_MSB:				.byte		1
D:00011f    G_TEST_VALUE_LSB:				.byte		1
D:000120    G_TEST_VALUE_MSB_MORE:		.byte		1
D:000121    G_TEST_VALUE_LSB_MORE:		.byte		1
         
D:000122    G_TEST_VALUE_DEC_MSB:		.byte		1
D:000123    G_TEST_VALUE_DEC_LSB:		.byte		1
         
         ;G_TEST_FLAGS_2:				.byte		1
         
D:000124    G_TEST_VALUES_IDX_WRK:		.byte		1				; Index sur les valeurs de 'G_TEST_VALUES_ZONE' (travail)
D:000125    G_TEST_VALUES_IDX:			.byte		1				; Index sur les valeurs de 'G_TEST_VALUES_ZONE' (disponible)
D:000126    G_TEST_VALUES_ZONE:			.byte		(2 * 32)		; Page de 32 mots
         
         ; End of file
         
          
         
          .cseg
         
         ; ---------
         ; Interpretation d'une commande recue
         ;
         ; Usage:
         ;		 rcall	interprete_command		; Lecture de la FIFO/Rx
         ;
         ; Registres utilises (sauvegarde/restaures):
         ;    REG_TEMP_R16 -> Caractere a convertir et a ajouter apres x10
         ;    REG_TEMP_R17 -> Working register
         ;    
         ; Warning: Pas de test du 'char' passe en argument dans la plage ['0,', '1', ..., '9']
         ; Remarque: Lecture de la FIFO/Rx jusqu'au vidage
         ;
         ; Retour ajoute a 'G_TEST_VALUE_MSB:G_TEST_VALUE_LSB' par decalage et sans raz
         ; => Raz a la charge de l'interpretation de la valeur
         ; ---------
          interpret_command:
         
          interpret_command_loop:
C:000428 94f8      	cli
C:000429 def6      	rcall		uart_fifo_rx_read			; Lecture atomique
C:00042a 9478      	sei
         
C:00042b f5be      	brtc		interpret_command_rtn	; Nouvelle donnee disponible ?
         
C:00042c 9110 011c 	lds		REG_TEMP_R17, G_TEST_FLAGS
         
         	; Oui. -> Caractere dans 'REG_R2'
C:00042e 2d02      	mov		REG_TEMP_R16, REG_R2
C:00042f 330c      	cpi		REG_TEMP_R16, CHAR_COMMAND_REC
C:000430 f421      	brne		interpret_command_loop_more
         
         	; Le prochain caractere sera le type de la commande
C:000431 6011      	sbr		REG_TEMP_R17, FLG_TEST_COMMAND_TYPE_MSK
C:000432 9310 011c 	sts		G_TEST_FLAGS, REG_TEMP_R17
C:000434 cff3      	rjmp		interpret_command_loop
         
          interpret_command_loop_more:
C:000435 320d      	cpi		REG_TEMP_R16, CHAR_COMMAND_MORE
C:000436 f421      	brne		interpret_command_loop_more_2
         
C:000437 6014      	sbr		REG_TEMP_R17, FLG_TEST_COMMAND_MORE_MSK
C:000438 9310 011c 	sts		G_TEST_FLAGS, REG_TEMP_R17
C:00043a cfed      	rjmp		interpret_command_loop
         
          interpret_command_loop_more_2:
C:00043b 320b      	cpi		REG_TEMP_R16, CHAR_COMMAND_PLUS
C:00043c f441      	brne		interpret_command_loop_more_2A
         
         	; Effacement de 'G_TEST_VALUES_ZONE' sur le 1st 'CHAR_COMMAND_PLUS
C:00043d ff13      	sbrs		REG_TEMP_R17, FLG_TEST_COMMAND_PLUS_IDX
C:00043e d221      	rcall		raz_value_into_zone
         
         	; Ajout 'G_TEST_VALUE_MSB_MORE:G_TEST_VALUE_LSB_MORE' a 'G_TEST_VALUES_ZONE'
         	; precedent 'CHAR_COMMAND_PLUS'
C:00043f fd13      	sbrc		REG_TEMP_R17, FLG_TEST_COMMAND_PLUS_IDX
C:000440 d233      	rcall		add_value_into_zone
         
         	; Force maj 'G_TEST_VALUE_MSB_MORE:G_TEST_VALUE_LSB_MORE'
C:000441 601c      	sbr		REG_TEMP_R17, (FLG_TEST_COMMAND_MORE_MSK | FLG_TEST_COMMAND_PLUS_MSK)
C:000442 9310 011c 	sts		G_TEST_FLAGS, REG_TEMP_R17
C:000444 cfe3      	rjmp		interpret_command_loop
         
          interpret_command_loop_more_2A:
C:000445 300a      	cpi		REG_TEMP_R16, CHAR_LF
C:000446 f429      	brne		interpret_command_loop_more_3
         
         	; Ajout 'G_TEST_VALUE_MSB_MORE:G_TEST_VALUE_LSB_MORE' a 'G_TEST_VALUES_ZONE'
C:000447 fd13      	sbrc		REG_TEMP_R17, FLG_TEST_COMMAND_PLUS_IDX
C:000448 d22b      	rcall		add_value_into_zone
         
C:000449 d033      	rcall		exec_command								; Execution de la commande
         
         	; Lancement de l'emission
C:00044a 6490      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK
C:00044b c017      	rjmp		interpret_command_rtn
         
          interpret_command_loop_more_3:
C:00044c ff10      	sbrs		REG_TEMP_R17, FLG_TEST_COMMAND_TYPE_IDX
C:00044d c013      	rjmp		interpret_command_loop_more_4
         
C:00044e 9300 011d 	sts		G_TEST_COMMAND_TYPE, REG_TEMP_R16	; Save command type
         
         	; Raz des donnees de la commande a recevoir
C:000450 2700      	clr		REG_TEMP_R16
C:000451 9300 011e 	sts		G_TEST_VALUE_MSB, REG_TEMP_R16
C:000453 9300 011f 	sts		G_TEST_VALUE_LSB, REG_TEMP_R16
C:000455 9300 0120 	sts		G_TEST_VALUE_MSB_MORE, REG_TEMP_R16
C:000457 9300 0121 	sts		G_TEST_VALUE_LSB_MORE, REG_TEMP_R16
         
C:000459 9100 0124 	lds		REG_TEMP_R16, G_TEST_VALUES_IDX_WRK
C:00045b 9300 0125 	sts		G_TEST_VALUES_IDX, REG_TEMP_R16
         
         	; Effacement pour prendre la valeur qui suit avec eventuellement des donnees a suivre
C:00045d 7f12      	cbr		REG_TEMP_R17, (FLG_TEST_COMMAND_TYPE_MSK | FLG_TEST_COMMAND_MORE_MSK | FLG_TEST_COMMAND_PLUS_MSK)
C:00045e 9310 011c 	sts		G_TEST_FLAGS, REG_TEMP_R17
C:000460 cfc7      	rjmp		interpret_command_loop
         
          interpret_command_loop_more_4:
C:000461 d1d1      	rcall		char_to_hex_incremental		; Construction de 'G_TEST_VALUE_MSB:G_TEST_VALUE_LSB'
C:000462 cfc5      	rjmp		interpret_command_loop
         
          interpret_command_rtn:
C:000463 9508      	ret
         ; ---------
         
         ; ---------
         ; - Echo de la commande avec ses parametres
         ; ---------
          uos_print_command_ok:
          print_command_ok:
         	; Echo de la commande reconnue avec uniquement l'adresse
         	; => ie. "[34>zA987-4321]"
         	;
C:000464 9110 011c 	lds		REG_TEMP_R17, G_TEST_FLAGS
C:000466 7e1f      	cbr		REG_TEMP_R17, FLG_TEST_COMMAND_ERROR_MSK
         
C:000467 e30e      	ldi		REG_TEMP_R16, CHAR_COMMAND_SEND
C:000468 c004      	rjmp		print_command
         
          uos_print_command_ko:
          print_command_ko:
         	; Echo de la commande non reconnue avec ses parametres
         	; => ie. "34?zA987-4321" si commande non reconnue
         	;
C:000469 9110 011c 	lds		REG_TEMP_R17, G_TEST_FLAGS
C:00046b 6110      	sbr		REG_TEMP_R17, FLG_TEST_COMMAND_ERROR_MSK
         
C:00046c e30f      	ldi		REG_TEMP_R16, CHAR_COMMAND_UNKNOWN
         
          print_command:
C:00046d 9310 011c 	sts		G_TEST_FLAGS, REG_TEMP_R17					; Maj Flag 'FLG_TEST_COMMAND_ERROR'
         
C:00046f df32      	rcall		push_1_char_in_fifo_tx						; '>' eor '?'
         
C:000470 9100 011d 	lds		REG_TEMP_R16, G_TEST_COMMAND_TYPE
C:000472 df2f      	rcall		push_1_char_in_fifo_tx
         
         	; 1st argument sur 16 bits de la commande
C:000473 9100 011e 	lds		REG_TEMP_R16, G_TEST_VALUE_MSB
C:000475 d250      	rcall		convert_and_put_fifo_tx
         
C:000476 9100 011f 	lds		REG_TEMP_R16, G_TEST_VALUE_LSB
C:000478 d24d      	rcall		convert_and_put_fifo_tx
         	; Fin: Echo de la commande avec uniquement l'adresse
         
C:000479 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value_lf_end << 1) / 256)
C:00047a e7e0      	ldi		REG_Z_LSB, ((text_hexa_value_lf_end << 1) % 256)
C:00047b df17      	rcall		push_text_in_fifo_tx
         
C:00047c 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande recue
         ; ---------
          exec_command:
C:00047d e50b      	ldi		REG_TEMP_R16, '['
C:00047e df23      	rcall		push_1_char_in_fifo_tx
         
         	; Comptabilisation et print des executions
C:00047f 9100 0066 	lds		REG_TEMP_R16, G_NBR_VALUE_TRACE
C:000481 9503      	inc		REG_TEMP_R16
C:000482 9300 0066 	sts		G_NBR_VALUE_TRACE, REG_TEMP_R16
         
         	; Compteur d'execution commande sur 8 bits
C:000484 9100 0066 	lds		REG_TEMP_R16, G_NBR_VALUE_TRACE
C:000486 d23f      	rcall		convert_and_put_fifo_tx
         
         	; Fin: Comptabilisation et print des executions
         
         	; Liste des commandes supportees
C:000487 9100 011d 	lds		REG_TEMP_R16, G_TEST_COMMAND_TYPE
         
          exec_command_test_a_min:
C:000489 3601      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_A_MIN
C:00048a f189      	breq		exec_command_type_A
         
          exec_command_test_b_maj:
C:00048b 3402      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_B_MAJ
C:00048c f409      	brne		exec_command_test_f_min
C:00048d c073      	rjmp		exec_command_type_B
         
          exec_command_test_f_min:
C:00048e 3606      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_F_MIN
C:00048f f409      	brne		exec_command_test_s_read
C:000490 c126      	rjmp		exec_command_type_f_min
         
          exec_command_test_s_read:
C:000491 3703      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_S_READ
C:000492 f409      	brne		exec_command_test_s_write
C:000493 c08b      	rjmp		exec_command_type_s_read
         
          exec_command_test_s_write:
C:000494 3503      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_S_WRITE
C:000495 f409      	brne		exec_command_test_e_read
C:000496 c0ab      	rjmp		exec_command_type_s_write
         
          exec_command_test_e_read:
C:000497 3605      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_E_READ
C:000498 f409      	brne		exec_command_test_e_write
C:000499 c0ca      	rjmp		exec_command_type_e_read
         
          exec_command_test_e_write:
C:00049a 3405      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_E_WRITE
C:00049b f409      	brne		exec_command_test_p
C:00049c c0e9      	rjmp		exec_command_type_e_write
         
          exec_command_test_p:
C:00049d 3700      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_P_READ
C:00049e f409      	brne		exec_command_test_x
C:00049f c146      	rjmp		exec_command_type_p_read
         
          exec_command_test_x:
C:0004a0 3708      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_X
C:0004a1 f409      	brne		exec_command_ko
C:0004a2 c162      	rjmp		exec_command_type_x
         	; Fin: Liste des commandes supportees par uOS
         
          exec_command_ko:
         	; La commande dans 'REG_TEMP_R16' n'est pas supportee par uOS
         	; => Prolongement si module ADDON detecte
         	;
C:0004a3 e013      	ldi		REG_TEMP_R17, EXTENSION_COMMANDS
C:0004a4 dba7      	rcall		exec_extension_addon
C:0004a5 c001      	rjmp		exec_command_rtn
         
          exec_command_ko_end:
C:0004a6 dfc2      	rcall		print_command_ko			; Commande non reconnue
         
          exec_command_rtn:
C:0004a7 9508      	ret
         ; ---------
         
         ; ---------
         ; Arret si 0xFFFFFFFF trouve a l'adresse @ Z (2 premiers non programme)
         ; => Warning: Si une 2 dernieres donnees '.dseg' est definie a 0xFFFFFFFF
         ;    => Arret premature ;-)
         ; ---------
          exec_command_A_test_end:
C:0004a8 93ff      	push		REG_Z_MSB
C:0004a9 93ef      	push		REG_Z_LSB
C:0004aa 930f      	push		REG_TEMP_R16
C:0004ab 931f      	push		REG_TEMP_R17
         
C:0004ac e014      	ldi		REG_TEMP_R17, 4
         
          exec_command_A_test_end_more:
C:0004ad 3f0f      	cpi		REG_TEMP_R16, 0xFF
C:0004ae f429      	brne		exec_command_A_test_end_not_found	
         
         	; 0xFF trouve -> Limitaion a 4 bytes trouves a 0xFF
         	; => Fin du calcul
C:0004af 951a      	dec		REG_TEMP_R17
C:0004b0 f029      	breq		exec_command_A_test_end_found
         
          exec_command_A_test_end_continue:
C:0004b1 95e3      	inc		REG_Z_LSB
C:0004b2 9104      	lpm		REG_TEMP_R16, Z
C:0004b3 cff9      	rjmp		exec_command_A_test_end_more
         
          exec_command_A_test_end_not_found:
C:0004b4 9418      	sez												; Z <- 1 (return false)
C:0004b5 c001      	rjmp		exec_command_A_test_end_rtn
         
          exec_command_A_test_end_found:
C:0004b6 9498      	clz												; Z <- 0 (return true)
         
          exec_command_A_test_end_rtn:
C:0004b7 911f      	pop		REG_TEMP_R17
C:0004b8 910f      	pop		REG_TEMP_R16
C:0004b9 91ef      	pop		REG_Z_LSB
C:0004ba 91ff      	pop		REG_Z_MSB
         
C:0004bb 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'A'
         ; ---------
          exec_command_type_A:
         
C:0004bc dfa7      	rcall		print_command_ok
         
C:0004bd 27bb      	clr		REG_X_MSB			; Calcul a partir de l'adresse 0x0000
C:0004be 27aa      	clr		REG_X_LSB
         
         	; Raz CRC8
C:0004bf 2700      	clr		REG_TEMP_R16
C:0004c0 9300 0068 	sts		G_CALC_CRC8, REG_TEMP_R16
         
          exec_command_A_loop_0:
         	; Impression de 'X' ("[0xHHHH] ")
         	; Remarque: Division par 2 car dump de word ;-)
C:0004c2 95b6      	lsr		REG_X_MSB
C:0004c3 95a7      	ror		REG_X_LSB
C:0004c4 d235      	rcall		print_2_bytes_hexa
         
         	; Retablissement de 'X' qui est toujours pair ici
C:0004c5 0faa      	lsl		REG_X_LSB
C:0004c6 1fbb      	rol		REG_X_MSB
         
         	; Impression du dump ("[0x....]")
         	; => TODO: Si saut 'end_of_program' est de la forme 0xhhh0, pas de valeur apres [0x...]
C:0004c7 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:0004c8 e6ea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:0004c9 dec9      	rcall		push_text_in_fifo_tx
         
C:0004ca e220      	ldi		REG_TEMP_R18, 32
         
          exec_command_A_loop_1:
         	; Valeur de la memoire programme indexee par 'REG_X_MSB:REG_X_LSB'
C:0004cb 01fd      	movw		REG_Z_LSB, REG_X_LSB
C:0004cc 9611      	adiw		REG_X_LSB, 1								; Preparation prochain byte
         
         	; Calcul jusqu'a l'adresse 'end_of_program' incluse
C:0004cd e001      	ldi		REG_TEMP_R16, 0x01
C:0004ce 230a      	and		REG_TEMP_R16, REG_X_LSB
C:0004cf f001      	breq		exec_command_A_loop_1_cont_d			; Lecture par mot
         
          exec_command_A_loop_1_cont_d:
C:0004d0 e001      	ldi		REG_TEMP_R16, 0x01
C:0004d1 27e0      	eor		REG_Z_LSB, REG_TEMP_R16		; Lecture MSB puis LSB
C:0004d2 9104      	lpm		REG_TEMP_R16, Z
         
         	; Test de la fin du programme (4 bytes a 0xFFFFFFFF)
C:0004d3 dfd4      	rcall		exec_command_A_test_end		; if (exec_command_A_test_end() == true) ?
C:0004d4 f479      	brne		exec_command_A_end			; -> Yes: La fin du programme flashe est trouvee -> Arret
         
C:0004d5 930f      	push		REG_TEMP_R16
C:0004d6 d1ef      	rcall		convert_and_put_fifo_tx
         
C:0004d7 910f      	pop		REG_TEMP_R16
C:0004d8 dc51      	rcall		calc_crc8_maxim
         
C:0004d9 952a      	dec		REG_TEMP_R18
C:0004da f781      	brne		exec_command_A_loop_1
         
C:0004db e50d      	ldi		REG_TEMP_R16, ']'
C:0004dc dec5      	rcall		push_1_char_in_fifo_tx
         
C:0004dd 93af      	push		REG_X_LSB
C:0004de 91a0 0068 	lds		REG_X_LSB, G_CALC_CRC8
C:0004e0 d20a      	rcall		print_1_byte_hexa
C:0004e1 d1ff      	rcall		print_line_feed
C:0004e2 91af      	pop		REG_X_LSB
         
C:0004e3 cfde      	rjmp		exec_command_A_loop_0
         
          exec_command_A_end:
C:0004e4 e50d      	ldi		REG_TEMP_R16, ']'
C:0004e5 debc      	rcall		push_1_char_in_fifo_tx
         
C:0004e6 93af      	push		REG_X_LSB
C:0004e7 91a0 0068 	lds		REG_X_LSB, G_CALC_CRC8
C:0004e9 d201      	rcall		print_1_byte_hexa
C:0004ea d1f6      	rcall		print_line_feed
C:0004eb 91af      	pop		REG_X_LSB
         
         	; Impression du resultat comme "[CRC8-MAXIM [0x0000][0x06f6][0x3c]]"
C:0004ec 93ff      	push		REG_Z_MSB
C:0004ed 93ef      	push		REG_Z_LSB
C:0004ee e0fd      	ldi		REG_Z_MSB, ((text_crc8_maxim_label << 1) / 256)
C:0004ef e2ee      	ldi		REG_Z_LSB, ((text_crc8_maxim_label << 1) % 256)
C:0004f0 dea2      	rcall		push_text_in_fifo_tx
C:0004f1 91ef      	pop		REG_Z_LSB
C:0004f2 91ff      	pop		REG_Z_MSB
         
C:0004f3 e0d0      	ldi		REG_Y_MSB, 0
C:0004f4 e0c0      	ldi		REG_Y_LSB, 0
C:0004f5 d22f      	rcall		print_y_reg
         
         	; Recadrage pour une adresse "imprimable"
C:0004f6 95f6      	lsr		REG_Z_MSB
C:0004f7 95e7      	ror		REG_Z_LSB
C:0004f8 9731      	sbiw		REG_Z_LSB, 1
C:0004f9 d234      	rcall		print_z_reg
         	; Fin: Impression du resultat comme "[CRC8-MAXIM [0x0000][0x06f6][0x3c]]"
         
C:0004fa 93af      	push		REG_X_LSB
C:0004fb 91a0 0068 	lds		REG_X_LSB, G_CALC_CRC8
C:0004fd d1ed      	rcall		print_1_byte_hexa
C:0004fe d1e2      	rcall		print_line_feed
C:0004ff 91af      	pop		REG_X_LSB
         
          exec_command_A_rtn:
C:000500 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'B'
         ;
         ; Reprogrammation du Baud Rate
         ; - "<B0": 19200 bauds
         ; - "<B1":  9600 bauds
         ; - "<B2":  4800 bauds
         ; - "<B3":  2400 bauds
         ; - "<B4":  1200 bauds
         ; - "<B5":   600 bauds
         ; - "<B6":   300 bauds
         ; ---------
          exec_command_type_B:
         	; Recuperation de l'index
C:000501 27bb      	clr		REG_X_MSB
C:000502 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB
         
         	; Multiplication par 4 pour acceder a chaque quadruplet de la table 'const_for_bauds_rate'
         	; => Pas de report dans 'REG_X_MSB' car 6 resultats dans la plage [0, 4, 8, 12, 16, 20 et 24]]
C:000504 0faa      	lsl		REG_X_LSB
C:000505 0faa      	lsl		REG_X_LSB
         
C:000506 e0f7      	ldi		REG_Z_MSB, high(const_for_bauds_rate << 1)
C:000507 e8ea      	ldi		REG_Z_LSB, low(const_for_bauds_rate << 1)
C:000508 0fea      	add		REG_Z_LSB, REG_X_LSB	
C:000509 1ffb      	adc		REG_Z_MSB, REG_X_MSB	
         
         	; Adresse du dernier quadruplet cadree sur un mot
C:00050a ea12      	ldi		REG_TEMP_R17, low((const_for_bauds_rate_end - 1 - 1) << 1)
C:00050b 171e      	cp			REG_TEMP_R17, REG_Z_LSB
C:00050c e017      	ldi		REG_TEMP_R17, high((const_for_bauds_rate_end - 1 - 1) << 1)
C:00050d 071f      	cpc		REG_TEMP_R17, REG_Z_MSB
C:00050e f072      	brmi		exec_command_type_B_ko		; Z <= 'Adresse du dernier quadruplet' ?
         
          exec_command_type_B_ok:			; -> Yes (adresse de copie dans la plage ;-)
C:00050f e0b0      	ldi		REG_X_MSB, high(G_BAUDS_VALUE)
C:000510 eaaa      	ldi		REG_X_LSB, low(G_BAUDS_VALUE)
         
         	; Recopie atomique...
C:000511 94f8      	cli
C:000512 9105      	lpm		REG_TEMP_R16, Z+
C:000513 930d      	st			X+, REG_TEMP_R16
C:000514 9105      	lpm		REG_TEMP_R16, Z+
C:000515 930d      	st			X+, REG_TEMP_R16
C:000516 9105      	lpm		REG_TEMP_R16, Z+
C:000517 930d      	st			X+, REG_TEMP_R16
C:000518 9105      	lpm		REG_TEMP_R16, Z+
C:000519 930d      	st			X+, REG_TEMP_R16
C:00051a 9478      	sei
         
C:00051b df48      	rcall		print_command_ok			; Commande executee
C:00051c 9508      	ret
         
          exec_command_type_B_ko:					; -> No (adresse de copie hors de la plage ;-)
C:00051d df4b      	rcall		print_command_ko			; Commande non executee (index trop grand)
C:00051e 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 's'
         ; => Dump de la SRAM: "<sAAAA-BBBB" avec:
         ;    - 0xAAAA: l'adresse du 1st byte a lire (si 0xAAAA == 0x0000 => Debut en SRAM_START
         ;    - 0xBBBB: le nombre de blocs de 16 bytes
         ;    - La lecture et l'emission sont effectuees 8 bytes par 8 bytes
         ;      avec une limitation des adresses dans la plage [SRAM_START, ..., RAMEND]
         ;
         ; Reponse: "[NN>sAAAA-BBBB]"
         ;          "[0xAAAA] [0xd0d1d2d3d4d5d6d7...]" (0xAAAA actualise @ adresse en cours)
         ; ---------
          exec_command_type_s_read:
C:00051f df44      	rcall		print_command_ok			; Commande reconnue
         
         	; Recuperation de l'adresse du 1st byte a lire
C:000520 91b0 011e 	lds		REG_X_MSB, G_TEST_VALUE_MSB
C:000522 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB
         
C:000524 23bb      	tst		REG_X_MSB
C:000525 f431      	brne		exec_command_type_s_read_cont_d
C:000526 23aa      	tst		REG_X_LSB
C:000527 f421      	brne		exec_command_type_s_read_cont_d
         
C:000528 e0b0      	ldi		REG_X_MSB, (SRAM_START / 256)
C:000529 e6a0      	ldi		REG_X_LSB, (SRAM_START % 256)
         
         	; Dump de toute la SRAM
         	; TODO: Calcul @ 'SRAM_START' et 'RAMEND'
C:00052a e210      	ldi		REG_TEMP_R17, 32
C:00052b c001      	rjmp		exec_command_type_s_read_loop_0
         
          exec_command_type_s_read_cont_d:
         	; Dump sur 8 x 16 bytes
         	; TODO: Get 'G_TEST_VALUE_MSB_MORE:G_TEST_VALUE_LSB_MORE'
C:00052c e018      	ldi		REG_TEMP_R17, 8
         
          exec_command_type_s_read_loop_0:
         	; Impression de 'X' ("[0xHHHH] ")
C:00052d d1cc      	rcall		print_2_bytes_hexa
         
         	; Impression du dump ("[0x....]")
C:00052e e0fe      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:00052f e6ea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:000530 de62      	rcall		push_text_in_fifo_tx
         
C:000531 e120      	ldi		REG_TEMP_R18, 16
         
          exec_command_type_s_read_loop_1:
         	; Valeur de la SRAM indexee par 'REG_X_MSB:REG_X_LSB'
C:000532 910d      	ld			REG_TEMP_R16, X+
C:000533 d192      	rcall		convert_and_put_fifo_tx
         
         	; Test limite 'RAMEND'
         	; => On suppose qu'au depart 'X <= RAMEND'
C:000534 30b2      	cpi		REG_X_MSB, ((RAMEND + 1) / 256)
C:000535 f421      	brne		exec_command_type_s_read_more2
C:000536 36a0      	cpi		REG_X_LSB, ((RAMEND + 1) % 256)
C:000537 f411      	brne		exec_command_type_s_read_more2
         
         	; Astuce pour gagner du code de presentation ;-)
C:000538 e021      	ldi		REG_TEMP_R18, 1
C:000539 e011      	ldi		REG_TEMP_R17, 1
         
          exec_command_type_s_read_more2:
C:00053a 952a      	dec		REG_TEMP_R18
C:00053b f7b1      	brne		exec_command_type_s_read_loop_1
         
C:00053c e0fe      	ldi		REG_Z_MSB, ((text_hexa_value_lf_end << 1) / 256)
C:00053d e7e0      	ldi		REG_Z_LSB, ((text_hexa_value_lf_end << 1) % 256)
C:00053e de54      	rcall		push_text_in_fifo_tx
         
C:00053f 951a      	dec		REG_TEMP_R17
C:000540 f761      	brne		exec_command_type_s_read_loop_0
         
C:000541 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'S'
         ; => Ecriture de plusieurs bytes dans la SRAM: "<SAAAA+BB+CC+DD..." avec:
         ;    - 0xAAAA: l'adresse du 1st byte a ecrire
         ;    - 0xBB:   la valeur 1st du byte a ecrire
         ;    - 0xCC:   la valeur 2nd du byte a ecrire
         ;    ...
         ;
         ; Reponse: "[NN>SAAAA]"
         ; ---------
          exec_command_type_s_write:
C:000542 df21      	rcall		print_command_ok			; Commande reconnue
         
         	; Prise du nombre de mots passes en arguments
C:000543 91a0 0124 	lds		REG_X_LSB, G_TEST_VALUES_IDX_WRK
C:000545 95a6      	lsr		REG_X_LSB									; REG_X_LSB /= 2 pour nbr de bytes a ecrire
         
C:000546 2f2a      	mov		REG_TEMP_R18, REG_X_LSB
         	; Fin: Prise du nombre de mots passes en arguments
         
         	; Recuperation de l'adresse du 1st byte a ecrire
C:000547 91b0 011e 	lds		REG_X_MSB, G_TEST_VALUE_MSB
C:000549 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB
         
         	; Test de 'REG_X_MSB:REG_X_LSB' dans la plage [SRAM_START, ..., 'G_SRAM_END_OF_USE'[
         	; => Adresse 'G_SRAM_END_OF_USE' exclue de la plage ;-)
C:00054b e600      	ldi		REG_TEMP_R16, low(SRAM_START)
C:00054c 17a0      	cp			REG_X_LSB, REG_TEMP_R16
C:00054d e000      	ldi		REG_TEMP_R16, high(SRAM_START)
C:00054e 07b0      	cpc		REG_X_MSB, REG_TEMP_R16
C:00054f f090      	brlo		exec_command_type_s_write_out_of_range		; Saut si X <= 'Adresse du 1er byte de la SRAM'
         
C:000550 e00b      	ldi		REG_TEMP_R16, low(G_SRAM_END_OF_USE)
C:000551 17a0      	cp			REG_X_LSB, REG_TEMP_R16
C:000552 e002      	ldi		REG_TEMP_R16, high(G_SRAM_END_OF_USE)
C:000553 07b0      	cpc		REG_X_MSB, REG_TEMP_R16
C:000554 f468      	brsh		exec_command_type_s_write_out_of_range		; Saut si X > 'Adresse du dernier byte utilise de la SRAM'
         
C:000555 df0e      	rcall		print_command_ok			; Commande reconnue
         
         	; Lecture des 'REG_TEMP_R18' mots de la SRAM dont seule la partie LSB sera ecrite
C:000556 2f12      	mov		REG_TEMP_R17, REG_TEMP_R18
C:000557 e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE)
C:000558 e2c6      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE)
         
          exec_command_type_s_write_loop:
C:000559 94f8      	cli
         
C:00055a 8108      	ld			REG_TEMP_R16, Y
C:00055b 930c      	st			X, REG_TEMP_R16
         
C:00055c 9611      	adiw		REG_X_LSB, 1			; Adresse SRAM suivante
C:00055d 9622      	adiw		REG_Y_LSB, 2			; Saut au prochain mot
C:00055e 951a      	dec		REG_TEMP_R17
C:00055f f7c9      	brne		exec_command_type_s_write_loop
         
C:000560 9478      	sei
         
C:000561 c001      	rjmp		exec_command_type_s_write_end
         
          exec_command_type_s_write_out_of_range:
C:000562 df06      	rcall		print_command_ko			; Commande non executee
         
          exec_command_type_s_write_end:
C:000563 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'e'
         ; => Dump de l'EEPROM: "<eAAAA-BBBB" avec:
         ;    - 0xAAAA: l'adresse du 1st byte a lire (si 0xAAAA == 0x0000 => Debut a l'adresse 0 de l'EEPROM
         ;    - 0xBBBB: le nombre de blocs de 16 bytes
         ;    - La lecture et l'emission sont effectuees 8 bytes par 8 bytes
         ;      avec une limitation des adresses dans la plage [0, ..., EEPROMEND]
         ;
         ; Reponse: "[NN>eAAAA]"
         ;          "[0xAAAA] [0xd0d1d2d3d4d5d6d7...]" (0xAAAA actualise @ adresse en cours)
         ; ---------
          exec_command_type_e_read:
C:000564 deff      	rcall		print_command_ok			; Commande reconnue
         
         	; Recuperation de l'adresse du 1st byte a lire
C:000565 91b0 011e 	lds		REG_X_MSB, G_TEST_VALUE_MSB
C:000567 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB
         
C:000569 23bb      	tst		REG_X_MSB
C:00056a f421      	brne		exec_command_type_e_read_cont_d
C:00056b 23aa      	tst		REG_X_LSB
C:00056c f411      	brne		exec_command_type_e_read_cont_d
         
         	; Dump de toute l'EEPROM
         	; TODO: Calcul @ 'EEPROMEND'
C:00056d e210      	ldi		REG_TEMP_R17, 32
C:00056e c001      	rjmp		exec_command_type_e_read_loop_0
         
          exec_command_type_e_read_cont_d:
         	; Dump sur 8 x 16 bytes
         	; TODO: Get 'G_TEST_VALUE_MSB_MORE:G_TEST_VALUE_LSB_MORE'
C:00056f e018      	ldi		REG_TEMP_R17, 8
         
          exec_command_type_e_read_loop_0:
         	; Impression de 'X' ("[0xHHHH] ")
C:000570 d189      	rcall		print_2_bytes_hexa
         
         	; Impression du dump ("[0x....]")
C:000571 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:000572 e6ea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:000573 de1f      	rcall		push_text_in_fifo_tx
         
C:000574 e120      	ldi		REG_TEMP_R18, 16
         
          exec_command_type_e_read_loop_1:
         	; Valeur de l'EEPROM indexee par 'REG_X_MSB:REG_X_LSB'
C:000575 de5d      	rcall		eeprom_read_byte
C:000576 d14f      	rcall		convert_and_put_fifo_tx
         
C:000577 9611      	adiw		REG_X_LSB, 1
         
         	; Test limite 'EEPROMEND'
         	; => On suppose qu'au depart 'X <= EEPROMEND'
C:000578 30b2      	cpi		REG_X_MSB, ((EEPROMEND + 1) / 256)
C:000579 f421      	brne		exec_command_type_e_read_more2
C:00057a 30a0      	cpi		REG_X_LSB, ((EEPROMEND + 1) % 256)
C:00057b f411      	brne		exec_command_type_e_read_more2
         
         	; Astuce pour gagner du code de presentation ;-)
C:00057c e021      	ldi		REG_TEMP_R18, 1
C:00057d e011      	ldi		REG_TEMP_R17, 1
         
          exec_command_type_e_read_more2:
C:00057e 952a      	dec		REG_TEMP_R18
C:00057f f7a9      	brne		exec_command_type_e_read_loop_1
         
C:000580 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value_lf_end << 1) / 256)
C:000581 e7e0      	ldi		REG_Z_LSB, ((text_hexa_value_lf_end << 1) % 256)
C:000582 de10      	rcall		push_text_in_fifo_tx
         
C:000583 951a      	dec		REG_TEMP_R17
C:000584 f759      	brne		exec_command_type_e_read_loop_0
         
C:000585 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'E'
         ; => Ecriture d'une suite de N bytes dans l'EEPROM (N dans [1, 2, ...])
         ;    - 0xAAAA:    l'adresse du byte a ecrire dans l'EEPROM
         ;
         ; Reponse: "[NN>EAAAA]" (Adresse du byte a ecrire)
         ; ---------
          exec_command_type_e_write:
         	; Prise du nombre de mots passes en arguments
C:000586 91a0 0124 	lds		REG_X_LSB, G_TEST_VALUES_IDX_WRK
C:000588 95a6      	lsr		REG_X_LSB									; REG_X_LSB /= 2 pour nbr de bytes a ecrire
         
C:000589 2f2a      	mov		REG_TEMP_R18, REG_X_LSB
         	; Fin: Prise du nombre de mots passes en arguments
         
         	; Recuperation de l'adresse du 1st byte a ecrire
C:00058a 91b0 011e 	lds		REG_X_MSB, G_TEST_VALUE_MSB
C:00058c 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB
         
         	; Test de 'REG_X_MSB:REG_X_LSB' dans la plage [0, ..., EEPROMEND] @ 'REG_TEMP_R18'
C:00058e e001      	ldi		REG_TEMP_R16, low(EEPROMEND + 2)
C:00058f e012      	ldi		REG_TEMP_R17, high(EEPROMEND + 2)
C:000590 1b02      	sub		REG_TEMP_R16, REG_TEMP_R18
C:000591 4010      	sbci		REG_TEMP_R17, 0					; Soustraction 16 bits (report de la Carry)
         
C:000592 17a0      	cp			REG_X_LSB, REG_TEMP_R16		
C:000593 07b1      	cpc		REG_X_MSB, REG_TEMP_R17		
C:000594 f502      	brpl		exec_command_type_e_write_out_of_range
         	; Fin: Test de 'REG_X_MSB:REG_X_LSB' dans la plage [0, ..., EEPROMEND] @ 'REG_TEMP_R18'
         
C:000595 dece      	rcall		print_command_ok			; Commande reconnue
         
         	; Lecture des 'REG_TEMP_R18' mots de la SRAM dont seule la partie LSB sera ecrite
C:000596 2f12      	mov		REG_TEMP_R17, REG_TEMP_R18
C:000597 e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE)
C:000598 e2c6      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE)
         
         	; Clear error
C:000599 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS
C:00059b 7b0f      	cbr		REG_TEMP_R16, FLG_TEST_EEPROM_ERROR_MSK
C:00059c 9300 011c 	sts		G_TEST_FLAGS, REG_TEMP_R16
         
          exec_command_type_e_write_loop:
C:00059e 8108      	ld			REG_TEMP_R16, Y
C:00059f de3a      	rcall		eeprom_write_byte
         
         	; Verification de l'ecriture
C:0005a0 2f20      	mov		REG_TEMP_R18, REG_TEMP_R16		; Save data writed
C:0005a1 2700      	clr		REG_TEMP_R16						; Raz before read eeprom @ 'X'
C:0005a2 de30      	rcall		eeprom_read_byte	
         
C:0005a3 1302      	cpse		REG_TEMP_R16, REG_TEMP_R18
C:0005a4 c005      	rjmp		exec_command_type_e_write_ko
         	; Fin: Verification de l'ecriture
         
C:0005a5 9611      	adiw		REG_X_LSB, 1			; Adresse EEPROM suivante
C:0005a6 9622      	adiw		REG_Y_LSB, 2			; Saut au prochain mot
C:0005a7 951a      	dec		REG_TEMP_R17
C:0005a8 f7a9      	brne		exec_command_type_e_write_loop
         
C:0005a9 c00c      	rjmp		exec_command_type_e_write_end
         
          exec_command_type_e_write_ko:
C:0005aa e0f8      	ldi      REG_Z_MSB, ((text_eeprom_error << 1) / 256)
C:0005ab e3e6      	ldi      REG_Z_LSB, ((text_eeprom_error << 1) % 256)
C:0005ac dde6      	rcall    push_text_in_fifo_tx
C:0005ad d14c      	rcall		print_2_bytes_hexa
C:0005ae d132      	rcall    print_line_feed
         
C:0005af 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS
C:0005b1 6400      	sbr		REG_TEMP_R16, FLG_TEST_EEPROM_ERROR_MSK
C:0005b2 9300 011c 	sts		G_TEST_FLAGS, REG_TEMP_R16
C:0005b4 c001      	rjmp		exec_command_type_e_write_end
         
          exec_command_type_e_write_out_of_range:
C:0005b5 deb3      	rcall		print_command_ko			; Commande non executee
         
          exec_command_type_e_write_end:
C:0005b6 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'f'
         ; => Lecture des fuses
         ; ---------
          exec_command_type_f_min:
C:0005b7 deac      	rcall		print_command_ok			; Commande reconnue
         
         ; Definition du bit 'RSIG' car non attribue dans 'tn85def.inc'
          .equ	RSIG = 5		; Read Device Signature Imprint Table
         
         	; Signature...
C:0005b8 e201      	ldi		REG_TEMP_R16, (1 << RSIG) | (1 << SPMEN)
C:0005b9 bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005ba e0f0      	ldi		REG_Z_MSB, 0x00
C:0005bb e0e0      	ldi		REG_Z_LSB, 0x00
C:0005bc 91a4      	lpm		REG_X_LSB, Z
C:0005bd d12d      	rcall		print_1_byte_hexa
         
C:0005be e201      	ldi		REG_TEMP_R16, (1 << RSIG) | (1 << SPMEN)
C:0005bf bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005c0 e0f0      	ldi		REG_Z_MSB, 0x00
C:0005c1 e0e2      	ldi		REG_Z_LSB, 0x02
C:0005c2 91a4      	lpm		REG_X_LSB, Z
C:0005c3 d127      	rcall		print_1_byte_hexa
         
C:0005c4 e201      	ldi		REG_TEMP_R16, (1 << RSIG) | (1 << SPMEN)
C:0005c5 bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005c6 e0f0      	ldi		REG_Z_MSB, 0x00
C:0005c7 e0e4      	ldi		REG_Z_LSB, 0x04
C:0005c8 91a4      	lpm		REG_X_LSB, Z
C:0005c9 d121      	rcall		print_1_byte_hexa
         
C:0005ca d116      	rcall		print_line_feed
         	; Fin: Signature...
         
         	; Read Fuse Low Byte
C:0005cb e009      	ldi		REG_TEMP_R16, (1 << RFLB) | (1 << SELFPRGEN)
C:0005cc bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005cd e0f0      	ldi		REG_Z_MSB, 0x00
C:0005ce e0e0      	ldi		REG_Z_LSB, 0x00
C:0005cf 91a4      	lpm		REG_X_LSB, Z
C:0005d0 d11a      	rcall		print_1_byte_hexa
         
         	; Read Lock bits
C:0005d1 e009      	ldi		REG_TEMP_R16, (1 << RFLB) | (1 << SELFPRGEN)
C:0005d2 bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005d3 e0f0      	ldi		REG_Z_MSB, 0x00
C:0005d4 e0e1      	ldi		REG_Z_LSB, 0x01
C:0005d5 91a4      	lpm		REG_X_LSB, Z
C:0005d6 d114      	rcall		print_1_byte_hexa
         
         	; Read Read Fuse Extended Byte
C:0005d7 e009      	ldi		REG_TEMP_R16, (1 << RFLB) | (1 << SELFPRGEN)
C:0005d8 bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005d9 e0f0      	ldi		REG_Z_MSB, 0x00
C:0005da e0e2      	ldi		REG_Z_LSB, 0x02
C:0005db 91a4      	lpm		REG_X_LSB, Z
C:0005dc d10e      	rcall		print_1_byte_hexa
         
         	; Read Fuse High Byte
C:0005dd e009      	ldi		REG_TEMP_R16, (1 << RFLB) | (1 << SELFPRGEN)
C:0005de bf07      	out		SPMCSR, REG_TEMP_R16
         
C:0005df e0f0      	ldi		REG_Z_MSB, 0x00
C:0005e0 e0e3      	ldi		REG_Z_LSB, 0x03
C:0005e1 91a4      	lpm		REG_X_LSB, Z
C:0005e2 d108      	rcall		print_1_byte_hexa
         
C:0005e3 d0fd      	rcall		print_line_feed
         
C:0005e4 9468      	set													; Commande reconnue
C:0005e5 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'p'
         ; => Dump de la memoire programme: "<pAAAA-BBBB" avec:
         ;    - 0xAAAA: l'adresse du 1st word a lire
         ;    - 0xBBBB: le nombre de blocs de 16 bytes
         ;    - La lecture et l'emission sont effectuees 8 bytes par 8 bytes
         ;
         ; Reponse: "[NN>pAAAA-BBBB]"
         ;          "[0xAAAA] [0xd0d1d2d3d4d5d6d7...]" (0xAAAA actualise @ adresse en cours)
         ; ---------
          exec_command_type_p_read:
C:0005e6 de7d      	rcall		print_command_ok			; Commande reconnue
         
         	; Recuperation de l'adresse du 1st byte a lire
C:0005e7 91b0 011e 	lds		REG_X_MSB, G_TEST_VALUE_MSB
C:0005e9 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB
         
         	; Adresse sur des mots
C:0005eb 0faa      	lsl		REG_X_LSB
C:0005ec 1fbb      	rol		REG_X_MSB
         
C:0005ed e018      	ldi		REG_TEMP_R17, 8
         
          exec_command_type_p_read_loop_0:
         	; Impression de 'X' ("[0xHHHH] ")
         	; Remarque: Division par 2 car dump de word ;-)
C:0005ee 93bf      	push		REG_X_MSB
C:0005ef 93af      	push		REG_X_LSB
         
C:0005f0 95b6      	lsr		REG_X_MSB
C:0005f1 95a7      	ror		REG_X_LSB
C:0005f2 d107      	rcall		print_2_bytes_hexa
         
C:0005f3 91af      	pop		REG_X_LSB
C:0005f4 91bf      	pop		REG_X_MSB
         
         	; Impression du dump ("[0x....]")
C:0005f5 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:0005f6 e6ea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:0005f7 dd9b      	rcall		push_text_in_fifo_tx
         
C:0005f8 e120      	ldi		REG_TEMP_R18, 16
         
          exec_command_type_p_read_loop_1:
         	; Valeur de la memoire programme indexee par 'REG_X_MSB:REG_X_LSB'
C:0005f9 01fd      	movw		REG_Z_LSB, REG_X_LSB
C:0005fa 9611      	adiw		REG_X_LSB, 1						; Preparation prochain byte
         
C:0005fb 9104      	lpm		REG_TEMP_R16, Z
C:0005fc d0c9      	rcall		convert_and_put_fifo_tx
         
C:0005fd 952a      	dec		REG_TEMP_R18
C:0005fe f7d1      	brne		exec_command_type_p_read_loop_1
         
C:0005ff e0fe      	ldi		REG_Z_MSB, ((text_hexa_value_lf_end << 1) / 256)
C:000600 e7e0      	ldi		REG_Z_LSB, ((text_hexa_value_lf_end << 1) % 256)
C:000601 dd91      	rcall		push_text_in_fifo_tx
         
C:000602 951a      	dec		REG_TEMP_R17
C:000603 f751      	brne		exec_command_type_p_read_loop_0
         
C:000604 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'x'
         ; => Execution d'une methode
         ; ---------
          exec_command_type_x:
C:000605 de5e      	rcall		print_command_ok			; Commande reconnue
         
         	; Recuperation de l'adresse d'execution
C:000606 91f0 011e 	lds		REG_Z_MSB, G_TEST_VALUE_MSB
C:000608 91e0 011f 	lds		REG_Z_LSB, G_TEST_VALUE_LSB
         
         	; Si execution du 'Reset' (adresse 0x0000)
         	; => Reinitialisation de 'SPH:SPL' a 'RAMEND'
C:00060a 23ff      	tst		REG_Z_MSB
C:00060b f431      	brne		exec_command_type_x_more
         
C:00060c 23ee      	tst		REG_Z_LSB
C:00060d f421      	brne		exec_command_type_x_more
         
C:00060e e002      	ldi		REG_TEMP_R16, high(RAMEND)
C:00060f bf0e      	out		SPH, REG_TEMP_R16
         
C:000610 e50f      	ldi		REG_TEMP_R16, low(RAMEND)
C:000611 bf0d      	out		SPL, REG_TEMP_R16
         	; Fin: Si execution du 'Reset' (adresse 0x0000)
         
         	; Saut a un programme dont l'adresse est passe en argument
         	; avec d'eventuels parametres apres 'CHAR_COMMAND_PLUS'
         	; => Remarque: Le 'ret' en fin de programme fera retourner apres
         	;              l'instruction 'rcall exec_command'
          exec_command_type_x_more:
C:000612 9409      	ijmp
         ; ---------
         
         ; ---------
         ; Conversion ASCII -> Decimal-16 bits
         ;
         ; Usage:
         ;		 rcall	char_to_dec_incremental		; 'REG_TEMP_R16' in ['0,', '1', ..., '9', 'A', ..., 'F'
         ;
         ; Registres utilises (sauvegarde/restaures):
         ;    REG_TEMP_R16 -> Caractere a convertir et a ajouter apres x10
         ;    REG_TEMP_R17 -> Working register
         ;    
         ; Warning: Pas de test du 'char' passe en argument dans la plage ['0,', '1', ..., '9']
         ;
         ; Retour ajoute a 'G_TEST_VALUE_DEC_MSB:G_TEST_VALUE_DEC_LSB' par decalage et sans raz
         ; => Raz a la charge de l'interpretation de la valeur
         ; ---------
          char_to_dec_incremental:
C:000613 93bf      	push		REG_X_MSB
C:000614 93af      	push		REG_X_LSB
C:000615 93df      	push		REG_Y_MSB
C:000616 93cf      	push		REG_Y_LSB
C:000617 930f      	push		REG_TEMP_R16
C:000618 931f      	push		REG_TEMP_R17
         
C:000619 91a0 0123 	lds		REG_X_LSB, G_TEST_VALUE_DEC_LSB	; Reprise valeur -> X
C:00061b 91b0 0122 	lds		REG_X_MSB, G_TEST_VALUE_DEC_MSB
         
         	; Multiplication par 10 = 2 x 5
C:00061d 0faa      	lsl		REG_X_LSB
C:00061e 1fbb      	rol		REG_X_MSB							; X = 2X
C:00061f 01ed      	movw		REG_Y_LSB, REG_X_LSB				; Y = 2X
         
         	; REG_TEMP_R17 = 4: 1st pass: X = 2X + 2X = 4X
         	; REG_TEMP_R17 = 3: 2nd pass: X = 4X + 2X = 6X
         	; REG_TEMP_R17 = 2: 3rd pass: X = 6X + 2X = 8X
         	; REG_TEMP_R17 = 1: 4th pass: X = 8X + 2X = 10X => Fin
         
C:000620 e014      	ldi		REG_TEMP_R17, 4
         
          char_to_dec_incremental_loop:
C:000621 0fac      	add		REG_X_LSB, REG_Y_LSB				; X += 2X
C:000622 1fbd      	adc		REG_X_MSB, REG_Y_MSB
C:000623 951a      	dec		REG_TEMP_R17
C:000624 f7e1      	brne		char_to_dec_incremental_loop
         
         	; Conversion et addition
C:000625 5300      	subi		REG_TEMP_R16, '0'
C:000626 0fa0      	add		REG_X_LSB, REG_TEMP_R16			; X += REG_TEMP_R16
C:000627 1fb1      	adc		REG_X_MSB, REG_TEMP_R17			; X += 0 + C
         
C:000628 93a0 0123 	sts		G_TEST_VALUE_DEC_LSB, REG_X_LSB
C:00062a 93b0 0122 	sts		G_TEST_VALUE_DEC_MSB, REG_X_MSB
         
C:00062c 911f      	pop		REG_TEMP_R17
C:00062d 910f      	pop		REG_TEMP_R16
C:00062e 91cf      	pop		REG_Y_LSB
C:00062f 91df      	pop		REG_Y_MSB
C:000630 91af      	pop		REG_X_LSB
C:000631 91bf      	pop		REG_X_MSB
C:000632 9508      	ret
         ; ---------
         
         ; ---------
         ; Conversion ASCII -> Hexa-16 bits
         ;
         ; Usage:
         ;		 rcall	char_to_hex_incremental	; 'REG_R2' in ['0,', '1', ..., '9', 'A', ..., 'F'
         ;
         ; Registres utilises (sauvegarde/restaures):
         ;    REG_TEMP_R16 -> Caractere a convertir et a ajouter apres x16
         ;    REG_TEMP_R17 -> Working register
         ;    
         ; Warning: Pas de test du 'char' passe en argument dans la plage ['0,', '1', ..., '9', 'A', ..., 'F']
         ;
         ; Retour ajoute a 'G_TEST_VALUE_MSB:G_TEST_VALUE_LSB'
         ; ---------
          char_to_hex_incremental:
C:000633 930f      	push		REG_TEMP_R16
C:000634 931f      	push		REG_TEMP_R17
         
         	; Discrimination...
C:000635 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS
C:000637 fd02      	sbrc		REG_TEMP_R16, FLG_TEST_COMMAND_MORE_IDX
C:000638 c005      	rjmp		char_to_hex_incremental_more
         
C:000639 91a0 011f 	lds		REG_X_LSB, G_TEST_VALUE_LSB			; Reprise valeur -> X
C:00063b 91b0 011e 	lds		REG_X_MSB, G_TEST_VALUE_MSB
C:00063d c004      	rjmp		char_to_hex_incremental_cont_d
         
          char_to_hex_incremental_more:
C:00063e 91a0 0121 	lds		REG_X_LSB, G_TEST_VALUE_LSB_MORE		; Reprise valeur -> X
C:000640 91b0 0120 	lds		REG_X_MSB, G_TEST_VALUE_MSB_MORE
         	; Fin: Discrimination...
         
          char_to_hex_incremental_cont_d:
C:000642 2d02      	mov		REG_TEMP_R16, REG_R2				; Recuperation valeur a concatener
         
         	; REG_TEMP_R17 = 4: 1st pass: X = 2X
         	; REG_TEMP_R17 = 3: 2nd pass: X = 4X
         	; REG_TEMP_R17 = 2: 3rd pass: X = 8X
         	; REG_TEMP_R17 = 1: 4th pass: X = 16X => Fin
         
C:000643 e014      	ldi		REG_TEMP_R17, 4
         
          char_to_hex_incremental_loop:
C:000644 0faa      	lsl		REG_X_LSB				; X *= 2
C:000645 1fbb      	rol		REG_X_MSB
C:000646 951a      	dec		REG_TEMP_R17
C:000647 f7e1      	brne		char_to_hex_incremental_loop
         
         	; Conversion ['0', ... , '9'] = [0x30, ... , 0x39] -> [0x0, ..., 0x9]
         	;            ['A', ... , 'F'] = [0x41, ... , 0x46] -> [0xa, ..., 0xf]
         	;            ['a', ... , 'f'] = [0x61, ... , 0x66] -> [0xa, ..., 0xf]
         	;
C:000648 fd06      	sbrc		REG_TEMP_R16, IDX_BIT6			; ['0', ... , '9'] ?
C:000649 c002      	rjmp		char_to_hex_incremental_a_f	; Non
         
          char_to_hex_incremental_0_9:					; Oui
C:00064a 5300      	subi		REG_TEMP_R16, '0'
C:00064b c002      	rjmp		char_to_hex_incremental_add
         
          char_to_hex_incremental_a_f:
C:00064c 7d0f      	cbr		REG_TEMP_R16, MSK_BIT5			; Lowercase -> Uppercase ('a' (0x61) -> 'A' (0x41))
C:00064d 5307      	subi		REG_TEMP_R16, ('A' - 0xa)		; 'A' -> 0xa, ..., 'F' -> 0xf
         
          char_to_hex_incremental_add:
C:00064e 700f      	andi		REG_TEMP_R16, 0x0f				; Filtre Bits<3,0> (precaution ;-)
C:00064f 2ba0      	or			REG_X_LSB, REG_TEMP_R16			; X |= REG_TEMP_R16
         
         	; Discrimination...
C:000650 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS
C:000652 fd02      	sbrc		REG_TEMP_R16, FLG_TEST_COMMAND_MORE_IDX
C:000653 c005      	rjmp		char_to_hex_incremental_more_2
         
C:000654 93a0 011f 	sts		G_TEST_VALUE_LSB, REG_X_LSB
C:000656 93b0 011e 	sts		G_TEST_VALUE_MSB, REG_X_MSB
C:000658 c004      	rjmp		char_to_hex_incremental_end
         
          char_to_hex_incremental_more_2:
C:000659 93a0 0121 	sts		G_TEST_VALUE_LSB_MORE, REG_X_LSB
C:00065b 93b0 0120 	sts		G_TEST_VALUE_MSB_MORE, REG_X_MSB
         	; Fin: Discrimination...
         
          char_to_hex_incremental_end:
         
C:00065d 911f      	pop		REG_TEMP_R17
C:00065e 910f      	pop		REG_TEMP_R16
C:00065f 9508      	ret
         ; ---------
         
         ; ---------
         ; Raz de 'G_TEST_VALUES_ZONE'
         ; ---------
          raz_value_into_zone:
C:000660 93df      	push		REG_Y_MSB
C:000661 93cf      	push		REG_Y_LSB
C:000662 930f      	push		REG_TEMP_R16
C:000663 931f      	push		REG_TEMP_R17
         
C:000664 2700      	clr		REG_TEMP_R16
C:000665 9300 0124 	sts		G_TEST_VALUES_IDX_WRK, REG_TEMP_R16
         
C:000667 e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE)
C:000668 e2c6      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE)
         
C:000669 e200      	ldi		REG_TEMP_R16, 32
C:00066a 2711      	clr		REG_TEMP_R17
         
          raz_value_into_zone_loop:
C:00066b 9319      	st			Y+, REG_TEMP_R17
C:00066c 9319      	st			Y+, REG_TEMP_R17
         
C:00066d 950a      	dec		REG_TEMP_R16
C:00066e f7e1      	brne		raz_value_into_zone_loop
         
C:00066f 911f      	pop		REG_TEMP_R17
C:000670 910f      	pop		REG_TEMP_R16
C:000671 91cf      	pop		REG_Y_LSB
C:000672 91df      	pop		REG_Y_MSB
         
C:000673 9508      	ret
         ; ---------
         
         ; Recopie de 'G_TEST_VALUE_MSB_MORE:G_TEST_VALUE_LSB_MORE' a 'G_TEST_VALUES_ZONE'
         ; ---------
          add_value_into_zone:
C:000674 93bf      	push		REG_X_MSB
C:000675 93af      	push		REG_X_LSB
C:000676 93df      	push		REG_Y_MSB
C:000677 93cf      	push		REG_Y_LSB
C:000678 930f      	push		REG_TEMP_R16
C:000679 931f      	push		REG_TEMP_R17
         
C:00067a 9100 0124 	lds		REG_TEMP_R16, G_TEST_VALUES_IDX_WRK
C:00067c e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE)
C:00067d e2c6      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE)
C:00067e 2711      	clr		REG_TEMP_R17
C:00067f 0fc0      	add		REG_Y_LSB, REG_TEMP_R16
C:000680 1fd1      	adc		REG_Y_MSB, REG_TEMP_R17
         
C:000681 91b0 0120 	lds		REG_X_MSB, G_TEST_VALUE_MSB_MORE
C:000683 91a0 0121 	lds		REG_X_LSB, G_TEST_VALUE_LSB_MORE
         
C:000685 83a8      	std		Y+0, REG_X_LSB			; LSB en tete
C:000686 83b9      	std		Y+1, REG_X_MSB
         
C:000687 9503      	inc		REG_TEMP_R16			; Next word
C:000688 9503      	inc		REG_TEMP_R16
C:000689 9300 0124 	sts		G_TEST_VALUES_IDX_WRK, REG_TEMP_R16
         
         	; Raz donnee
C:00068b 2700      	clr		REG_TEMP_R16
C:00068c 9300 0120 	sts		G_TEST_VALUE_MSB_MORE, REG_TEMP_R16
C:00068e 9300 0121 	sts		G_TEST_VALUE_LSB_MORE, REG_TEMP_R16
         
C:000690 911f      	pop		REG_TEMP_R17
C:000691 910f      	pop		REG_TEMP_R16
C:000692 91cf      	pop		REG_Y_LSB
C:000693 91df      	pop		REG_Y_MSB
C:000694 91af      	pop		REG_X_LSB
C:000695 91bf      	pop		REG_X_MSB
         
C:000696 9508      	ret
         ; ---------
         
          text_crc8_maxim_label:
          .db	"[CRC8-MAXIM ", CHAR_NULL, CHAR_NULL
C:000697 5B435243382D4D4158494D200000
         
         ; End of file
         
          
          #endif
         
          .include		"ATtiny85_uOS_Print.asm"
         ; "$Id: ATtiny85_uOS_Print.asm,v 1.16 2025/12/17 22:16:43 administrateur Exp $"
         
          .include		"ATtiny85_uOS_Print.h"
         ; "$Id: ATtiny85_uOS_Print.h,v 1.2 2025/12/01 17:36:27 administrateur Exp $
         
          #define  CHAR_LF					0x0A		; Line Feed ('\n')
          #define  CHAR_CR					0x0D		; Carriage Return ('\r')
          #define  CHAR_NULL				0x00		; '\0'
         
          .dseg
D:000166    G_HEADER_TYPE_PLATINE:		.byte		1		; Type de la platine lu de l'EEPROM
D:000167    G_HEADER_INDEX_PLATINE:		.byte		1		; Index de la platine lu de l'EEPROM
         
         ; End of file
         
          
         
          .cseg
         ; ---------
         ; Allumage fugitif Led RED Externe si erreur
         ; => L'effacement des 2 'FLG_0_UART_RX_BYTE_START_ERROR' et 'FLG_0_UART_RX_BYTE_STOP_ERROR'
         ;    est effectue sur la reception d'un nouveau caratere sans erreur ;-)
         ;    => L'allumage peut durer au dela de la valeur d'initialisation du timer 'TIMER_ERROR'
         ;       et donc ne pas presenter d'autres erreurs a definir
         ;       => Choix: Effacement sur time-out de 'TIMER_CONNECT'
         ;
         ; => L'effacement des 2 'FLG_1_UART_FIFO_RX_FULL' et 'FLG_1_UART_FIFO_TX_FULL'
         ;    est effectue des lors que la FIFO/Rx ou Tx n'est plus "vue" comme pleine
         ;    => Des carateres peuvent avoir ete perdus dans l'empilement dans la FIFO
         ;
          presentation_error:
C:00069e fd86      	sbrc		REG_FLAGS_0, FLG_0_UART_RX_BYTE_START_ERROR_IDX
C:00069f c00d      	rjmp		presentation_error_reinit
C:0006a0 fd87      	sbrc		REG_FLAGS_0, FLG_0_UART_RX_BYTE_STOP_ERROR_IDX
C:0006a1 c00b      	rjmp		presentation_error_reinit
C:0006a2 fd91      	sbrc		REG_FLAGS_1, FLG_1_UART_FIFO_RX_FULL_IDX
C:0006a3 c009      	rjmp		presentation_error_reinit
C:0006a4 fd95      	sbrc		REG_FLAGS_1, FLG_1_UART_FIFO_TX_FULL_IDX
C:0006a5 c007      	rjmp		presentation_error_reinit
         
          #ifndef USE_MINIMALIST_UOS
C:0006a6 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS			; Prise des flags 'G_TEST_FLAGS'
         
C:0006a8 fd04      	sbrc		REG_TEMP_R16, FLG_TEST_COMMAND_ERROR_IDX
C:0006a9 c003      	rjmp		presentation_error_reinit
         
C:0006aa fd06      	sbrc		REG_TEMP_R16, FLG_TEST_EEPROM_ERROR_IDX
C:0006ab c001      	rjmp		presentation_error_reinit
          #endif
         
C:0006ac c010      	rjmp		presentation_error_rtn
         
          presentation_error_reinit:
         	; Reinitialisation timer 'TIMER_ERROR' tant que erreur(s) presente(s)
C:0006ad e011      	ldi		REG_TEMP_R17, TIMER_ERROR
C:0006ae ec28      	ldi		REG_TEMP_R18, (200 % 256)
C:0006af e030      	ldi		REG_TEMP_R19, (200 / 256)
C:0006b0 eb40      	ldi		REG_TEMP_R20, low(exec_timer_error)
C:0006b1 e052      	ldi		REG_TEMP_R21, high(exec_timer_error)
C:0006b2 dbb1      	rcall		start_timer
         
          #ifndef USE_MINIMALIST_UOS
         	; Effacement de certaines erreurs non fugitives
C:0006b3 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS 
C:0006b5 7e0f      	cbr		REG_TEMP_R16, FLG_TEST_COMMAND_ERROR_MSK
C:0006b6 9300 011c 	sts		G_TEST_FLAGS, REG_TEMP_R16
          #endif
         
C:0006b8 94f8      	cli
C:0006b9   +  	setLedRedOn
C:0006b9 6890      sbr		REG_FLAGS_1, FLG_1_LED_RED_ON_MSK	

C:0006ba 7e7f      cbr		REG_PORTB_OUT, MSK_BIT_LED_RED
C:0006bb bb78      out		PORTB, REG_PORTB_OUT					

C:0006bc 9478      	sei
         
          presentation_error_rtn:
C:0006bd 9508      	ret
         ; ---------
         
         ; ---------
         ; Conversion en minuscule si 'text_convert_hex_to_min_ascii_table' utilisee
         ; Conversion en majuscule si 'text_convert_hex_to_maj_ascii_table' utilisee
         ; ---------
          convert_nibble_to_ascii:
C:0006be 700f      	andi		REG_TEMP_R16, 0x0f
C:0006bf e0fe      	ldi		REG_Z_MSB, high(text_convert_hex_to_min_ascii_table << 1)
C:0006c0 e7e6      	ldi		REG_Z_LSB, low(text_convert_hex_to_min_ascii_table << 1)
C:0006c1 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:0006c2 2700      	clr		REG_TEMP_R16
C:0006c3 1ff0      	adc		REG_Z_MSB, REG_TEMP_R16
C:0006c4 9104      	lpm		REG_TEMP_R16, Z
         
          convert_nibble_to_ascii_rtn:
C:0006c5 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un byte converti en 2 hex-char
         ;
         ; Usage:
         ;      ldi		REG_TEMP_R16, <value>
         ;      rcall   convert_and_put_fifo_tx
         ; ---------
          convert_and_put_fifo_tx:
C:0006c6 930f      	push		REG_TEMP_R16		; Sauvegarde de la valeur a convertir et ecrire
         
C:0006c7 9502      	swap		REG_TEMP_R16		; Copie Bits<7-4> dans Bits<3-0>
C:0006c8 dff5      	rcall		convert_nibble_to_ascii
C:0006c9 dcd8      	rcall    push_1_char_in_fifo_tx
         
C:0006ca 910f      	pop		REG_TEMP_R16		; Reprise de la valeur a convertir et ecrire
         
C:0006cb dff2      	rcall		convert_nibble_to_ascii
C:0006cc dcd5      	rcall    push_1_char_in_fifo_tx
         
C:0006cd 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         ; Presentation de l'etat de connexion
         ; ---------
          presentation_connexion:
C:0006ce ff90      	sbrs		REG_FLAGS_1, FLG_1_UART_FIFO_RX_NOT_EMPTY_IDX
C:0006cf c00e      	rjmp		presentation_connexion_fifo_rx_empty
         
          presentation_connexion_fifo_rx_not_empty:
         	; FIFO/Rx non vide
         	; Test si 'Non Connecte' ?
         	; => Si Oui: Changement chenillard
C:0006d0 fd93      	sbrc		REG_FLAGS_1, FLG_1_CONNECTED_IDX
C:0006d1 c005      	rjmp		presentation_connexion_reinit_timer
         
         	; Changement chenillard
C:0006d2 ef0e      	ldi		REG_TEMP_R16, 0xFE
C:0006d3 9300 0064 	sts		G_CHENILLARD_MSB, REG_TEMP_R16
C:0006d5 9300 0065 	sts		G_CHENILLARD_LSB, REG_TEMP_R16
         
          presentation_connexion_reinit_timer:
         	; Reinitialisation timer 'TIMER_CONNECT' tant que FIFO/Rx non vide
C:0006d7 e010      	ldi		REG_TEMP_R17, TIMER_CONNECT
C:0006d8 eb28      	ldi		REG_TEMP_R18, (3000 % 256)
C:0006d9 e03b      	ldi		REG_TEMP_R19, (3000 / 256)
C:0006da ea47      	ldi		REG_TEMP_R20, low(exec_timer_connect)
C:0006db e052      	ldi		REG_TEMP_R21, high(exec_timer_connect)
C:0006dc db87      	rcall		start_timer
         
         	; Passage en mode 'Connecte' pour une presentation Led GREEN --\__/-----
C:0006dd 6098      	sbr		REG_FLAGS_1, FLG_1_CONNECTED_MSK
         	;rjmp		presentation_connexion_rtn
         
          presentation_connexion_fifo_rx_empty:
         	; Passage en mode 'Non Connecte' a l'expiration du timer 'TIMER_CONNECT'
         
          presentation_connexion_rtn:
C:0006de 9508      	ret
         ; ---------
          #endif
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
          uos_print_line_feed_skip:
          print_line_feed_skip:
C:0006df fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:0006e0 9508      	ret
          #endif
         
          uos_print_line_feed:
          print_line_feed:
C:0006e1 93ff      	push		REG_Z_MSB
C:0006e2 93ef      	push		REG_Z_LSB
         
C:0006e3 e0fe      	ldi		REG_Z_MSB, ((text_line_feed << 1) / 256)
C:0006e4 e7e4      	ldi		REG_Z_LSB, ((text_line_feed << 1) % 256)
C:0006e5 dcad      	rcall		push_text_in_fifo_tx
         
C:0006e6 91ef      	pop		REG_Z_LSB
C:0006e7 91ff      	pop		REG_Z_MSB
C:0006e8 9508      	ret
         ; ---------
         
         ; ---------
          uos_print_1_byte_hexa_skip:
          print_1_byte_hexa_skip:
C:0006e9 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:0006ea 9508      	ret
         
          uos_print_1_byte_hexa:
          print_1_byte_hexa:
C:0006eb 93ff      	push		REG_Z_MSB
C:0006ec 93ef      	push		REG_Z_LSB
         
         	; Emission en hexa du contenu de 'REG_X_LSB'
C:0006ed e0fe      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:0006ee e6ea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:0006ef dca3      	rcall		push_text_in_fifo_tx
         
C:0006f0 2f0a      	mov		REG_TEMP_R16, REG_X_LSB
C:0006f1 dfd4      	rcall		convert_and_put_fifo_tx
         
C:0006f2 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value_end << 1) / 256)
C:0006f3 e6ee      	ldi		REG_Z_LSB, ((text_hexa_value_end << 1) % 256)
C:0006f4 dc9e      	rcall		push_text_in_fifo_tx
         
C:0006f5 91ef      	pop		REG_Z_LSB
C:0006f6 91ff      	pop		REG_Z_MSB
C:0006f7 9508      	ret
         ; ---------
         
         ; ---------
          uos_print_2_bytes_hexa_skip:
          print_2_bytes_hexa_skip:
C:0006f8 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:0006f9 9508      	ret
         
          uos_print_2_bytes_hexa:
          print_2_bytes_hexa:
C:0006fa 93ff      	push		REG_Z_MSB
C:0006fb 93ef      	push		REG_Z_LSB
         
         	; Emission en hexa du contenu de 'REG_X_MSB:REG_X_LSB'
C:0006fc e0fe      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:0006fd e6ea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:0006fe dc94      	rcall		push_text_in_fifo_tx
         
C:0006ff 2f0b      	mov		REG_TEMP_R16, REG_X_MSB
C:000700 dfc5      	rcall		convert_and_put_fifo_tx
         
C:000701 2f0a      	mov		REG_TEMP_R16, REG_X_LSB
C:000702 dfc3      	rcall		convert_and_put_fifo_tx
         
C:000703 e0fe      	ldi		REG_Z_MSB, ((text_hexa_value_end << 1) / 256)
C:000704 e6ee      	ldi		REG_Z_LSB, ((text_hexa_value_end << 1) % 256)
C:000705 dc8d      	rcall		push_text_in_fifo_tx
         
C:000706 91ef      	pop		REG_Z_LSB
C:000707 91ff      	pop		REG_Z_MSB
C:000708 9508      	ret
         ; ---------
         
         ; ---------
         ; Marquage traces
         ; ---------
          uos_print_mark_skip:
          print_mark_skip:
C:000709 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:00070a 9508      	ret
         
          print_mark:
C:00070b 930f      	push		REG_TEMP_R16
C:00070c e003      	ldi		REG_TEMP_R16, 3
         
          print_mark_loop:
C:00070d 930f      	push		REG_TEMP_R16
C:00070e 3002      	cpi		REG_TEMP_R16, 2
C:00070f f411      	brne		print_mark_loop_a
C:000710 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:000711 c001      	rjmp		print_mark_loop_b
         
          print_mark_loop_a:
C:000712 e20d      	ldi		REG_TEMP_R16, '-'
         
          print_mark_loop_b:
C:000713 dc8e      	rcall		push_1_char_in_fifo_tx
C:000714 910f      	pop		REG_TEMP_R16
C:000715 950a      	dec		REG_TEMP_R16
C:000716 f7b1      	brne		print_mark_loop
         
C:000717 dfc9      	rcall		print_line_feed
C:000718 6490      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK	; Flush...
         
C:000719 910f      	pop		REG_TEMP_R16
         
C:00071a 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         ; Print du registre X
         ; ---------
          uos_print_x_reg_skip:
          print_x_reg_skip:
C:00071b fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:00071c 9508      	ret
          #endif
         
         ; ---------
         ; En mode 'Minimaliste', l'addon 'ATtiny85_uOS_Test_Addons.asm' peut etre inclus
         ; => Appel a 'print_x_reg' dans les methodes de test ;-)
         ; ---------
          uos_print_x_reg:
          print_x_reg:
C:00071d 93ff      	push		REG_Z_MSB
C:00071e 93ef      	push		REG_Z_LSB
         
C:00071f dfda      	rcall		print_2_bytes_hexa
         
C:000720 91ef      	pop		REG_Z_LSB
C:000721 91ff      	pop		REG_Z_MSB
C:000722 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_UOS
         ; ---------
         ; Print du registre Y
         ; ---------
          uos_print_y_reg_skip:
          print_y_reg_skip:
C:000723 fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:000724 9508      	ret
         
          uos_print_y_reg:
          print_y_reg:
C:000725 93bf      	push		REG_X_MSB
C:000726 93af      	push		REG_X_LSB
         
C:000727 01de      	movw		REG_X_LSB, REG_Y_LSB
C:000728 dff4      	rcall		print_x_reg
         
C:000729 91af      	pop		REG_X_LSB
C:00072a 91bf      	pop		REG_X_MSB
C:00072b 9508      	ret
         ; ---------
         
         ; ---------
         ; Print du registre Z
         ; ---------
          uos_print_z_reg_skip:
          print_z_reg_skip:
C:00072c fd85      	sbrc		REG_FLAGS_0, FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
C:00072d 9508      	ret
         
          uos_print_z_reg:
          print_z_reg:
C:00072e 93bf      	push		REG_X_MSB
C:00072f 93af      	push		REG_X_LSB
         
C:000730 01df      	movw		REG_X_LSB, REG_Z_LSB
C:000731 dfeb      	rcall		print_x_reg
         
C:000732 91af      	pop		REG_X_LSB
C:000733 91bf      	pop		REG_X_MSB
C:000734 9508      	ret
         ; ---------
          #endif
         
          text_hexa_value:
          .db	"[0x", CHAR_NULL
C:000735 5B307800
         
          text_hexa_value_end:
          .db	"]", CHAR_NULL
C:000737 5D00
         
          text_hexa_value_lf_end:
          .db	"]", CHAR_LF, CHAR_NULL, CHAR_NULL
C:000738 5D0A0000
         
          text_line_feed:
          .db	CHAR_LF, CHAR_NULL
C:00073A 0A00
         
          #if 0		; Provision pour une conversion en majuscule
          #endif
         
          text_convert_hex_to_min_ascii_table:
          .db	"0123456789abcdef"
C:00073B 30313233343536373839616263646566
         
         ; End of file
         
          
         
          end_of_prg_uos:		; Adresse de fin de uOS
         
         ; Inclusion de 'ATtiny85_uOS_Test_Addons.asm':
         ; - Si la directive USE_ADDON n'est pas definie
         ;   => Car un programme addon est attendu
         ; - Et si la directive USE_MINIMALIST_UOS est definie
         ;   => Car le commandes de monitoring ne sont pas implementees
          #ifndef USE_ADDONS
          #endif
         ; Fin: Pas d'inclusion de 'ATtiny85_uOS_Test_Addons.asm' si un ADDON est defini
         
         ; End of file
         
          
         
          .include		"ATtiny85_uOS+DS18B20.h"
         ; "$Id: ATtiny85_uOS+DS18B20.h,v 1.19 2025/12/17 09:20:55 administrateur Exp $"
         
          #define	USE_DS18B20_TRACE				0
         
         ; Support de 4 capteurs ('DS18B20_NBR_ROM_TO_DETECT' inferieur ou egal a 'DS18B20_NBR_ROM_GESTION')
          #ifndef USE_MINIMALIST_ADDONS
          #define	DS18B20_NBR_ROM_TO_DETECT	4
          #else
          #endif
         
          #define	DS18B20_NBR_ROM_GESTION		8		; Gestion interne des ROM a concurence de 8 max (NE PAS MODIFIER)
         
          #define	IDX_BIT_1_WIRE					IDX_BIT2
          #define	NBR_BITS_TO_SHIFT				8
         
         ; Remarque: 8 timers minimum definis dans uOS (cf. 'ATtiny85_uOS_Timers.h')
          #define	DS18B20_TIMER_1_SEC			(NBR_TIMER - 1)	; Timer pour les mesures des temperatures et les emissions de trames
         
          #ifndef USE_MINIMALIST_ADDONS
          #define	CHAR_TYPE_COMMAND_C_MAJ		'C'
          #define	CHAR_TYPE_COMMAND_T_MAJ		'T'
          #endif
         
         ; Definitions et Variables pour la gestion des DS18B20
          #define	FLG_DS18B20_CONV_T_MSK		MSK_BIT0
          #define	FLG_DS18B20_TEMP_MSK			MSK_BIT1
          #define	FLG_DS18B20_FRAMES_MSK		MSK_BIT2		; Trames en lieu et place des 'G_DS18B20_ALR_ROM_N'
          #define	FLG_DS18B20_TRACE_MSK		MSK_BIT3		; Trace Enable (1) /Disable (0) (0 by default)
          #define	FLG_TEST_CONFIG_ERROR_MSK	MSK_BIT7
         
          #define	FLG_DS18B20_CONV_T_IDX		IDX_BIT0
          #define	FLG_DS18B20_TEMP_IDX			IDX_BIT1
          #define	FLG_DS18B20_FRAMES_IDX		IDX_BIT2		; Trames en lieu et place des 'G_DS18B20_ALR_ROM_N'
          #define	FLG_DS18B20_TRACE_IDX		IDX_BIT3		; Trace Enable (1) /Disable (0) (0 by default)
          #define	FLG_TEST_CONFIG_ERROR_IDX	IDX_BIT7
         
          #define	EEPROM_ADDR_NBR_DS18B20_TO_DETECT			15
          #define	EEPROM_ADDR_PRIMES								16
         
          .dseg
         
D:000168    G_DS18B20_FLAGS:					.byte		1
         
D:000169    G_HEADER_NUM_FRAME_MSB:			.byte		1		; Numero de la trame emise par la platine (MSB)
D:00016a    G_HEADER_NUM_FRAME_LSB:			.byte		1		; et (LSB)
D:00016b    G_HEADER_TIMESTAMP_MSB:			.byte		1		; Timestamp en Sec. de l'emission de la trame complete (MSB)
D:00016c    G_HEADER_TIMESTAMP_MID:			.byte		1		; + (MID)
D:00016d    G_HEADER_TIMESTAMP_LSB:			.byte		1		; et (LSB)
D:00016e    G_HEADER_NBR_CAPTEURS:			.byte		1		; Nombre de capteurs
         
D:00016f    G_DS18B20_BYTES_SEND:			.byte		16		; Bytes a emettre sur le 1-Wire
D:00017f    G_DS18B20_BYTES_RESP:			.byte		16		; Bytes recus sur le 1-Wire
D:00018f    G_DS18B20_BYTES_ROM:				.byte		8		; ROM extrait de la recherche
         
D:000197    G_BUS_1_WIRE_FLAGS:				.byte		1
         
D:000198    G_DS18B20_IN_ALARM:				.byte		1
D:000199    G_DS18B20_FAMILLE:				.byte		1
D:00019a    G_DS18B20_COUNTER:				.byte		1
D:00019b    G_DS18B20_COUNTER_INIT:			.byte		1
D:00019c    G_DS18B20_NBR_BITS_RETRY:		.byte		1		; Numero de la passe ((1 << n) - 1) <= au nbr de bits inconnus
D:00019d    G_DS18B20_PATTERN:				.byte		1		; Pattern a tester
D:00019e    G_DS18B20_NBR_BITS_0_1:			.byte		1		; Nbr de bits inconnus (retour de 0x00) a balayer
D:00019f    G_DS18B20_NBR_BITS_0_1_MAX: 	.byte		1		; Nbr de bits inconnus maximal (pour verification @ pattern a tester
D:0001a0    G_DS18B20_NBR_ROM_FOUND:		.byte		1		; Nbr de ROM trouve
D:0001a1    G_DS18B20_NBR_ROM_MAX:			.byte		1		; Nbr de ROM maximal supporte (lu depuis l'EEPROM)
D:0001a2    G_DS18B20_ROM_IDX_WRK:			.byte		1		; Index dans la table des ROM a rechercher / trouve
D:0001a3    G_DS18B20_ROM_IDX:				.byte		1		; Index du ROM "matche" dans la plage [0, 1, 2, etc.]
         
         ; Reservation pour 'DS18B20_NBR_ROM_TO_DETECT' capteurs (ROM)
D:0001a4    G_DS18B20_ROM_0:					.byte		(DS18B20_NBR_ROM_TO_DETECT * 8)	; Reservation pour 'DS18B20_NBR_ROM_TO_DETECT' ROM
         
         ; Position des donnees '<NAME>' dans 'G_DS18B20_BYTES_RESP' a recopier @ FRAME_IDX_<NAME>
         ; ie. "0xB9 10 7F FF 7F C9 16 01  36"
         ;              Resol    Tl Th Tch Tcl
         ;
          #define	RESP_IDX_TC_LSB			8
          #define	RESP_IDX_TC_MSB			7
          #define	RESP_IDX_TL					5
          #define	RESP_IDX_TH					6
          #define	RESP_IDX_RESOL_CONV 		2
         
         ; Definitions des positions dans la trame
          #define	FRAME_IDX_TYPE_PLATINE		15		; Type de la platine lu de l'EEPROM
          #define	FRAME_IDX_INDEX_PLATINE		14		; Index de la platine lu de l'EEPROM
          #define	FRAME_IDX_NUM_FRAME_MSB		13		; Numero de la trame emise par cette platine (MSB)
          #define	FRAME_IDX_NUM_FRAME_LSB		12		; et (LSB)
          #define	FRAME_IDX_TIMESTAMP_MSB		11		; Timestamp en Sec. de l'emission de la trame complete (MSB)
          #define	FRAME_IDX_TIMESTAMP_MID		10		; et (LSB)
          #define	FRAME_IDX_TIMESTAMP_LSB		9		; et (LSB)
          #define	FRAME_IDX_NBR_CAPTEURS		8		; Nombre de capteurs
         
          #define	FRAME_IDX_IDX					7		; Index du capteur de temperature (1 byte)
          #define	FRAME_IDX_FAMILLE				6		; Famille du capteur (1 byte)
          #define	FRAME_IDX_TC_MSB   			5		; Temperature courante Tc (2 bytes)
          #define	FRAME_IDX_TC_LSB				4
          #define	FRAME_IDX_TH					3		; Temperature de seuil Th (1 byte)
          #define	FRAME_IDX_TL					2		; Temperature de seuil Tl (1 byte)
          #define	FRAME_IDX_ALR_RES_CONV		1		; Alarme + Resolution de la conversion analogique (1 byte)
          #define	FRAME_IDX_CRC8					0		; CRC8 des 7 bytes precedents (1 byte)
         
          #define	FRAME_LENGTH_CAPTEUR			(FRAME_IDX_IDX + 1)		; Longueur d'une trame capteur
         ; Fin: Definitions des positions dans la trame
         
         ; Variables pour la gestion des DS18B20 (commande 'alarm search' DS18B20_CMD_SEARCH_ALARM)
         ; => Memes principes que pour la commande DS18B20_CMD_SEARCH_ROM
D:0001c4    G_DS18B20_ALR_NBR_BITS_RETRY:		.byte		1		; Numero de la passe ((1 << n) - 1) <= au nbr de bits inconnus
D:0001c5    G_DS18B20_ALR_PATTERN:				.byte		1		; Pattern a tester
D:0001c6    G_DS18B20_ALR_NBR_BITS_0_1:		.byte		1		; Nombre de bits inconnus (retour de 0x00) a balayer)
D:0001c7    G_DS18B20_ALR_NBR_BITS_0_1_MAX:	.byte		1		; Nombre de bits inconnus maximal (pour verification @ pattern a tester
D:0001c8    G_DS18B20_ALR_NBR_ROM:				.byte		1		; Nombre de ROM trouve
D:0001c9    G_DS18B20_ALR_NBR_ROM_MAX:			.byte		1		; Nombre de ROM maximal supporte (lu depuis l'EEPROM)
D:0001ca    G_DS18B20_ALR_ROM_IDX_WRK:			.byte		1		; Index dans la table des ROM a rechercher / trouve
         
         ; Reservation pour 2 capteurs en alarme dans la version "minimaliste"
         ; => Sinon reservation pour 4 capteurs en alarme
D:0001cb    G_DS18B20_ALR_ROM_0:					.byte		(DS18B20_NBR_ROM_TO_DETECT * 8)	; Reservation pour 'DS18B20_NBR_ROM_TO_DETECT' ALR
         
         ; Zone de travail
D:0001eb    G_DS18B20_WORK:						.byte		(DS18B20_NBR_ROM_TO_DETECT * 8)	; Non utilise directement
         
         ; Reservation de 1 byte pour accueillir le CRC8-MAXIM de l'ensemble de la trame
         ; Warning: 7 bytes seront concatenes a la trame:
         ;          - Index et type de la platine (2 bytes)
         ;          - Numero de la trame emise par cette platine (2 bytes)
         ;          - Timestamp en Sec. de l'emission de la trame complete (3 bytes)
         ;          - Nombre de capteurs (1 byte)
         ;
          #define	G_FRAME_ALL_INFOS			G_DS18B20_ALR_ROM_0
         
         ; Reservation pour 'DS18B20_NBR_ROM_TO_DETECT' capteurs (ALR)
          #define	G_DS18B20_FRAME_0			(G_DS18B20_ALR_ROM_0 + 1)
         
         ; End of file
         
          
         
          .cseg
         
         ; Definitions de la table de vecteurs de "prolongation" des 5 traitements:
         ; geres par uOS qui passe la main aux methodes specifiques a l'ADDON
         ; - #0: Initialisation materielle et logicielle (prolongation du 'setup' de uOS)
         ; - #1: Traitements en fond de tache
         ; - #2: Traitements toutes les 1 mS
         ; - #3: Traitements des nouvelles commandes non supportees par uOS
         ; - #4: Traitements associes a l'appui bouton avant ceux effectues par uOS
         ;
         ; => Toujours definir les 5 adresses avec un 'rjmp' ou un 'ret'
         ;    si pas de "prolongation" des traitements
         ;
         ; => Le nommage est libre et non utilise par uOS
         ;    => Seul le rang du traitement est impose dans l'ordre defini plus haut
         
          ds18b20_setup:
         	; Initialisation et armocage des prises des mesures et de l'emission de la trame
C:000743 c004      	rjmp		ds18b20_begin
         
          ds18b20_background:
         	; Aucun traitement en fond de tache
C:000744 9508      	ret
         
          ds18b20_1_ms:
         	; Aucun traitement toutes les 1 mS
C:000745 9508      	ret
         
          ds18b20_commands:
          #ifndef USE_MINIMALIST_ADDONS
         	; Execution des commandes "<C" et "<T"
C:000746 c342      	rjmp		exec_command_ds18b20	
          #else
          #endif
         
          ds18b20_button:
          #ifndef USE_MINIMALIST_ADDONS
         	; Traitements associes a l'appui bouton avant ceux effectues par uOS
C:000747 c436      	rjmp		exec_button_ds18b20	
          #else
          #endif
         
         ; Fin: Definitions de la table de vecteurs de "prolongation" des traitements
         
         ; ---------
         ; Initialisation contextes
         ; ---------
          ds18b20_begin:
         	; Prompt d'accueil
C:000748 e1f4      	ldi		REG_Z_MSB, ((text_prompt_ds18b20 << 1) / 256)
C:000749 e9e6      	ldi		REG_Z_LSB, ((text_prompt_ds18b20 << 1) % 256)
C:00074a dc48      	rcall		uos_push_text_in_fifo_tx
         
C:00074b d002      	rcall		ds18b20_init	; Duree de cadencement lue de l'EEPROM @ Id Platine
C:00074c d031      	rcall		ds18b20_exec	; 1st appel a l'initialisation
         
C:00074d 9508      	ret
         ; ---------
         
         ; ---------
         ; Preparation du code a exporter dans le fichier 'DS18B20.asm' inclus dans le projet
         ; - Recherche sur le bus des ROMs a concurence de 8 maximum
         ; - Conversion pour la detection de depassement des seuils d'alarme Tl et Th
         ;   et pour prise des temperatures Tc
         ; - Recherche des ROMs en alarme @ aus seuils Tl et Th
         ; - Prise des temperatures Tc
         ; - Emission de la trame constituee des parties:
         ;   - Header
         ;   - Informations pour chaque capteur trouve
         ;   - CRC8 de la trame complete
         ; ---------
          ds18b20_init:
         	; Lecture du nombre premier associe a l'Id de la platine
         	; pour une emission de la trame a un temps fonction de l'Id
C:00074e e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_PRIMES);
C:00074f e1a0      	ldi		REG_X_LSB, low(EEPROM_ADDR_PRIMES);
C:000750 9100 0167 	lds		REG_TEMP_R16, G_HEADER_INDEX_PLATINE
C:000752 700f      	andi		REG_TEMP_R16, 0x0f
C:000753 0fa0      	add		REG_X_LSB, REG_TEMP_R16
C:000754 2700      	clr		REG_TEMP_R16
C:000755 1fb0      	adc		REG_X_MSB, REG_TEMP_R16
         
C:000756 dc7c      	rcall		eeprom_read_byte
         
         	; Test si valeur incorrecte (0x00 ou 0xff)
         	; => Pas de maj de 'G_DS18B20_COUNTER_xxx'
         	;    => En consequence, pas de cadencement ;-)
C:000757 2300      	tst		REG_TEMP_R16
C:000758 f121      	breq		ds18b20_init_end
         
C:000759 3f0f      	cpi		REG_TEMP_R16, 0xff
C:00075a f111      	breq		ds18b20_init_end
         	; Fin: Test si valeur incorrecte (0x00 ou 0xff)
         
C:00075b 9300 019b 	sts		G_DS18B20_COUNTER_INIT, REG_TEMP_R16
         
         	; Amorce avec une 2nd lecture des DS18B20 au bout de 5 Sec
         	; car la 1st retourne la valeur par defaut cad 85 degrees
         	; => Les suivantes se feront au rithme de 'G_DS18B20_COUNTER_INIT' Sec. ;-)
C:00075d e015      	ldi		REG_TEMP_R17, 5
C:00075e 9310 019a 	sts		G_DS18B20_COUNTER, REG_TEMP_R17
         
         	; Traces de developpement
         	; Exemple:
         	; -e-
         	; [0x00][0x05] -> [Id] Platine][G_DS18B20_COUNTER_INIT]
         	; => 'G_DS18B20_COUNTER_INIT' lu de l'eeprom
         
C:000760 e615      	ldi		REG_TEMP_R17, 'e'
C:000761 dfa7      	rcall		uos_print_mark_skip
C:000762 91a0 0167 	lds		REG_X_LSB, G_HEADER_INDEX_PLATINE
C:000764 df86      	rcall		uos_print_1_byte_hexa
C:000765 91a0 019b 	lds		REG_X_LSB, G_DS18B20_COUNTER_INIT
C:000767 df83      	rcall		uos_print_1_byte_hexa
         	; Fin: Traces de developpement
         
         	; Armement timer 'DS18B20_TIMER_1_SEC' pour les mesures de temperatures
         	; et le cadencement des emissions des trames...
C:000768 e01f      	ldi      REG_TEMP_R17, DS18B20_TIMER_1_SEC
C:000769 ee28      	ldi      REG_TEMP_R18, (1000 % 256)
C:00076a e033      	ldi      REG_TEMP_R19, (1000 / 256)
C:00076b e645      	ldi      REG_TEMP_R20, low(exec_timer_ds18b20)
C:00076c e05a      	ldi      REG_TEMP_R21, high(exec_timer_ds18b20)
C:00076d daf6      	rcall    start_timer
         
         	; Lecture depuis l'EEPROM du nombre de DS18B20 a detecter et a gerer
         	;       => Valeur a tester dan la plage [1, 2, ..., DS18B20_NBR_ROM_TO_DETECT]
         	;          => Sinon forcer a 1 capteur a detecter
C:00076e e004      	ldi		REG_TEMP_R16, DS18B20_NBR_ROM_TO_DETECT
         
C:00076f e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_NBR_DS18B20_TO_DETECT);
C:000770 e0af      	ldi		REG_X_LSB, low(EEPROM_ADDR_NBR_DS18B20_TO_DETECT);
         
C:000771 dc61      	rcall		eeprom_read_byte
         
         	; Test dans la plage [1, 2, ..., DS18B20_NBR_ROM_TO_DETECT]
C:000772 2300      	tst		REG_TEMP_R16
C:000773 f011      	breq		ds18b20_init_force_nbr_detect							; Si valeur 0 lue -> Pas de test dans la plage -> forcage
         
C:000774 3005      	cpi		REG_TEMP_R16, (DS18B20_NBR_ROM_TO_DETECT + 1)	; Test dans la plage [1, ..., DS18B20_NBR_ROM_TO_DETECT]
C:000775 f008      	brlo		ds18b20_init_cont_d
         
          ds18b20_init_force_nbr_detect:
C:000776 e001      	ldi		REG_TEMP_R16, 1											; 1 DS18B20 a detecter si pas dans la plage
         
          ds18b20_init_cont_d:
C:000777 9300 01a1 	sts		G_DS18B20_NBR_ROM_MAX, REG_TEMP_R16
         	; Fin: Lecture depuis l'EEPROM du nombre de DS18B20 a detecter et a gerer
         
         	; Traces de developpement
C:000779 91a0 01a1 	lds		REG_X_LSB, G_DS18B20_NBR_ROM_MAX
C:00077b df6f      	rcall		uos_print_1_byte_hexa
C:00077c df64      	rcall		uos_print_line_feed
         	; Fin: Traces de developpement
         
          ds18b20_init_end:
C:00077d 9508      	ret
         ; ---------
         
         ; ---------
         ; Realise les fonctionnements:
         ; - Recherche sur le bus des ROMs
         ; - 1st pass: Conversion des temperatures + Recherche des capteurs en alarme
         ; - 2nd pass: Prise des temperatures
         ; - Emission de la trame complete...
         ; ---------
          ds18b20_exec:
         	; Autorisation traces si 'G_DS18B20_FLAGS<FLG_DS18B20_TRACE>' a 1
C:00077e 9100 0168 	lds		REG_TEMP_R16, G_DS18B20_FLAGS
C:000780 ff03      	sbrs		REG_TEMP_R16, FLG_DS18B20_TRACE_IDX
C:000781 6280      	sbr		REG_FLAGS_0, FLG_0_PRINT_SKIP_MSK
         
         	; Recherche sur le bus des ROMs
          #ifndef USE_MINIMALIST_ADDONS
C:000782 e713      	ldi		REG_TEMP_R17, 's'
C:000783 df85      	rcall		uos_print_mark_skip
          #endif
         
C:000784 d483      	rcall		ds18b20_search_rom
         	; Fin: Recherche sur le bus des ROMs
         
         	; 1st pass: Conversion des temperatures + Recherche des capteurs en alarme
         	; 2nd pass: Prise des temperatures
C:000785 2711      	clr		REG_TEMP_R17
C:000786 6011      	sbr		REG_TEMP_R17, FLG_DS18B20_CONV_T_MSK
C:000787 7f1d      	cbr		REG_TEMP_R17, FLG_DS18B20_TEMP_MSK
C:000788 6014      	sbr		REG_TEMP_R17, FLG_DS18B20_FRAMES_MSK
C:000789 9310 0197 	sts		G_BUS_1_WIRE_FLAGS, REG_TEMP_R17
         
          ds18b20_exec_pass:
         	; Conversion pour chaque ROM detecte #N [0, 1, 2, etc.]
C:00078b 2700      	clr		REG_TEMP_R16
         
          ds18b20_exec_loop:
         	; Recuperation du ROM #N detecte
C:00078c d19d      	rcall		ds18b20_get_rom_detected_bypass	
C:00078d f506      	brtc		ds18b20_exec_conversion_end
         
C:00078e 930f      	push		REG_TEMP_R16			; Sauvegarde #N
         
         	; Reset capteur #N
          #ifndef USE_MINIMALIST_ADDONS
C:00078f e712      	ldi		REG_TEMP_R17, 'r'
C:000790 df78      	rcall		uos_print_mark_skip
          #endif
         
C:000791 d058      	rcall		ds18b20_reset
         
         	; Copy ROM @ 'REG_TEMP_R17' into 'G_DS18B20_BYTES_SEND'
C:000792 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_SEND)
C:000793 e6cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_SEND)
C:000794 e018      	ldi		REG_TEMP_R17, DS18B20_NBR_ROM_GESTION
         
          ds18b20_exec_loop_2:
C:000795 912d      	ld			REG_TEMP_R18, X+
C:000796 9329      	st			Y+, REG_TEMP_R18
C:000797 951a      	dec		REG_TEMP_R17
C:000798 f7e1      	brne		ds18b20_exec_loop_2
         	; End: Copy ROM @ 'REG_TEMP_R17' into 'G_DS18B20_BYTES_SEND'
         
          #ifndef USE_MINIMALIST_ADDONS
C:000799 e61d      	ldi		REG_TEMP_R17, 'm'
C:00079a df6e      	rcall		uos_print_mark_skip
          #endif
         
C:00079b d440      	rcall		ds18b20_match_rom
         
C:00079c 9110 0197 	lds		REG_TEMP_R17, G_BUS_1_WIRE_FLAGS
C:00079e fd10      	sbrc		REG_TEMP_R17, FLG_DS18B20_CONV_T_IDX
C:00079f c003      	rjmp		ds18b20_conversion
         
C:0007a0 fd11      	sbrc		REG_TEMP_R17, FLG_DS18B20_TEMP_IDX
C:0007a1 c005      	rjmp		ds18b20_temp
         
C:0007a2 c007      	rjmp		ds18b20_exec_cont_d
         
          ds18b20_conversion:
          #ifndef USE_MINIMALIST_ADDONS
C:0007a3 e613      	ldi		REG_TEMP_R17, 'c'
C:0007a4 df64      	rcall		uos_print_mark_skip
          #endif
         
C:0007a5 d3ff      	rcall		ds18b20_convert_t
C:0007a6 c003      	rjmp		ds18b20_exec_cont_d
         
          ds18b20_temp:
          #ifndef USE_MINIMALIST_ADDONS
C:0007a7 e714      	ldi		REG_TEMP_R17, 't'
C:0007a8 df60      	rcall		uos_print_mark_skip
          #endif
         
C:0007a9 d406      	rcall		ds18b20_read_scratchpad
         
          ds18b20_exec_cont_d:
C:0007aa dc12      	rcall		fifo_tx_to_send_sync
         
C:0007ab 910f      	pop		REG_TEMP_R16			; Restauration #N
C:0007ac 9503      	inc		REG_TEMP_R16			; #N suivant
C:0007ad cfde      	rjmp		ds18b20_exec_loop
         	; Fin: Conversion pour chaque ROM detecte
         
          ds18b20_exec_conversion_end:
         	; Test si tous les 'G_DS18B20_NBR_ROM_FOUND' ont ete balayes
C:0007ae 9110 01a0 	lds		REG_TEMP_R17, G_DS18B20_NBR_ROM_FOUND
C:0007b0 2311      	tst		REG_TEMP_R17
C:0007b1 f099      	breq		ds18b20_exec_build_frame		; Construction de la trame a emettre
         
C:0007b2 1301      	cpse		REG_TEMP_R16, REG_TEMP_R17		; Fin si erreur de comparaison
C:0007b3 c01d      	rjmp		ds18b20_exec_end
         
         	; Recherche des capteurs en alarme si fin de la conversion
C:0007b4 9110 0197 	lds		REG_TEMP_R17, G_BUS_1_WIRE_FLAGS
C:0007b6 fd10      	sbrc		REG_TEMP_R17, FLG_DS18B20_CONV_T_IDX
         
C:0007b7 c004      	rjmp		ds18b20_exec_search_alarm
         
C:0007b8 7f1d      	cbr		REG_TEMP_R17, FLG_DS18B20_TEMP_MSK
C:0007b9 9310 0197 	sts		G_BUS_1_WIRE_FLAGS, REG_TEMP_R17
         
C:0007bb c009      	rjmp		ds18b20_exec_build_frame
         
          ds18b20_exec_search_alarm:
C:0007bc 7f1e      	cbr		REG_TEMP_R17, FLG_DS18B20_CONV_T_MSK
C:0007bd 6012      	sbr		REG_TEMP_R17, FLG_DS18B20_TEMP_MSK
C:0007be 9310 0197 	sts		G_BUS_1_WIRE_FLAGS, REG_TEMP_R17
         
          #ifndef USE_MINIMALIST_ADDONS
C:0007c0 e611      	ldi		REG_TEMP_R17, 'a'
C:0007c1 df47      	rcall		uos_print_mark_skip
          #endif
         
C:0007c2 d4e5      	rcall		ds18b20_search_alarm
         ;#endif
         
         	; Effacement des emplacements 'G_DS18B20_ALR_ROM_N' pour accueillir les trames
C:0007c3 d0c4      	rcall		ds18b20_clear_alr
         
C:0007c4 cfc6      	rjmp		ds18b20_exec_pass
         
          ds18b20_exec_build_frame:
          #ifndef USE_MINIMALIST_ADDONS
C:0007c5 e616      	ldi		REG_TEMP_R17, 'f'
C:0007c6 df42      	rcall		uos_print_mark_skip
          #endif
         
         	; Complements d'informations de la trame complete a emettre
C:0007c7 d1fd      	rcall		buid_frame_complement
         
         	; Preparation prochaine emission
C:0007c8 91d0 0169 	lds		REG_Y_MSB, G_HEADER_NUM_FRAME_MSB
C:0007ca 91c0 016a 	lds		REG_Y_LSB, G_HEADER_NUM_FRAME_LSB
C:0007cc 9621      	adiw		REG_Y_LSB, 1
C:0007cd 93d0 0169 	sts		G_HEADER_NUM_FRAME_MSB, REG_Y_MSB
C:0007cf 93c0 016a 	sts		G_HEADER_NUM_FRAME_LSB, REG_Y_LSB
         
          ds18b20_exec_end:
         	; Reactivation trace
C:0007d1 7d8f      	cbr		REG_FLAGS_0, FLG_0_PRINT_SKIP_MSK
         
         	; Emission de la trame complete
C:0007d2 d234      	rcall		ds18b20_send_frame
         
C:0007d3 9508      	ret
         ; ---------
         
         ; ---------
         ; Raz des 16 bytes [G_DS18B20_BYTES_RESP, ..., (G_DS18B20_BYTES_RESP + 15)]
         ;  et des 16 bytes [G_DS18B20_BYTES_SEND, ..., (G_DS18B20_BYTES_SEND + 15)]
         ; ---------
          ds18b20_clear:
         ; ---------
C:0007d4 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_RESP)
C:0007d5 e7cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_RESP)
C:0007d6 e120      	ldi		REG_TEMP_R18, 16
C:0007d7 2700      	clr		REG_TEMP_R16
         
          ds18b20_clear_loop:
C:0007d8 9309      	st			Y+, REG_TEMP_R16
C:0007d9 952a      	dec		REG_TEMP_R18
C:0007da f7e9      	brne		ds18b20_clear_loop
         
C:0007db e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_SEND)
C:0007dc e6cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_SEND)
C:0007dd e120      	ldi		REG_TEMP_R18, 16
C:0007de 2700      	clr		REG_TEMP_R16
         
          ds18b20_clear_loop_2:
C:0007df 9309      	st			Y+, REG_TEMP_R16
C:0007e0 952a      	dec		REG_TEMP_R18
C:0007e1 f7e9      	brne		ds18b20_clear_loop_2
         
C:0007e2 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)
C:0007e3 e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
C:0007e4 e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
C:0007e5 2700      	clr		REG_TEMP_R16
         
          ds18b20_clear_loop_3:
C:0007e6 9309      	st			Y+, REG_TEMP_R16
C:0007e7 952a      	dec		REG_TEMP_R18
C:0007e8 f7e9      	brne		ds18b20_clear_loop_3
         
C:0007e9 9508      	ret
         ; ---------
         
         ; ---------
         ; ds18b20_reset: Generation de la pulse RESET --\__/---- de 1mS
         ; ---------
         ; La norme specifie > 480uS
         ;
         ; Remarque: L'execution est ininterruptible
         ;           => TODO: Amelioration peut eviter d'etre "sourd" sur la recpetion Rx
         ; ---------
          ds18b20_reset:
C:0007ea dfe9      	rcall		ds18b20_clear							; Raz des zone d'emission et reception
         
C:0007eb 94f8      	cli
         
C:0007ec 9ac3      	sbi		PORTB, IDX_BIT_LED_GREEN			; Extinction Led GREEN
C:0007ed 98c2      	cbi		PORTB, IDX_BIT_1_WIRE
         
C:0007ee e011      	ldi		REG_TEMP_R17, 1						; Spare for awaiting > 255mS
         
          ds18b20_reset_loop_1:
C:0007ef e604      	ldi		REG_TEMP_R16, 100						; Wait 1mS
         
          ds18b20_reset_loop_2:
C:0007f0 d8e8      	rcall		uos_delay_10uS
C:0007f1 950a      	dec		REG_TEMP_R16
C:0007f2 f7e9      	brne		ds18b20_reset_loop_2
         
C:0007f3 951a      	dec		REG_TEMP_R17
C:0007f4 f7d1      	brne		ds18b20_reset_loop_1
         
C:0007f5 9ac2      	sbi		PORTB, IDX_BIT_1_WIRE
         
         	; Presence detect ?
C:0007f6 98ba      	cbi		DDRB, IDX_BIT_1_WIRE					; <PORTB<2> en entree
C:0007f7 d36f      	rcall		delay_65uS
         
C:0007f8 e310      	ldi		REG_TEMP_R17, '0'
C:0007f9 99b2      	sbic		PINB, IDX_BIT_1_WIRE
C:0007fa e311      	ldi		REG_TEMP_R17, '1'						; ... et non <PORTB<2> a 1
         
C:0007fb e624      	ldi		REG_TEMP_R18, 100						; Wait 1mS
         
          ds18b20_reset_loop_3:
C:0007fc d8dc      	rcall		uos_delay_10uS
C:0007fd 952a      	dec		REG_TEMP_R18
C:0007fe f7e9      	brne		ds18b20_reset_loop_3
         
C:0007ff 9aba      	sbi		DDRB, IDX_BIT_1_WIRE					; <PORTB<2> en sortie
         
          #ifndef USE_MINIMALIST_ADDONS
C:000800 e500      	ldi		REG_TEMP_R16, 'P'
C:000801 db9e      	rcall		push_1_char_in_fifo_tx_skip
         	
C:000802 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:000803 db9c      	rcall		push_1_char_in_fifo_tx_skip
C:000804 deda      	rcall		uos_print_line_feed_skip
          #endif
         	; End: Presence detect ?
         
C:000805 9478      	sei
C:000806 9508      	ret
         ; ---------
         
          #ifndef USE_MINIMALIST_ADDONS
         ; ---------
          ds18b20_print_response:
C:000807 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_RESP)
C:000808 e7cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_RESP)
         
          ds18b20_print_response_loop:
C:000809 91b9      	ld			REG_X_MSB, Y+
C:00080a 91a9      	ld			REG_X_LSB, Y+
C:00080b deec      	rcall		uos_print_2_bytes_hexa_skip
         
C:00080c 952a      	dec		REG_TEMP_R18
C:00080d f7d9      	brne		ds18b20_print_response_loop
         
C:00080e ded0      	rcall		uos_print_line_feed_skip
C:00080f 9508      	ret
         ; ---------
         
         ; ---------
          ds18b20_print_rom_send:
C:000810 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_SEND)
C:000811 e6cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_SEND)
         
C:000812 e024      	ldi		REG_TEMP_R18, 4
         
          ds18b20_print_rom_send_loop:
C:000813 91b9      	ld			REG_X_MSB, Y+
C:000814 91a9      	ld			REG_X_LSB, Y+
C:000815 dee2      	rcall		uos_print_2_bytes_hexa_skip
         
C:000816 952a      	dec		REG_TEMP_R18
C:000817 f7d9      	brne		ds18b20_print_rom_send_loop
         
C:000818 dec6      	rcall		uos_print_line_feed_skip
         
C:000819 9508      	ret
         ; ---------
         
         ; ---------
          ds18b20_print_rom:
C:00081a e502      	ldi		REG_TEMP_R16, 'R'
C:00081b db84      	rcall		push_1_char_in_fifo_tx_skip
         
C:00081c e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)
C:00081d e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
         
C:00081e e024      	ldi		REG_TEMP_R18, 4
         
          ds18b20_print_rom_loop:
C:00081f 91b9      	ld			REG_X_MSB, Y+
C:000820 91a9      	ld			REG_X_LSB, Y+
C:000821 ded6      	rcall		uos_print_2_bytes_hexa_skip
         
C:000822 952a      	dec		REG_TEMP_R18
C:000823 f7d9      	brne		ds18b20_print_rom_loop
         
C:000824 deba      	rcall		uos_print_line_feed_skip
         
C:000825 9508      	ret
         ; ---------
          #endif
         
         ; ---------
         ; Clear of ROM table in 'G_DS18B20_BYTES_ROM' to 'G_DS18B20_ROM_0', ...
         ; ---------
          ds18b20_clear_rom:
C:000826 e0f1      	ldi		REG_Z_MSB, high(G_DS18B20_ROM_0)
C:000827 eae4      	ldi		REG_Z_LSB, low(G_DS18B20_ROM_0)
         
         	; Remarque: Pour un marquage d'utilisation 'ldi REG_TEMP_R16, 0xA5'
         	;           => Ne doit pas apparaitre en SRAM ;-)
C:000828 2700      	clr		REG_TEMP_R16
         
         	; Balayage des 'DS18B20_NBR_ROM_TO_DETECT' x 8 bytes des ROM a rechercher
C:000829 e220      	ldi		REG_TEMP_R18, (DS18B20_NBR_ROM_TO_DETECT * 8)
         
          ds18b20_clear_rom_loop:
C:00082a 9301      	st			Z+, REG_TEMP_R16
         
C:00082b 952a      	dec		REG_TEMP_R18
C:00082c f7e9      	brne		ds18b20_clear_rom_loop
         
C:00082d 9508      	ret
         ; ---------
         
         ; ---------
         ; Copy of ROM found in 'G_DS18B20_BYTES_ROM' to 'G_DS18B20_ROM_0' @ 'G_DS18B20_ROM_IDX'
         ; ---------
          ds18b20_copy_rom:
C:00082e e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)
C:00082f e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
         
C:000830 9100 01a2 	lds		REG_TEMP_R16, G_DS18B20_ROM_IDX_WRK
C:000832 e0f1      	ldi		REG_Z_MSB, high(G_DS18B20_ROM_0)
C:000833 eae4      	ldi		REG_Z_LSB, low(G_DS18B20_ROM_0)
C:000834 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:000835 2711      	clr		REG_TEMP_R17
C:000836 1ff1      	adc		REG_Z_MSB, REG_TEMP_R17
         
         	; Preparation prochaine copie
C:000837 e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
C:000838 0f02      	add		REG_TEMP_R16, REG_TEMP_R18
C:000839 9300 01a2 	sts		G_DS18B20_ROM_IDX_WRK, REG_TEMP_R16
         
          ds18b20_copy_rom_loop:
C:00083b 9109      	ld			REG_TEMP_R16, Y+
C:00083c 9301      	st			Z+, REG_TEMP_R16
         
C:00083d 952a      	dec		REG_TEMP_R18
C:00083e f7e1      	brne		ds18b20_copy_rom_loop
         
C:00083f 9508      	ret
         ; ---------
         
         ; ---------
         ; Compare of ROM found in 'G_DS18B20_BYTES_ROM' with all from ['G_DS18B20_ROM_0', ..., 'G_DS18B20_ROM_7']
         ;
         ; Remarque: Seul le test du CRC8 est effectue
         ;           On suppose qu'il n'y pas 2 ROM differents avec le meme CRC8 valide
         ;
         ; => Retour:
         ;    - 0xff si "Non trouve"
         ;    - L'index [0, 8, 16, ...] si "trouve"
         ; ---------
          ds18b20_compare_rom:
C:000840 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_ROM_0)
C:000841 eac4      	ldi		REG_Y_LSB, low(G_DS18B20_ROM_0)
         
C:000842 ef08      	ldi		REG_TEMP_R16, -8		; Index du CRC du n-ieme ROM (0, 8, 16, etc.)
         
          ds18b20_compare_rom_loop:
C:000843 5f08      	subi		REG_TEMP_R16, -8		; 'REG_TEMP_R16' += 8
         
         	; Reinit 'Y' car 'REG_TEMP_R16' l'adresse a tester est ('Y' + 'REG_TEMP_R16')
C:000844 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_ROM_0)
C:000845 eac4      	ldi		REG_Y_LSB, low(G_DS18B20_ROM_0)
         
C:000846 0fc0      	add		REG_Y_LSB, REG_TEMP_R16
C:000847 2711      	clr		REG_TEMP_R17
C:000848 1fd1      	adc		REG_Y_MSB, REG_TEMP_R17
         
C:000849 9120 0196 	lds		REG_TEMP_R18, (G_DS18B20_BYTES_ROM + 7)
C:00084b 813f      	ldd		REG_TEMP_R19, Y+7
C:00084c 1323      	cpse		REG_TEMP_R18, REG_TEMP_R19			; Famille differente ?
C:00084d c012      	rjmp		ds18b20_compare_rom_not_found		; Non
         
C:00084e 9320 0199 	sts		G_DS18B20_FAMILLE, REG_TEMP_R18	; Update for build frame
         
C:000850 9120 018f 	lds		REG_TEMP_R18, G_DS18B20_BYTES_ROM
C:000852 8138      	ld			REG_TEMP_R19, Y
C:000853 1323      	cpse		REG_TEMP_R18, REG_TEMP_R19			; CRC different ?
C:000854 c00b      	rjmp		ds18b20_compare_rom_not_found		; Non
         
          ds18b20_compare_rom_found:
C:000855 930f      	push		REG_TEMP_R16
C:000856 2fa0      	mov		REG_X_LSB, REG_TEMP_R16
C:000857 de91      	rcall		uos_print_1_byte_hexa_skip
         
C:000858 2fbd      	mov		REG_X_MSB, REG_Y_MSB
C:000859 2fac      	mov		REG_X_LSB, REG_Y_LSB
C:00085a de9d      	rcall		uos_print_2_bytes_hexa_skip
         
          #ifndef USE_MINIMALIST_ADDONS
C:00085b e406      	ldi		REG_TEMP_R16, 'F'
C:00085c db43      	rcall		push_1_char_in_fifo_tx_skip
C:00085d de81      	rcall		uos_print_line_feed_skip
          #endif
         
C:00085e 910f      	pop		REG_TEMP_R16
         
C:00085f c027      	rjmp		ds18b20_compare_rom_ret
         
          ds18b20_compare_rom_not_found:
         	; Test du CRC8 pour un nouveau ROM non trouve
C:000860 930f      	push		REG_TEMP_R16
C:000861 93df      	push		REG_Y_MSB
C:000862 93cf      	push		REG_Y_LSB
C:000863 e008      	ldi		REG_TEMP_R16, NBR_BITS_TO_SHIFT			; 8 bytes pour le calcul sur les ROM
C:000864 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)	; Adresse de 'G_DS18B20_BYTES_ROM'
C:000865 e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
         
C:000866 94e8      	clt															; Test du CRC8 avec non prise en compte du 1st byte
C:000867 d086      	rcall		ds18b20_crc8_bypass
         
C:000868 9468      	set															; A priori, CRC8 recu egal a celui attendu ...
C:000869 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
C:00086b 9110 018f 	lds		REG_TEMP_R17, G_DS18B20_BYTES_ROM
C:00086d 1301      	cpse		REG_TEMP_R16, REG_TEMP_R17
C:00086e 94e8      	clt															; ... et non CRC8 recu different de celui attendu
         
C:00086f 91cf      	pop		REG_Y_LSB
C:000870 91df      	pop		REG_Y_MSB
C:000871 910f      	pop		REG_TEMP_R16
         
C:000872 f02e      	brts		ds18b20_compare_rom_crc8_ok		; CRC8 calcule et egal a celui recu ?
         
          ds18b20_compare_rom_crc8_ko:						; Non
          #ifndef USE_MINIMALIST_ADDONS
C:000873 e40b      	ldi		REG_TEMP_R16, 'K'
C:000874 db2b      	rcall		push_1_char_in_fifo_tx_skip
C:000875 de69      	rcall		uos_print_line_feed_skip
          #endif
         
C:000876 e000      	ldi		REG_TEMP_R16, 0						; Force a ROM trouve (retour avec 'REG_TEMP_R16' != 0 ;-)
C:000877 c00f      	rjmp		ds18b20_compare_rom_ret
         
          ds18b20_compare_rom_crc8_ok:						; Oui
         	; Fin: Test du CRC8 pour un nouveau ROM non trouve
         
          ds18b20_compare_rom_not_found_save:
         
          #ifndef USE_MINIMALIST_ADDONS
C:000878 930f      	push		REG_TEMP_R16
C:000879 2fbd      	mov		REG_X_MSB, REG_Y_MSB
C:00087a 2fac      	mov		REG_X_LSB, REG_Y_LSB
C:00087b de7c      	rcall		uos_print_2_bytes_hexa_skip
         
C:00087c e606      	ldi		REG_TEMP_R16, 'f'
C:00087d db22      	rcall		push_1_char_in_fifo_tx_skip
C:00087e de60      	rcall		uos_print_line_feed_skip
C:00087f 910f      	pop		REG_TEMP_R16
          #endif
         
         	; Test de depassement de l'index 'REG_TEMP_R16'
C:000880 9110 01a2 	lds		REG_TEMP_R17, G_DS18B20_ROM_IDX_WRK
C:000882 1701      	cp			REG_TEMP_R16, REG_TEMP_R17
C:000883 f00a      	brmi		ds18b20_compare_rom_loop_cont_d
C:000884 c001      	rjmp		ds18b20_compare_rom_loop_end
         
          ds18b20_compare_rom_loop_cont_d:
C:000885 cfbd      	rjmp		ds18b20_compare_rom_loop
         
          ds18b20_compare_rom_loop_end:
C:000886 ef0f      	ldi		REG_TEMP_R16, 0xff
         
          ds18b20_compare_rom_ret:
C:000887 9508      	ret
         ; ---------
         
         ; ---------
         ; Gestion des alarmes
         ; ---------
         ; ds18b20_clear_alr:
         ; ds18b20_alr_copy_rom:
         ; ds18b20_compare_alr_rom:
         ; ds18b20_search_alarm:    Recherche des capteurs en "alarme"
         ; ---------
         ; Clear of ROM table 'G_DS18B20_ALR_ROM_0', ...
         ; ---------
          ds18b20_clear_alr:
C:000888 e0f1      	ldi		REG_Z_MSB, high(G_DS18B20_ALR_ROM_0)
C:000889 eceb      	ldi		REG_Z_LSB, low(G_DS18B20_ALR_ROM_0)
         
         	; Remarque: Pour un marquage d'utilisation 'ldi REG_TEMP_R16, 0xA6'
         	;           => Ne doit pas apparaitre en SRAM ;-)
C:00088a 2700      	clr		REG_TEMP_R16
         
         	; Balayage des 'DS18B20_NBR_ROM_TO_DETECT' x 8 bytes des ROM a rechercher
C:00088b e220      	ldi		REG_TEMP_R18, (DS18B20_NBR_ROM_TO_DETECT * 8)
         
          ds18b20_clear_alr_loop:
C:00088c 9301      	st			Z+, REG_TEMP_R16
         
C:00088d 952a      	dec		REG_TEMP_R18
C:00088e f7e9      	brne		ds18b20_clear_alr_loop
         
C:00088f 9508      	ret
         ; ---------
         
         ; ---------
         ; Copy of ROM found in 'G_DS18B20_BYTES_ROM' to 'G_DS18B20_ALR_ROM_0' @ 'G_DS18B20_ALR_ROM_IDX'
         ; => Code identique a 'ds18b20_copy_rom' sur les variables 'G_DS18B20_ALR_ROM_X'
         ;    a la place de 'G_DS18B20_XXX'
         ; ---------
          ds18b20_alr_copy_rom:
C:000890 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)
C:000891 e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
         
C:000892 9100 01ca 	lds		REG_TEMP_R16, G_DS18B20_ALR_ROM_IDX_WRK
C:000894 e0f1      	ldi		REG_Z_MSB, high(G_DS18B20_ALR_ROM_0)
C:000895 eceb      	ldi		REG_Z_LSB, low(G_DS18B20_ALR_ROM_0)
C:000896 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:000897 2711      	clr		REG_TEMP_R17
C:000898 1ff1      	adc		REG_Z_MSB, REG_TEMP_R17
         
         	; Preparation prochaine copie
C:000899 e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
C:00089a 0f02      	add		REG_TEMP_R16, REG_TEMP_R18
C:00089b 9300 01ca 	sts		G_DS18B20_ALR_ROM_IDX_WRK, REG_TEMP_R16
         
          ds18b20_alr_copy_rom_loop:
C:00089d 9109      	ld			REG_TEMP_R16, Y+
C:00089e 9301      	st			Z+, REG_TEMP_R16
         
C:00089f 952a      	dec		REG_TEMP_R18
C:0008a0 f7e1      	brne		ds18b20_alr_copy_rom_loop
         
C:0008a1 9508      	ret
         ; ---------
         
         ; ---------
         ; Compare of ROM found in 'G_DS18B20_BYTES_ROM' with all from ['G_DS18B20_ALR_ROM_0', ..., 'G_DS18B20_ALR_ROM_7']
         ;
         ; Remarque: Seul le test du CRC8 est effectue 
         ;           On suppose qu'il n'y pas 2 ROM differents avec le meme CRC8 valide
         ;
         ; => Retour:
         ;    - 0xff si "Non trouve"
         ;    - L'index [0, 8, 16, ...] si "trouve"
         ; ---------
          ds18b20_compare_alr_rom:
C:0008a2 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_ALR_ROM_0)
C:0008a3 eccb      	ldi		REG_Y_LSB, low(G_DS18B20_ALR_ROM_0)
         
C:0008a4 ef08      	ldi		REG_TEMP_R16, -8		; Index du CRC du n-ieme ROM (0, 8, 16, etc.)
         
          ds18b20_compare_alr_rom_loop:
C:0008a5 5f08      	subi		REG_TEMP_R16, -8		; 'REG_TEMP_R16' += 8
         
         	; Reinit 'Y' car 'REG_TEMP_R16' l'adresse a tester est ('Y' + 'REG_TEMP_R16')
C:0008a6 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_ALR_ROM_0)
C:0008a7 eccb      	ldi		REG_Y_LSB, low(G_DS18B20_ALR_ROM_0)
         
C:0008a8 0fc0      	add		REG_Y_LSB, REG_TEMP_R16
C:0008a9 2711      	clr		REG_TEMP_R17
C:0008aa 1fd1      	adc		REG_Y_MSB, REG_TEMP_R17
         
C:0008ab 9120 0196 	lds		REG_TEMP_R18, (G_DS18B20_BYTES_ROM + 7)
C:0008ad 813f      	ldd		REG_TEMP_R19, Y+7
C:0008ae 1323      	cpse		REG_TEMP_R18, REG_TEMP_R19			; Famille differente ?
C:0008af c010      	rjmp		ds18b20_compare_alr_rom_not_found		; Non
         
C:0008b0 9120 018f 	lds		REG_TEMP_R18, G_DS18B20_BYTES_ROM
C:0008b2 8138      	ld			REG_TEMP_R19, Y
C:0008b3 1323      	cpse		REG_TEMP_R18, REG_TEMP_R19			; CRC different ?
C:0008b4 c00b      	rjmp		ds18b20_compare_alr_rom_not_found		; Non
         
          ds18b20_compare_alr_rom_found:
         
          #ifndef USE_MINIMALIST_ADDONS
C:0008b5 930f      	push		REG_TEMP_R16
C:0008b6 2fa0      	mov		REG_X_LSB, REG_TEMP_R16
C:0008b7 de31      	rcall		uos_print_1_byte_hexa_skip
         
C:0008b8 2fbd      	mov		REG_X_MSB, REG_Y_MSB
C:0008b9 2fac      	mov		REG_X_LSB, REG_Y_LSB
C:0008ba de3d      	rcall		uos_print_2_bytes_hexa_skip
         
C:0008bb e406      	ldi		REG_TEMP_R16, 'F'
C:0008bc dae3      	rcall		push_1_char_in_fifo_tx_skip
C:0008bd de21      	rcall		uos_print_line_feed_skip
C:0008be 910f      	pop		REG_TEMP_R16
          #endif
         
C:0008bf c027      	rjmp		ds18b20_compare_alr_rom_ret
         
          ds18b20_compare_alr_rom_not_found:
         	; Test du CRC8 pour un nouveau ROM non trouve
C:0008c0 930f      	push		REG_TEMP_R16
C:0008c1 93df      	push		REG_Y_MSB
C:0008c2 93cf      	push		REG_Y_LSB
C:0008c3 e008      	ldi		REG_TEMP_R16, NBR_BITS_TO_SHIFT			; 8 bytes pour le calcul sur les ROM
C:0008c4 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)	; Adresse de 'G_DS18B20_BYTES_ROM'
C:0008c5 e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
         
C:0008c6 94e8      	clt															; Test du CRC8 avec non prise en compte du 1st byte
C:0008c7 d026      	rcall		ds18b20_crc8_bypass
         
C:0008c8 9468      	set															; A priori, CRC8 recu egal a celui attendu ...
C:0008c9 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
C:0008cb 9110 018f 	lds		REG_TEMP_R17, G_DS18B20_BYTES_ROM
C:0008cd 1301      	cpse		REG_TEMP_R16, REG_TEMP_R17
C:0008ce 94e8      	clt															; ... et non CRC8 recu different de celui attendu
         
C:0008cf 91cf      	pop		REG_Y_LSB
C:0008d0 91df      	pop		REG_Y_MSB
C:0008d1 910f      	pop		REG_TEMP_R16
         
C:0008d2 f02e      	brts		ds18b20_compare_alr_rom_crc8_ok		; CRC8 calcule et egal a celui recu ?
         
          ds18b20_compare_alr_rom_crc8_ko:						; Non
          #ifndef USE_MINIMALIST_ADDONS
C:0008d3 e40b      	ldi		REG_TEMP_R16, 'K'
C:0008d4 dacb      	rcall		push_1_char_in_fifo_tx_skip
C:0008d5 de09      	rcall		uos_print_line_feed_skip
          #endif
         
C:0008d6 e000      	ldi		REG_TEMP_R16, 0						; Force a ROM trouve (retour avec 'REG_TEMP_R16' != 0 ;-)
C:0008d7 c00f      	rjmp		ds18b20_compare_alr_rom_ret
         
          ds18b20_compare_alr_rom_crc8_ok:						; Oui
         	; Fin: Test du CRC8 pour un nouveau ROM non trouve
         
          ds18b20_compare_alr_rom_not_found_save:
         
          #ifndef USE_MINIMALIST_ADDONS
C:0008d8 930f      	push		REG_TEMP_R16
C:0008d9 2fbd      	mov		REG_X_MSB, REG_Y_MSB
C:0008da 2fac      	mov		REG_X_LSB, REG_Y_LSB
C:0008db de1c      	rcall		uos_print_2_bytes_hexa_skip
         
C:0008dc e606      	ldi		REG_TEMP_R16, 'f'
C:0008dd dac2      	rcall		push_1_char_in_fifo_tx_skip
C:0008de de00      	rcall		uos_print_line_feed_skip
C:0008df 910f      	pop		REG_TEMP_R16
          #endif
         
         	; Test de depassement de l'index 'REG_TEMP_R16'
C:0008e0 9110 01ca 	lds		REG_TEMP_R17, G_DS18B20_ALR_ROM_IDX_WRK
C:0008e2 1701      	cp			REG_TEMP_R16, REG_TEMP_R17
C:0008e3 f00a      	brmi		ds18b20_compare_alr_rom_loop_cont_d
C:0008e4 c001      	rjmp		ds18b20_compare_alr_rom_loop_end
         
          ds18b20_compare_alr_rom_loop_cont_d:
C:0008e5 cfbf      	rjmp		ds18b20_compare_alr_rom_loop
         
          ds18b20_compare_alr_rom_loop_end:
C:0008e6 ef0f      	ldi		REG_TEMP_R16, 0xff
         
          ds18b20_compare_alr_rom_ret:
C:0008e7 9508      	ret
         ; ---------
         ; Fin: Gestion des alarmes
         ; ---------
         
         ; ---------
         ; CRC8-MAXIM
         ; ---------
         ; ds18b20_crc8_calc:   Calcul du CRC8
         ; ds18b20_crc8_test:   Test du CRC8
         ; ds18b20_crc8_bypass: Test du CRC8 avec non prise en compte du 1st byte
         ; ---------
         ; Input:
         ;   - Y:            Adresse du 1st byte
         ;   - REG_TEMP_R16: Nombre de bytes
         ;     => ('Y' + REG_TEMP_R16): Adresse qui suit le dernier byte a lire
         ;
         ;   - Bit Toggle 'T' a 0 pour une non prise en compte du 1st byte
         ;     => Le CRC8 calcule doit etre compare a celui recu
         ;
         ;   - Bit Toggle 'T' a 1 pour une prise en compte du 1st byte
         ;     => Le CRC8 calcule doit etre a 0
         ;
         ; Code en Langage C:
         ;   - 'i__byte': Byte en entree avec le Bit 0 a prendre en compte
         ;                => Bit 0 issu de 8 decalages a droite
         ;
         ;   - 'crc':     CRC8 incremental initialise a 0x00
         ;   - CRC8_POLYNOMIAL = CRC8_POLYNOMIAL = 0x8C pour le CRC8-MAXIM
         ;
         ;     unsigned char carry = ((crc ^ i__byte) & 0x01);
         ;
         ;     crc >>= 1;
         ;     crc ^= (carry ? CRC8_POLYNOMIAL: 0x00);
         ;
         ; ---------
          ds18b20_crc8_calc:
C:0008e8 94e8      	clt
C:0008e9 c001      	rjmp		ds18b20_crc8	
         
          ds18b20_crc8_test:
C:0008ea 9468      	set
         	;rjmp		ds18b20_crc8
         
          ds18b20_crc8:
C:0008eb e009      	ldi		REG_TEMP_R16, 9	; 9 bytes pour le calcul sur les reponses
C:0008ec e0d1      	ldi		REG_Y_MSB, 0x01	; Adresse de 'G_DS18B20_BYTES_RESP'
C:0008ed e6c0      	ldi		REG_Y_LSB, 0x60
         
          ds18b20_crc8_bypass:
C:0008ee 930f      	push		REG_TEMP_R16
C:0008ef 931f      	push		REG_TEMP_R17
C:0008f0 932f      	push		REG_TEMP_R18
C:0008f1 933f      	push		REG_TEMP_R19
C:0008f2 93bf      	push		REG_X_MSB
C:0008f3 93af      	push		REG_X_LSB
C:0008f4 93df      	push		REG_Y_MSB
C:0008f5 93cf      	push		REG_Y_LSB
C:0008f6 93ff      	push		REG_Z_MSB
C:0008f7 93ef      	push		REG_Z_LSB
         
C:0008f8 0fc0      	add		REG_Y_LSB, REG_TEMP_R16
C:0008f9 2711      	clr		REG_TEMP_R17
C:0008fa 1fd1      	adc		REG_Y_MSB, REG_TEMP_R17		; 'Y' pointe sur l'addrese qui suit le dernier byte
         
C:0008fb 2f20      	mov		REG_TEMP_R18, REG_TEMP_R16	; Parcours sans le 1st byte qui contient
         
C:0008fc f00e      	brts		ds18b20_crc8_more		; 'T'=0: Calcul CRC8 pour comparaison 'T'=1: CRC8 a 0 si Ok
C:0008fd 952a      	dec		REG_TEMP_R18
         
          ds18b20_crc8_more:
C:0008fe 2733      	clr		REG_TEMP_R19								; CRC8 calcule
C:0008ff 9330 0068 	sts		G_CALC_CRC8, REG_TEMP_R19
         
          ds18b20_crc8_loop_bytes:
C:000901 9130 0068 	lds		REG_TEMP_R19, G_CALC_CRC8				; Reprise du dernier CRC8 calcule
C:000903 911a      	ld			REG_TEMP_R17, -Y
         
          #ifndef USE_MINIMALIST_ADDONS
C:000904 2fa1      	mov		REG_X_LSB, REG_TEMP_R17
C:000905 dde3      	rcall		uos_print_1_byte_hexa_skip
          #endif
         	
C:000906 932f      	push		REG_TEMP_R18
         
C:000907 e028      	ldi		REG_TEMP_R18, NBR_BITS_TO_SHIFT
         
          ds18b20_crc8_loop_bit:
C:000908 2f03      	mov		REG_TEMP_R16, REG_TEMP_R19	; 'REG_TEMP_R19' contient le CRC8 calcule
C:000909 2701      	eor		REG_TEMP_R16, REG_TEMP_R17	; 'REG_TEMP_R17' contient le byte a inserer dans le polynome
C:00090a 7001      	andi		REG_TEMP_R16, 0x01			; carry = ((crc ^ i__byte) & 0x01);
         
C:00090b 94e8      	clt											; 'T' determine le report de la carry	
C:00090c f009      	breq		ds18b20_crc8_a
C:00090d 9468      	set
         
          ds18b20_crc8_a:
C:00090e 9536      	lsr		REG_TEMP_R19					; crc >>= 1;
C:00090f f416      	brtc		ds18b20_crc8_b
         
C:000910 e80c      	ldi		REG_TEMP_R16, CRC8_POLYNOMIAL
C:000911 2730      	eor		REG_TEMP_R19, REG_TEMP_R16					; crc ^= (carry ? CRC8_POLYNOMIAL: 0x00);
         
          ds18b20_crc8_b:
C:000912 9330 0068 	sts		G_CALC_CRC8, REG_TEMP_R19
         
C:000914 9516      	lsr		REG_TEMP_R17									; i__byte >>= 1
         
C:000915 952a      	dec		REG_TEMP_R18
C:000916 f789      	brne		ds18b20_crc8_loop_bit
         
C:000917 912f      	pop		REG_TEMP_R18
C:000918 952a      	dec		REG_TEMP_R18
C:000919 f739      	brne		ds18b20_crc8_loop_bytes		; Non prise en compte du 1st byte qui est le CRC8 recu ;-)
         
          #ifndef USE_MINIMALIST_ADDONS
C:00091a e403      	ldi		REG_TEMP_R16, 'C'
C:00091b da84      	rcall		push_1_char_in_fifo_tx_skip
C:00091c 2fa3      	mov		REG_X_LSB, REG_TEMP_R19
C:00091d ddcb      	rcall		uos_print_1_byte_hexa_skip
C:00091e ddc0      	rcall		uos_print_line_feed_skip
          #endif
         
C:00091f 91ef      	pop		REG_Z_LSB
C:000920 91ff      	pop		REG_Z_MSB
C:000921 91cf      	pop		REG_Y_LSB
C:000922 91df      	pop		REG_Y_MSB
C:000923 91af      	pop		REG_X_LSB
C:000924 91bf      	pop		REG_X_MSB
C:000925 913f      	pop		REG_TEMP_R19
C:000926 912f      	pop		REG_TEMP_R18
C:000927 911f      	pop		REG_TEMP_R17
C:000928 910f      	pop		REG_TEMP_R16
         
C:000929 9508      	ret
         ; ---------
         ; Fin: CRC8-MAXIM
         ; ---------
         
         ; ---------
         ; Valeur du ROM #N detecte
         ;
         ; Input:
         ;   - 'REG_TEMP_R16' dans la plage [0, 1, 2, ..., ('G_DS18B20_NBR_ROM_FOUND' - 1)]
         ;
         ; Retour:
         ;   - Bit Toggle 'T' a 0 pour non detecte (N >= 'G_DS18B20_NBR_ROM')
         ;   - Bit Toggle 'T' a 1 pour detecte
         ;     => 'X' contient l'adresse du ROM #N ('G_DS18B20_ROM_0', 'G_DS18B20_ROM_1', etc.)
         ;
          ds18b20_get_rom_detected_bypass:
C:00092a 930f      	push		REG_TEMP_R16
C:00092b 2300      	tst		REG_TEMP_R16								; N >= 0 ?
C:00092c f092      	brmi		ds18b20_get_rom_detected_ko			; Saut si N < 0
         
C:00092d 9110 01a0 	lds		REG_TEMP_R17, G_DS18B20_NBR_ROM_FOUND	; Oui
C:00092f 1701      	cp			REG_TEMP_R16, REG_TEMP_R17				; N < 'G_DS18B20_NBR_ROM_FOUND' ?
C:000930 f472      	brpl		ds18b20_get_rom_detected_ko			; Saut si N >= 'G_DS18B20_NBR_ROM_FOUND'
         
          ds18b20_get_rom_detected_ok:							; Oui (0 <= N < 'G_DS18B20_NBR_ROM_FOUND')
C:000931 e0b1      	ldi		REG_X_MSB, high(G_DS18B20_ROM_0)
C:000932 eaa4      	ldi		REG_X_LSB, low(G_DS18B20_ROM_0)
         
C:000933 0f00      	lsl		REG_TEMP_R16								; Table de ROM definis sur 8 bytes
C:000934 0f00      	lsl		REG_TEMP_R16								; => 'REG_TEMP_R16' *= 8
C:000935 0f00      	lsl		REG_TEMP_R16
         
C:000936 0fa0      	add		REG_X_LSB, REG_TEMP_R16
C:000937 2711      	clr		REG_TEMP_R17
C:000938 1fb1      	adc		REG_X_MSB, REG_TEMP_R17
         
          #ifndef USE_MINIMALIST_ADDONS
C:000939 e40f      	ldi		REG_TEMP_R16, 'O'
         
          #if USE_DS18B20_TRACE
          #else
C:00093a da65      	rcall		push_1_char_in_fifo_tx_skip
          #endif
         
C:00093b ddbc      	rcall		uos_print_2_bytes_hexa_skip
C:00093c dda2      	rcall		uos_print_line_feed_skip
          #endif
         
C:00093d 9468      	set														; Detecte
C:00093e c00a      	rjmp		ds18b20_get_rom_detected_ret
         
          ds18b20_get_rom_detected_ko:
         
          #ifndef USE_MINIMALIST_ADDONS
C:00093f 93af      	push		REG_X_LSB
C:000940 930f      	push		REG_TEMP_R16
C:000941 e40b      	ldi		REG_TEMP_R16, 'K'
C:000942 da5d      	rcall		push_1_char_in_fifo_tx_skip
C:000943 910f      	pop		REG_TEMP_R16
C:000944 2fa0      	mov		REG_X_LSB, REG_TEMP_R16
C:000945 dda3      	rcall		uos_print_1_byte_hexa_skip
C:000946 dd98      	rcall		uos_print_line_feed_skip
C:000947 91af      	pop		REG_X_LSB
          #endif
         
C:000948 94e8      	clt														; Non detecte
         
          ds18b20_get_rom_detected_ret:
C:000949 910f      	pop		REG_TEMP_R16
C:00094a 9508      	ret
         ; ---------
         
         ; ---------
         ; Prise de l'index du ROM passe en argument dans la table ['G_DS18B20_ROM_0', ..., 'G_DS18B20_ROM_7']
         ;
         ; - Input:
         ;    - -REG_X_MSB:REG_X_LSB': Adresse du 1st byte du ROM a rechercher
         ;
         ; - Retour dans 'REG_TEMP_R16':
         ;    - 0xff si "Non trouve"
         ;
         ;    - L'index [0, 1, 2, ...] si "trouve" a l'identique sur les 8 octets constituant le ROM
         ; ---------
          ds18b20_get_rom_idx:
C:00094b 931f      	push		REG_TEMP_R17
C:00094c 932f      	push		REG_TEMP_R18
C:00094d 93df      	push		REG_Y_MSB
C:00094e 93cf      	push		REG_Y_LSB
         
C:00094f 9110 01a0 	lds		REG_TEMP_R17, G_DS18B20_NBR_ROM_FOUND
C:000951 2311      	tst		REG_TEMP_R17
C:000952 f0a1      	breq		ds18b20_get_rom_idx_not_found
         
C:000953 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_ROM_0)
C:000954 eac4      	ldi		REG_Y_LSB, low(G_DS18B20_ROM_0)
         
C:000955 2700      	clr		REG_TEMP_R16						
         
          ds18b20_get_rom_idx_loop:
C:000956 93bf      	push		REG_X_MSB							; Sauvegarde de l'adresse du ROM a tester
C:000957 93af      	push		REG_X_LSB
C:000958 e028      	ldi		REG_TEMP_R18, NBR_BITS_TO_SHIFT		; Comparaison sur les 8 bytes
C:000959 9468      	set												; A priori bytes identiques
         
          ds18b20_get_rom_idx_loop_2:
C:00095a 900d      	ld			REG_R0, X+
C:00095b 9019      	ld			REG_R1, Y+
C:00095c 1001      	cpse		REG_R0, REG_R1
C:00095d 94e8      	clt												; Byte(s) different(s) => Continue
         
C:00095e 952a      	dec		REG_TEMP_R18
C:00095f f7d1      	brne		ds18b20_get_rom_idx_loop_2
         
C:000960 91af      	pop		REG_X_LSB							; Reprise de l'adresse du ROM a tester
C:000961 91bf      	pop		REG_X_MSB
         
C:000962 f40e      	brtc		ds18b20_get_rom_idx_cont_d		; Les 8 bytes sont identiques ?
C:000963 c018      	rjmp		ds18b20_get_rom_idx_found		; Oui => Fin avec l'index dans 'REG_TEMP_R16'
         
          ds18b20_get_rom_idx_cont_d:					; Non => Continue
C:000964 9503      	inc		REG_TEMP_R16
C:000965 951a      	dec		REG_TEMP_R17
C:000966 f779      	brne		ds18b20_get_rom_idx_loop
         
         	;rjmp		ds18b20_get_rom_idx_not_found
         
          ds18b20_get_rom_idx_not_found:
C:000967 ef0f      	ldi		REG_TEMP_R16, 0xff
         
C:000968 93bf      	push		REG_X_MSB
C:000969 93af      	push		REG_X_LSB
C:00096a 93bf      	push		REG_X_MSB
C:00096b 93af      	push		REG_X_LSB
C:00096c 930f      	push		REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_ADDONS
C:00096d e30f      	ldi		REG_TEMP_R16, '?'
C:00096e da31      	rcall		push_1_char_in_fifo_tx_skip
C:00096f 91af      	pop		REG_X_LSB
C:000970 dd78      	rcall		uos_print_1_byte_hexa_skip
C:000971 91af      	pop		REG_X_LSB
C:000972 91bf      	pop		REG_X_MSB
C:000973 dd84      	rcall		uos_print_2_bytes_hexa_skip
C:000974 2fbd      	mov		REG_X_MSB, REG_Y_MSB
C:000975 2fac      	mov		REG_X_LSB, REG_Y_LSB
C:000976 dd81      	rcall		uos_print_2_bytes_hexa_skip
C:000977 dd67      	rcall		uos_print_line_feed_skip
          #else
          #endif
         
C:000978 91af      	pop		REG_X_LSB
C:000979 91bf      	pop		REG_X_MSB
         
C:00097a ef0f      	ldi		REG_TEMP_R16, 0xff
C:00097b c008      	rjmp		ds18b20_get_rom_idx_ret
         
          ds18b20_get_rom_idx_found:
C:00097c 930f      	push		REG_TEMP_R16
C:00097d 930f      	push		REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_ADDONS
C:00097e e402      	ldi		REG_TEMP_R16, 'B'
C:00097f da20      	rcall		push_1_char_in_fifo_tx_skip
C:000980 91af      	pop		REG_X_LSB
C:000981 dd67      	rcall		uos_print_1_byte_hexa_skip
C:000982 dd5c      	rcall		uos_print_line_feed_skip
          #else
          #endif
         
C:000983 910f      	pop		REG_TEMP_R16
         
          ds18b20_get_rom_idx_ret:
C:000984 91cf      	pop		REG_Y_LSB
C:000985 91df      	pop		REG_Y_MSB
C:000986 912f      	pop		REG_TEMP_R18
C:000987 911f      	pop		REG_TEMP_R17
         
C:000988 9508      	ret
         ; ---------
         
         ; ---------
         ; Construction des trames a emettre pour chaque capteur
         ; => Les informations issues de 'ds18b20_read_scratchpad' sont deja disponibles
         ; => Les trames sont ecrites aux emplacements ['G_DS18B20_ALR_ROM_0', 'G_DS18B20_ALR_ROM_1', etc.]
         ; ---------
          build_frame_infos:
C:000989 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_RESP)
C:00098a e7cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_RESP)
C:00098b e0f1      	ldi		REG_Z_MSB, high(G_DS18B20_FRAME_0)
C:00098c ecec      	ldi		REG_Z_LSB, low(G_DS18B20_FRAME_0)
C:00098d 9110 01a3 	lds		REG_TEMP_R17, G_DS18B20_ROM_IDX
         
         	; Inversion pour l'emission du 1st capteur en premier
         	; #0 -> 'G_DS18B20_NBR_ROM_FOUND', #1 -> ('G_DS18B20_NBR_ROM_FOUND' - 1), etc.
C:00098f 9100 01a0 	lds		REG_TEMP_R16, G_DS18B20_NBR_ROM_FOUND
C:000991 1b01      	sub		REG_TEMP_R16, REG_TEMP_R17	
C:000992 5001      	subi		REG_TEMP_R16, 1
C:000993 0f00      	lsl		REG_TEMP_R16
C:000994 0f00      	lsl		REG_TEMP_R16
C:000995 0f00      	lsl		REG_TEMP_R16
C:000996 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:000997 2700      	clr		REG_TEMP_R16
C:000998 1ff0      	adc		REG_Z_MSB, REG_TEMP_R16
         
C:000999 9100 0199 	lds		REG_TEMP_R16, G_DS18B20_FAMILLE
C:00099b 8306      	std		Z + FRAME_IDX_FAMILLE, REG_TEMP_R16
         
C:00099c 9100 01a3 	lds		REG_TEMP_R16, G_DS18B20_ROM_IDX
C:00099e 8307      	std		Z + FRAME_IDX_IDX, REG_TEMP_R16
         
C:00099f 8508      	ldd		REG_TEMP_R16, Y + RESP_IDX_TC_LSB
C:0009a0 8304      	std		Z + FRAME_IDX_TC_LSB, REG_TEMP_R16
         
C:0009a1 810f      	ldd		REG_TEMP_R16, Y + RESP_IDX_TC_MSB
C:0009a2 8305      	std		Z + FRAME_IDX_TC_MSB, REG_TEMP_R16
         
C:0009a3 810d      	ldd		REG_TEMP_R16, Y + RESP_IDX_TL
C:0009a4 8302      	std		Z + FRAME_IDX_TL, REG_TEMP_R16
         
C:0009a5 810e      	ldd		REG_TEMP_R16, Y + RESP_IDX_TH
C:0009a6 8303      	std		Z + FRAME_IDX_TH, REG_TEMP_R16
         
C:0009a7 810a      	ldd		REG_TEMP_R16, Y + RESP_IDX_RESOL_CONV
C:0009a8 9502      	swap		REG_TEMP_R16				; Resolution dans REG_TEMP_R16<2,1>
C:0009a9 9506      	lsr		REG_TEMP_R16				; Resolution dans REG_TEMP_R16<1,0>
C:0009aa 7003      	andi		REG_TEMP_R16, 0x03		; Isolement de la resolution
         
         	; Add  Etat du capteur en alarme ou non (bit #7 de 'FRAME_IDX_ALR_RES_CONV')
C:0009ab 93ff      	push		REG_Z_MSB
C:0009ac 93ef      	push		REG_Z_LSB
         
C:0009ad e1f4      	ldi		REG_Z_MSB, ((text_msk_table << 1) / 256)
C:0009ae ece2      	ldi		REG_Z_LSB, ((text_msk_table << 1) % 256)
C:0009af 9110 01a3 	lds		REG_TEMP_R17, G_DS18B20_ROM_IDX
C:0009b1 0fe1      	add		REG_Z_LSB, REG_TEMP_R17
C:0009b2 2711      	clr		REG_TEMP_R17
C:0009b3 1ff1      	adc		REG_Z_MSB, REG_TEMP_R17
C:0009b4 9114      	lpm		REG_TEMP_R17, Z
C:0009b5 9120 0198 	lds		REG_TEMP_R18, G_DS18B20_IN_ALARM
C:0009b7 2312      	and		REG_TEMP_R17, REG_TEMP_R18
C:0009b8 f009      	breq		build_frame_infos_no_alarm
C:0009b9 6800      	sbr		REG_TEMP_R16, MSK_BIT7	; Etat d'alarme du Capteur dans REG_TEMP_R16<7>
         
          build_frame_infos_no_alarm:
C:0009ba 91ef      	pop		REG_Z_LSB
C:0009bb 91ff      	pop		REG_Z_MSB
C:0009bc 8301      	std		Z + FRAME_IDX_ALR_RES_CONV, REG_TEMP_R16
         	; End: Add  Etat du capteur en alarme ou non (bit #7 de 'FRAME_IDX_ALR_RES_CONV')
         
         	; Calcul du CRC8
C:0009bd e008      	ldi		REG_TEMP_R16, NBR_BITS_TO_SHIFT			; CRC8 sur les 7 bytes qui suivent 'Z + FRAME_IDX_CRC8'
C:0009be 01ef      	movw		REG_Y_LSB, REG_Z_LSB
C:0009bf 94e8      	clt
C:0009c0 df2d      	rcall		ds18b20_crc8_bypass
C:0009c1 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
C:0009c3 8300      	std		Z + FRAME_IDX_CRC8, REG_TEMP_R16
         	; Fin: Calcul du CRC8
         
C:0009c4 9508      	ret
         ; ---------
         
         ; ---------
          buid_frame_complement:
         	; Positionnement sur le 1st byte qui suit le dernier byte de la trame capteur
C:0009c5 e0f1      	ldi		REG_Z_MSB, high(G_DS18B20_FRAME_0)
C:0009c6 ecec      	ldi		REG_Z_LSB, low(G_DS18B20_FRAME_0)
C:0009c7 9100 01a0 	lds		REG_TEMP_R16, G_DS18B20_NBR_ROM_FOUND
C:0009c9 9300 016e 	sts		G_HEADER_NBR_CAPTEURS, REG_TEMP_R16		; Nombre de capteurs
C:0009cb 0f00      	lsl		REG_TEMP_R16									; Raccourci car 'FRAME_LENGTH_CAPTEUR' == 8
C:0009cc 0f00      	lsl		REG_TEMP_R16
C:0009cd 0f00      	lsl		REG_TEMP_R16
C:0009ce 2f10      	mov		REG_TEMP_R17, REG_TEMP_R16					; Nbr de bytes sans le CRC8 et le Header
         
C:0009cf 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:0009d0 2700      	clr		REG_TEMP_R16
C:0009d1 1ff0      	adc		REG_Z_MSB, REG_TEMP_R16
C:0009d2 9738      	sbiw		REG_Z_LSB, FRAME_LENGTH_CAPTEUR
         
C:0009d3 9100 016e 	lds		REG_TEMP_R16, G_HEADER_NBR_CAPTEURS
C:0009d5 8700      	std		Z + FRAME_IDX_NBR_CAPTEURS, REG_TEMP_R16
         
C:0009d6 9100 016b 	lds		REG_TEMP_R16, G_HEADER_TIMESTAMP_MSB
C:0009d8 8703      	std		Z + FRAME_IDX_TIMESTAMP_MSB, REG_TEMP_R16
C:0009d9 9100 016c 	lds		REG_TEMP_R16, G_HEADER_TIMESTAMP_MID
C:0009db 8702      	std		Z + FRAME_IDX_TIMESTAMP_MID, REG_TEMP_R16
C:0009dc 9100 016d 	lds		REG_TEMP_R16, G_HEADER_TIMESTAMP_LSB
C:0009de 8701      	std		Z + FRAME_IDX_TIMESTAMP_LSB, REG_TEMP_R16
         
C:0009df 9100 0169 	lds		REG_TEMP_R16, G_HEADER_NUM_FRAME_MSB
C:0009e1 8705      	std		Z + FRAME_IDX_NUM_FRAME_MSB, REG_TEMP_R16
C:0009e2 9100 016a 	lds		REG_TEMP_R16, G_HEADER_NUM_FRAME_LSB
C:0009e4 8704      	std		Z + FRAME_IDX_NUM_FRAME_LSB, REG_TEMP_R16
         
C:0009e5 9100 0167 	lds		REG_TEMP_R16, G_HEADER_INDEX_PLATINE
C:0009e7 8706      	std		Z + FRAME_IDX_INDEX_PLATINE, REG_TEMP_R16
C:0009e8 9100 0166 	lds		REG_TEMP_R16, G_HEADER_TYPE_PLATINE
C:0009ea 8707      	std		Z + FRAME_IDX_TYPE_PLATINE, REG_TEMP_R16
         
         	; Calcul du CRC8 de la trame complete
C:0009eb 5f17      	subi		REG_TEMP_R17, -(1 + 8)			; Reprise du nombre de bytes avec le CRC8 et le Header
         
         	; Calcul du CRC8 sur tous les bytes sauf le 1st
C:0009ec e0d1      	ldi		REG_Y_MSB, high(G_FRAME_ALL_INFOS)
C:0009ed eccb      	ldi		REG_Y_LSB, low(G_FRAME_ALL_INFOS)
C:0009ee 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:0009ef 94e8      	clt
C:0009f0 defd      	rcall		ds18b20_crc8_bypass
C:0009f1 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
C:0009f3 9300 01cb 	sts		G_FRAME_ALL_INFOS, REG_TEMP_R16
         	; Fin: Calcul du CRC8 sur tous les bytes sauf le 1st
         
          #ifndef USE_MINIMALIST_ADDONS
C:0009f5 2fa1      	mov		REG_X_LSB, REG_TEMP_R17
C:0009f6 dcf2      	rcall		uos_print_1_byte_hexa_skip
C:0009f7 01de      	movw		REG_X_LSB, REG_Y_LSB
C:0009f8 dcff      	rcall		uos_print_2_bytes_hexa_skip
C:0009f9 dce5      	rcall		uos_print_line_feed_skip
          #endif
         
         	; Calcul du CRC8 sur tous les bytes avec le 1st
         	; => Le CRC8 "total" doit etre etre egal a 0 car inclu ledit CRC8 ;-)
C:0009fa e0d1      	ldi		REG_Y_MSB, high(G_FRAME_ALL_INFOS)
C:0009fb eccb      	ldi		REG_Y_LSB, low(G_FRAME_ALL_INFOS)
C:0009fc 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:0009fd 9468      	set
C:0009fe deef      	rcall		ds18b20_crc8_bypass
C:0009ff 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
         	; Fin: Calcul du CRC8 sur tous les bytes avec le 1st
         
          #ifndef USE_MINIMALIST_ADDONS
C:000a01 2fa1      	mov		REG_X_LSB, REG_TEMP_R17
C:000a02 dce6      	rcall		uos_print_1_byte_hexa_skip
C:000a03 01de      	movw		REG_X_LSB, REG_Y_LSB
C:000a04 dcf3      	rcall		uos_print_2_bytes_hexa_skip
C:000a05 dcd9      	rcall		uos_print_line_feed_skip
          #endif
         	; Fin: Calcul du CRC8 sur tous les bytes avec le 1st
         	; Fin: Calcul du CRC8 de la trame complete
         
C:000a06 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission de la trame complete
         ; ---------
          ds18b20_send_frame:
         	; Positionnement sur le 1st byte qui suit le dernier byte de la trame capteur
C:000a07 9120 016e 	lds		REG_TEMP_R18, G_HEADER_NBR_CAPTEURS		; Nombre de capteurs
C:000a09 0f22      	lsl		REG_TEMP_R18									; Raccourci car 'FRAME_LENGTH_CAPTEUR' == 8
C:000a0a 0f22      	lsl		REG_TEMP_R18
C:000a0b 0f22      	lsl		REG_TEMP_R18
C:000a0c 5f27      	subi		REG_TEMP_R18, -(1 + 8)						; Nombre de bytes avec le CRC8 et le Header
         
C:000a0d e0d1      	ldi		REG_Y_MSB, high(G_FRAME_ALL_INFOS)
C:000a0e eccb      	ldi		REG_Y_LSB, low(G_FRAME_ALL_INFOS)
C:000a0f 0fc2      	add		REG_Y_LSB, REG_TEMP_R18
C:000a10 2700      	clr		REG_TEMP_R16
C:000a11 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16
         
          #if USE_DS18B20_TRACE
          #endif
         
         	; Emission de la trame
C:000a12 e204      	ldi		REG_TEMP_R16, '$'
C:000a13 d98e      	rcall		uos_push_1_char_in_fifo_tx
         
          ds18b20_send_frame_loop:
C:000a14 910a      	ld			REG_TEMP_R16, -Y
C:000a15 dcb0      	rcall		convert_and_put_fifo_tx
C:000a16 952a      	dec		REG_TEMP_R18
C:000a17 f7e1      	brne		ds18b20_send_frame_loop
C:000a18 dcc8      	rcall		uos_print_line_feed
C:000a19 d9a3      	rcall		fifo_tx_to_send_sync
         	; Fin: Emission de la trame
         
C:000a1a 9508      	ret
         ; ---------
         
         ; ---------
         ; Configuration des DS18B20
         ; ---------
         
          #ifndef USE_MINIMALIST_ADDONS
         ; ---------
         ; Conversion pour le DS18B20
         ;
         ; Input: 'REG_X_MSB:REG_X_LSB'
         ;
         ; Output: - Si valeur coherente (T == 1) -> 'REG_X_LSB'
         ;         - Sinon               (T == 0) -> 'REG_X_LSB' indefini
         ; ---------
          convert_val_for_ds18b20:
C:000a1b d01a      	rcall		convert_2_bytes_hexa_to_dec
         
C:000a1c 91b0 0122 	lds		REG_X_MSB, G_TEST_VALUE_DEC_MSB
C:000a1e 91a0 0123 	lds		REG_X_LSB, G_TEST_VALUE_DEC_LSB
C:000a20 dcd7      	rcall		uos_print_2_bytes_hexa_skip
C:000a21 dcbd      	rcall		uos_print_line_feed_skip
         
         	; Test dans la plage [0, 1, ..., 99, 100, 101, ..., 155]
         	;                                    L-- Negatives (0, -1, -2, ..., -55)
         	;                                    => (256 - (Value - 100)) = ((356 - Value) % 256) -> [0, -1, -2, ..., -55]
         	;                     L-- Positives (0, 1, 2, ..;, 99)                                -> [0, +1, +2, ..., +99]
         	;
C:000a22 e010      	ldi		REG_TEMP_R17, 0
C:000a23 e90c      	ldi		REG_TEMP_R16, (155 + 1)
C:000a24 17a0      	cp			REG_X_LSB, REG_TEMP_R16
C:000a25 07b1      	cpc		REG_X_MSB, REG_TEMP_R17
C:000a26 f46a      	brpl		convert_val_for_ds18b20_ko
         
         	; Test si valeur negative a configurer ?
C:000a27 e010      	ldi		REG_TEMP_R17, 0
C:000a28 e604      	ldi		REG_TEMP_R16, 100
C:000a29 17a0      	cp			REG_X_LSB, REG_TEMP_R16
C:000a2a 07b1      	cpc		REG_X_MSB, REG_TEMP_R17
C:000a2b f412      	brpl		convert_val_for_ds18b20_val_neg
         
          convert_val_for_ds18b20_val_pos:
C:000a2c 018d      	movw		REG_TEMP_R16, REG_X_LSB
C:000a2d c003      	rjmp		convert_val_for_ds18b20_value
         
          convert_val_for_ds18b20_val_neg:
C:000a2e e011      	ldi		REG_TEMP_R17, 0x01		; 356 = 0x164
C:000a2f e604      	ldi		REG_TEMP_R16, 0x64
C:000a30 1b0a      	sub		REG_TEMP_R16, REG_X_LSB	; ((356 - Value) % 256)
         
          convert_val_for_ds18b20_value:
C:000a31 2fa0      	mov		REG_X_LSB, REG_TEMP_R16
C:000a32 94e8      	clt
C:000a33 c001      	rjmp		convert_val_for_ds18b20_rtn
         
          convert_val_for_ds18b20_ko:
C:000a34 9468      	set
         
          convert_val_for_ds18b20_rtn:
C:000a35 9508      	ret
         ; ---------
         
         ; ---------
         ; Conversion des 2 bytes 'REG_X_MSB:REG_X_LSB' en decimal dans 'G_TEST_VALUE_DEC_MSB:G_TEST_VALUE_DEC_LSB'
         ; ---------
          convert_2_bytes_hexa_to_dec:
C:000a36 930f      	push		REG_TEMP_R16
         
C:000a37 2f0b      	mov		REG_TEMP_R16, REG_X_MSB
C:000a38 9502      	swap		REG_TEMP_R16
C:000a39 700f      	andi		REG_TEMP_R16, 0x0F					; Isolement de '0xHH..:....'
C:000a3a 5d00      	subi		REG_TEMP_R16, -'0'					; Conversion en ASCII ['0', ..., '9']
C:000a3b dbd7      	rcall		char_to_dec_incremental
         
C:000a3c 2f0b      	mov		REG_TEMP_R16, REG_X_MSB
C:000a3d 700f      	andi		REG_TEMP_R16, 0x0F					; Isolement de '0x..HH:....'
C:000a3e 5d00      	subi		REG_TEMP_R16, -'0'					; Conversion en ASCII ['0', ..., '9']
C:000a3f dbd3      	rcall		char_to_dec_incremental
         
C:000a40 2f0a      	mov		REG_TEMP_R16, REG_X_LSB
C:000a41 9502      	swap		REG_TEMP_R16
C:000a42 700f      	andi		REG_TEMP_R16, 0x0F					; Isolement de '0x....:HH..'
C:000a43 5d00      	subi		REG_TEMP_R16, -'0'					; Conversion en ASCII ['0', ..., '9']
C:000a44 dbce      	rcall		char_to_dec_incremental
         
C:000a45 2f0a      	mov		REG_TEMP_R16, REG_X_LSB
C:000a46 700f      	andi		REG_TEMP_R16, 0x0F					; Isolement de '0x....:..HH'
C:000a47 5d00      	subi		REG_TEMP_R16, -'0'					; Conversion en ASCII ['0', ..., '9']
C:000a48 dbca      	rcall		char_to_dec_incremental
         
C:000a49 910f      	pop		REG_TEMP_R16
C:000a4a 9508      	ret
         ; ---------
          #endif
         
          text_prompt_ds18b20:
          #ifndef USE_MINIMALIST_ADDONS
          .db	"### ATtiny85_uOS+DS18B20 $Revision: 1.38 $", CHAR_LF, CHAR_NULL
C:000A4B 23232320415474696E7938355F754F532B4453313842323020245265766973696F6E3A20312E333820240A00
          #else
          #endif
         
          text_msk_table:
          .db	MSK_BIT0, MSK_BIT1, MSK_BIT2, MSK_BIT3
C:000A61 01020408
          .db	MSK_BIT4, MSK_BIT5, MSK_BIT6, MSK_BIT7
C:000A63 10204080
         
         ;end:
         
          .include		"ATtiny85_uOS+DS18B20_Timers.asm"
         ; "$Id: ATtiny85_uOS+DS18B20_Timers.asm,v 1.7 2025/12/14 10:57:52 administrateur Exp $"
         
          .cseg
         
         ; Extensions d'execution de uOS pour DS18B20
         ; -------
          exec_timer_ds18b20:
C:000a65 91b0 016c 	lds      REG_X_MSB, G_HEADER_TIMESTAMP_MID
C:000a67 91a0 016d 	lds      REG_X_LSB, G_HEADER_TIMESTAMP_LSB
C:000a69 9611      	adiw     REG_X_LSB, 1
C:000a6a 93b0 016c 	sts      G_HEADER_TIMESTAMP_MID, REG_X_MSB
C:000a6c 93a0 016d 	sts      G_HEADER_TIMESTAMP_LSB, REG_X_LSB
         
C:000a6e f429      	brne		exec_timer_ds18b20_more
         
C:000a6f 9110 016b 	lds		REG_TEMP_R17, G_HEADER_TIMESTAMP_MSB
C:000a71 9513      	inc		REG_TEMP_R17
C:000a72 9310 016b 	sts		G_HEADER_TIMESTAMP_MSB, REG_TEMP_R17
         
         	; Cadencement de l'emission des trames DS18B20
          exec_timer_ds18b20_more:
C:000a74 9110 019a 	lds		REG_TEMP_R17, G_DS18B20_COUNTER
C:000a76 2311      	tst		REG_TEMP_R17
C:000a77 f049      	breq		exec_timer_ds18b20_cont_d					; Pas de traitement si 'G_DS18B20_COUNTER' trouve a 0
         
C:000a78 951a      	dec		REG_TEMP_R17
C:000a79 9310 019a 	sts		G_DS18B20_COUNTER, REG_TEMP_R17			; New value of counter
C:000a7b f429      	brne		exec_timer_ds18b20_cont_d					; Awaiting counter equal to 0
         
C:000a7c 9110 019b 	lds		REG_TEMP_R17, G_DS18B20_COUNTER_INIT	; Reinit value of counter
C:000a7e 9310 019a 	sts		G_DS18B20_COUNTER, REG_TEMP_R17
         
         	; Execution de la decouverte des capteurs DS18B20 + emission de la trame
C:000a80 dcfd      	rcall		ds18b20_exec
         
         	; Fin: Cadencement de l'emission des trames DS18B20
         
          exec_timer_ds18b20_cont_d:
         	; Reinitialisation du timer 'DS18B20_TIMER_1_SEC'
C:000a81 e01f      	ldi		REG_TEMP_R17, DS18B20_TIMER_1_SEC
C:000a82 ee28      	ldi		REG_TEMP_R18, (1000 % 256)
C:000a83 e033      	ldi		REG_TEMP_R19, (1000 / 256)
C:000a84 e645      	ldi		REG_TEMP_R20, low(exec_timer_ds18b20)
C:000a85 e05a      	ldi		REG_TEMP_R21, high(exec_timer_ds18b20)
C:000a86   +  	_CALL		start_timer
C:000a86 940e 0264 call		start_timer
         
C:000a88 9508      	ret
         ; ---------
         
         ; End of file
         
          
         
          #ifndef USE_MINIMALIST_ADDONS
          .include		"ATtiny85_uOS+DS18B20_Commands.asm"
         ; "$Id: ATtiny85_uOS+DS18B20_Commands.asm,v 1.9 2025/12/03 14:53:40 administrateur Exp $"
         
         ; Prolongation des commandes non supportees par uOS
         
          .cseg
         
         ; ---------
          exec_command_ds18b20:
C:000a89 3403      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_C_MAJ
C:000a8a f409      	brne		exec_command_ds18b20_test_t_maj
C:000a8b c004      	rjmp		exec_command_type_C
         
          exec_command_ds18b20_test_t_maj:
C:000a8c 3504      	cpi		REG_TEMP_R16, CHAR_TYPE_COMMAND_T_MAJ
C:000a8d f409      	brne		exec_command_ds18b20_ko
C:000a8e c081      	rjmp		exec_command_type_T
         
          exec_command_ds18b20_ko:
C:000a8f c9d9      	rjmp    uos_print_command_ko        ; Commande non reconnue
         ; ---------
         
         ; ---------
         ; Execution de la commande 'C'
         ;
         ; Configuration des seuils d'alarme et de la resolution pour un capteur donne
         ; ou tous les capteurs reconnus sur le bud 1-Wire
         ;
         ; Usages:
         ; - "<C1+<seuil_tl>+<seuil_th>+<resolution>"
         ;
         ; avec:
         ; - <seuil_tl> et <seuil_th> dans la plage [0, 1, ..., 99] pour une temperature positive
         ;                            egale a [0, 1, ..., 99] degres C
         ;                         et dans la plage [101, 102, ..., 155] pour une temperature negative
         ;                            egale a [-1, -2, ..., -55] degres C
         ;
         ; Remarque: 0 et 100 correspondant a 0 C
         ;
         ; Exemples:
         ; - "<C1+18+23+2" -> Configuration du capteur #1
         ; - "<C0+19+22+3" -> Configuration de tous les capteurs
         ; ---------
          exec_command_type_C:
         	; Autorisation traces si 'G_DS18B20_FLAGS<FLG_DS18B20_TRACE>' a 1
C:000a90 9100 0168 	lds      REG_TEMP_R16, G_DS18B20_FLAGS
C:000a92 ff03      	sbrs     REG_TEMP_R16, FLG_DS18B20_TRACE_IDX
C:000a93 6280      	sbr      REG_FLAGS_0, FLG_0_PRINT_SKIP_MSK
         
         	; Prise des parametre de la commande
         	; => ie. "<C2+15+24+2" (#Id capteur + Tl + Th + Resolution)
C:000a94 d013      	rcall		exec_command_type_C_get_params
         
         	; Print des conversions valides ou invalides
C:000a95 f016      	brts		exec_command_type_C_ko
         
          exec_command_type_C_ok:
C:000a96 d9cd      	rcall		uos_print_command_ok
C:000a97 c001      	rjmp		exec_command_type_C_print
         
          exec_command_type_C_ko:
C:000a98 d9d0      	rcall		uos_print_command_ko
         
          exec_command_type_C_print:
C:000a99 91a0 01cb 	lds		REG_X_LSB, (G_FRAME_ALL_INFOS + 0)
C:000a9b dc4f      	rcall		uos_print_1_byte_hexa
C:000a9c 91a0 01cc 	lds		REG_X_LSB, (G_FRAME_ALL_INFOS + 1)
C:000a9e dc4c      	rcall		uos_print_1_byte_hexa
C:000a9f 91a0 01cd 	lds		REG_X_LSB, (G_FRAME_ALL_INFOS + 2)
C:000aa1 dc49      	rcall		uos_print_1_byte_hexa
C:000aa2 91a0 01ce 	lds		REG_X_LSB, (G_FRAME_ALL_INFOS + 3)
C:000aa4 dc46      	rcall		uos_print_1_byte_hexa
C:000aa5 dc3b      	rcall		uos_print_line_feed
         
         	; Reactivation des traces
C:000aa6 7d8f      	cbr		REG_FLAGS_0, FLG_0_PRINT_SKIP_MSK
         
C:000aa7 9508      	ret
         ; ---------
         
         ; ---------
          exec_command_type_C_get_params:
         ; ---------
         	; Effacement des conversions des parametres
C:000aa8 2700      	clr		REG_TEMP_R16
C:000aa9 9300 01cb 	sts		(G_FRAME_ALL_INFOS + 0), REG_TEMP_R16		; #Id du capteur
C:000aab 9300 01cc 	sts		(G_FRAME_ALL_INFOS + 1), REG_TEMP_R16		; 1st parametre (Tl)
C:000aad 9300 01cd 	sts		(G_FRAME_ALL_INFOS + 2), REG_TEMP_R16		; 2nd parametre (Th)
C:000aaf 9300 01ce 	sts		(G_FRAME_ALL_INFOS + 3), REG_TEMP_R16		; 3rd parametre (Resolution)
         	
         	; #Id du capteur [0, 1, ..., 0xff]
C:000ab1 27bb         clr      REG_X_MSB
C:000ab2 91a0 011f    lds      REG_X_LSB, G_TEST_VALUE_LSB
         
         	; Test de l'Id capteur avec comme convention:
         	; - Si 'G_DS18B20_NBR_ROM_FOUND' == 0 -> Erreur
         	; - Si 'REG_X_LSB' == 0 -> Adressage des capteurs #0, #1, #2, ..., #(G_DS18B20_NBR_ROM_FOUND - 1)
         	; - Si 'REG_X_LSB' dans la plage [1, 2, ..., G_DS18B20_NBR_ROM_FOUND] -> Adressage du capteur #'REG_X_LSB'
         	; - Sinon -> Erreur	
C:000ab4 9100 01a0 	lds		REG_TEMP_R16, G_DS18B20_NBR_ROM_FOUND
C:000ab6 2300      	tst		REG_TEMP_R16
C:000ab7 f1a1      	breq		exec_command_type_C_not_valid
         
C:000ab8 23aa      	tst		REG_X_LSB
C:000ab9 f029      	breq		exec_command_type_C_all_capteur		; Balayage des 'G_DS18B20_NBR_ROM' capteurs
         
C:000aba 170a      	cp			REG_TEMP_R16, REG_X_LSB					; REG_X_LSB dans la plage [1, 2, ..., G_DS18B20_NBR_ROM_FOUND]
C:000abb 2700      	clr		REG_TEMP_R16
C:000abc 070b      	cpc		REG_TEMP_R16, REG_X_MSB
C:000abd f452      	brpl		exec_command_type_C_this_capteur
         
C:000abe c02d      	rjmp		exec_command_type_C_not_valid			; #Id hors plage @ 'G_DS18B20_NBR_ROM_FOUND'
         
          exec_command_type_C_all_capteur:
C:000abf 9120 01a0 	lds		REG_TEMP_R18, G_DS18B20_NBR_ROM_FOUND
         
          exec_command_type_C_all_capteur_loop:
C:000ac1 932f      	push		REG_TEMP_R18
         
C:000ac2 2fa2      	mov		REG_X_LSB, REG_TEMP_R18
C:000ac3 d004      	rcall		exec_command_type_C_this_capteur
         
C:000ac4 912f      	pop		REG_TEMP_R18
C:000ac5 952a      	dec		REG_TEMP_R18
C:000ac6 f7d1      	brne		exec_command_type_C_all_capteur_loop	
         
C:000ac7 c032      	rjmp		exec_command_type_C_end
         
          exec_command_type_C_this_capteur:
C:000ac8 95aa      	dec		REG_X_LSB									; Formatage #Id dans la plage [0, 1, ..., (G_DS18B20_NBR_ROM_FOUND - 1)]
C:000ac9 93a0 01cb 	sts		(G_FRAME_ALL_INFOS + 0), REG_X_LSB
         
C:000acb e413         ldi      REG_TEMP_R17, 'C'
C:000acc dc3c         rcall    uos_print_mark_skip
C:000acd dc2a         rcall    uos_print_2_bytes_hexa_skip
C:000ace dc10         rcall    uos_print_line_feed_skip
         
         	; 1st parametre (Tl)
C:000acf e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE)
C:000ad0 e2c6      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE)
C:000ad1 d029      	rcall		exec_command_type_C_convert_param
C:000ad2 f0ce      	brts		exec_command_type_C_not_valid
         
C:000ad3 93a0 01cc 	sts		(G_FRAME_ALL_INFOS + 1), REG_X_LSB
         
         	; 2nd parametre (Th)
C:000ad5 e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE + 2)
C:000ad6 e2c8      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE + 2)
C:000ad7 d023      	rcall		exec_command_type_C_convert_param
C:000ad8 f09e      	brts		exec_command_type_C_not_valid
         
C:000ad9 93a0 01cd 	sts		(G_FRAME_ALL_INFOS + 2), REG_X_LSB
         
         	; 3rd parametre (Resolution)
C:000adb e0d1      	ldi		REG_Y_MSB, high(G_TEST_VALUES_ZONE + 4)
C:000adc e2ca      	ldi		REG_Y_LSB, low(G_TEST_VALUES_ZONE + 4)
C:000add 81a8      	ldd		REG_X_LSB, Y+0
         
C:000ade dc0a         rcall    uos_print_1_byte_hexa_skip
C:000adf dbff         rcall    uos_print_line_feed_skip
         
C:000ae0 30a4      	cpi		REG_X_LSB, (3 + 1)		; [0, 1, 2, 3] admis
C:000ae1 f452      	brpl		exec_command_type_C_not_valid
         
C:000ae2 95a2      	swap		REG_X_LSB					; Mise au format pour le 'scratchpad'
C:000ae3 0faa      	lsl		REG_X_LSB
C:000ae4 61af      	ori		REG_X_LSB, 0x1f
C:000ae5 93a0 01ce 	sts		(G_FRAME_ALL_INFOS + 3), REG_X_LSB
         
C:000ae7 e41f      	ldi		REG_TEMP_R17, 'O'
C:000ae8 dc20      	rcall		uos_print_mark_skip
         
C:000ae9 d26c      	rcall		ds18b20_write_scratchpad_x
         
C:000aea d276      	rcall		ds18b20_copy_scratchpad_x
         
C:000aeb c00e      	rjmp		exec_command_type_C_end
         
          exec_command_type_C_not_valid:
C:000aec ef0f      	ldi		REG_TEMP_R16, 0xff
C:000aed 9300 01cb 	sts		(G_FRAME_ALL_INFOS + 0), REG_TEMP_R16
C:000aef 9300 01cc 	sts		(G_FRAME_ALL_INFOS + 1), REG_TEMP_R16
C:000af1 9300 01cd 	sts		(G_FRAME_ALL_INFOS + 2), REG_TEMP_R16
C:000af3 9300 01ce 	sts		(G_FRAME_ALL_INFOS + 3), REG_TEMP_R16
         
C:000af5 9100 011c 	lds		REG_TEMP_R16, G_TEST_FLAGS
C:000af7 6800      	sbr		REG_TEMP_R16, FLG_TEST_CONFIG_ERROR_MSK
C:000af8 9300 011c 	sts		G_TEST_FLAGS, REG_TEMP_R16
         
          exec_command_type_C_end:
C:000afa 9508      	ret
         ; ---------
         
         ; ---------
          exec_command_type_C_convert_param:
         ; ---------
C:000afb 2700      	clr		REG_TEMP_R16
C:000afc 9300 0122 	sts		G_TEST_VALUE_DEC_MSB, REG_TEMP_R16		; Raz resultat decimal
C:000afe 9300 0123 	sts		G_TEST_VALUE_DEC_LSB, REG_TEMP_R16
         
C:000b00 81a8      	ldd		REG_X_LSB, Y+0
C:000b01 81b9      	ldd		REG_X_MSB, Y+1
C:000b02 dbf5         rcall    uos_print_2_bytes_hexa_skip
         
C:000b03 df17      	rcall		convert_val_for_ds18b20
C:000b04 f00e      	brts		exec_command_type_C_wrong
C:000b05 c004      	rjmp		exec_command_type_C_valid
         
          exec_command_type_C_wrong:
C:000b06 e41b      	ldi		REG_TEMP_R17, 'K'
C:000b07 dc01      	rcall		uos_print_mark_skip
C:000b08 9468      	set									; Car 'T' est modifie par 'uart_fifo_tx_write'
C:000b09 c005      	rjmp		exec_command_type_C_more
         
          exec_command_type_C_valid:
C:000b0a e41f      	ldi		REG_TEMP_R17, 'O'
C:000b0b dbfd      	rcall		uos_print_mark_skip
C:000b0c dbdc      	rcall		uos_print_1_byte_hexa_skip
C:000b0d dbd1      	rcall		uos_print_line_feed_skip
C:000b0e 94e8      	clt									; Car 'T' est modifie par 'uart_fifo_tx_write'
         
          exec_command_type_C_more:
C:000b0f 9508      	ret
         ; ---------
         
         ; ---------
         ; Activation / deactivation traces de developpement
         ; ---------
          exec_command_type_T:
         	; Prise du parametre de la commande
         	; => ie. "<T0" ou "<T1" (ou != 0)
         
C:000b10 27bb         clr      REG_X_MSB
C:000b11 91a0 011f    lds      REG_X_LSB, G_TEST_VALUE_LSB
C:000b13 23aa      	tst		REG_X_LSB
         
C:000b14 f431      	brne		exec_command_type_T_enable_traces
         
          exec_command_type_T_disable_traces:
C:000b15 9100 0168 	lds		REG_TEMP_R16, G_DS18B20_FLAGS
C:000b17 7f07      	cbr		REG_TEMP_R16, FLG_DS18B20_TRACE_MSK
C:000b18 9300 0168 	sts		G_DS18B20_FLAGS, REG_TEMP_R16
C:000b1a c008      	rjmp		exec_command_type_T_ok
         
          exec_command_type_T_enable_traces:
C:000b1b 9100 0168 	lds		REG_TEMP_R16, G_DS18B20_FLAGS
C:000b1d 6008      	sbr		REG_TEMP_R16, FLG_DS18B20_TRACE_MSK
C:000b1e 9300 0168 	sts		G_DS18B20_FLAGS, REG_TEMP_R16
C:000b20 c002      	rjmp		exec_command_type_T_ok
         
          exec_command_type_T_ko:
C:000b21 d947      	rcall		uos_print_command_ko
C:000b22 c001      	rjmp		exec_command_type_T_rtn
         
          exec_command_type_T_ok:
C:000b23 d940      	rcall		uos_print_command_ok
         
          exec_command_type_T_rtn:
C:000b24 9508      	ret
         ; ----------
         
         ; End of file
         
          
          #endif
         
          .include		"ATtiny85_uOS+DS18B20_1_Wire.asm"
         ; "$Id: ATtiny85_uOS+DS18B20_1_Wire.asm,v 1.10 2025/12/14 10:57:52 administrateur Exp $"
         
         ; ---------
         ; ds18b20_write_8_bits_command
         ; ---------
         ; Emission d'une commande de 8 bits contenue dans 'REG_TEMP_R16'
         ; => LSB en tete
         ; ---------
          ds18b20_write_8_bits_command:
C:000b25 e028      	ldi		REG_TEMP_R18, NBR_BITS_TO_SHIFT
         
          ds18b20_write_8_bits_command_loop:
C:000b26 9507      	ror		REG_TEMP_R16
C:000b27 d00d      	rcall		ds18b20_write_bit
         
C:000b28 952a      	dec		REG_TEMP_R18
C:000b29 f7e1      	brne		ds18b20_write_8_bits_command_loop
         
C:000b2a 9508      	ret
         ; ---------
         
         ; ---------
         ; ds18b20_read_response_72_bits:
         ; ds18b20_read_response_64_bits:
         ; ---------
         ; Lecture de la reponse sur 64 bits disponible dans [G_DS18B20_BYTES_RESP, ..., (G_DS18B20_BYTES_RESP + 7)]
         ; Lecture de la reponse sur 72 bits disponible dans [G_DS18B20_BYTES_RESP, ..., (G_DS18B20_BYTES_RESP + 8)]
         ; ---------
          ds18b20_read_response_72_bits:
C:000b2b e039      	ldi		REG_TEMP_R19, (72 / 8)
C:000b2c e428      	ldi		REG_TEMP_R18, 72
C:000b2d c002      	rjmp		ds18b20_read_response_x_bits_loop
         
          ds18b20_read_response_64_bits:
C:000b2e e038      	ldi		REG_TEMP_R19, (64 / 8)
C:000b2f e420      	ldi		REG_TEMP_R18, 64
         
          ds18b20_read_response_x_bits_loop:
C:000b30 d011      	rcall		ds18b20_read_bit
         
C:000b31 d01e      	rcall		ds18b20_shift_right_resp
         
C:000b32 952a      	dec		REG_TEMP_R18
C:000b33 f7e1      	brne		ds18b20_read_response_x_bits_loop
         
C:000b34 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission d'un bit contenu dans la Carry:
         ; - L'emission d'un bit a 0 consiste a presenter une pulse --\_____/---
         ;   avec un etat bas d'une duree superieure a 60uS (65uS implemente)
         ; - L'emission d'un bit a 1 consiste a presenter une pulse --\__/---
         ;   avec un etat bas d'une duree > 1 uS et < 15uS (10uS implemente)
         ; - L'etat haut est maintenu jusqu'a une duree de 70uS 
         ; ---------
          ds18b20_write_bit:
C:000b35 f030      	brcs		ds18b20_write_bit_1
         
          ds18b20_write_bit_0:							; Pulse --\____/--
C:000b36 9ac3      	sbi		PORTB, IDX_BIT_LED_GREEN	; Extinction Led GREEN
C:000b37 98c2      	cbi		PORTB, IDX_BIT_1_WIRE
         
C:000b38 d02e      	rcall		delay_65uS
         
C:000b39 9ac2      	sbi		PORTB, IDX_BIT_1_WIRE
         
C:000b3a d038      	rcall		delay_5uS
C:000b3b c005      	rjmp		ds18b20_write_bit_end
         
          ds18b20_write_bit_1:							; Pulse --\_/-----
C:000b3c 98c2      	cbi		PORTB, IDX_BIT_1_WIRE
         
C:000b3d   +  	_CALL		uos_delay_10uS
C:000b3d 940e 00d9 call		uos_delay_10uS
         
C:000b3f 9ac2      	sbi		PORTB, IDX_BIT_1_WIRE
         
C:000b40 d027      	rcall		delay_60uS
         
          ds18b20_write_bit_end:
C:000b41 9508      	ret
         ; ---------
         
         ; ---------
         ; La reception d'un bit retourne dans la Carry:
         ; - Mise a l'etat bas durant 5uS (la norme specifie > 1uS et < 15uS)
         ; - Attendre 10 uS avant la lecture de l'entree presentee par un esclave
         ; - Lecture a 0 ou 1 de l'entree
         ; ---------
         ; Lecture d'un bit disponible dans la Carry
         ;
         ; Chronograme
         ; - DDRB<2>:  ..../---------\_______/----------
         ; - PORTB<2>: ----\___/----------read----------
         ;                  3uS       10uS       55uS
         ;
         ; Pseudo Code:
         ;
         ;       DIRECT_MODE_OUTPUT(reg, mask);
         ;       DIRECT_WRITE_LOW(reg, mask);
         ;       delayMicroseconds(3);
         ;       DIRECT_MODE_INPUT(reg, mask);   // let pin float, pull up will raise
         ;       delayMicroseconds(10);
         ;       r = DIRECT_READ(reg, mask);
         ;       delayMicroseconds(55);
         ;     
         ; ---------
          ds18b20_read_bit:
C:000b42 9aba      	sbi		DDRB, IDX_BIT_1_WIRE			; <PORTB<2> en sortie
         
         	; Pulse --\_/---- durant 3uS
C:000b43 9ac3      	sbi		PORTB, IDX_BIT_LED_GREEN	; Extinction Led GREEN
C:000b44 98c2      	cbi		PORTB, IDX_BIT_1_WIRE
         
C:000b45 d02d      	rcall		delay_5uS
         
C:000b46 9ac2      	sbi		PORTB, IDX_BIT_1_WIRE
         
C:000b47 98ba      	cbi		DDRB, IDX_BIT_1_WIRE			; <PORTB<2> en entree
         
C:000b48   +  	_CALL		uos_delay_10uS					; Attente de 10uS avant de lire le port
C:000b48 940e 00d9 call		uos_delay_10uS
         
         	; Lecture au temps (t0 + 15uS)
C:000b4a 9488      	clc											; <PORTB<2> a priori a 0 ...
C:000b4b 99b2      	sbic		PINB, IDX_BIT_1_WIRE
C:000b4c 9408      	sec											; ... et non <PORTB<2> a 1
         
         	;rcall		delay_65uS						; Attente de 65uS avant de sortir (total: 73uS)
C:000b4d d01b      	rcall		delay_55uS						; Attente de 55uS avant de sortir (total: 70uS)
         
C:000b4e 9aba      	sbi		DDRB, IDX_BIT_1_WIRE			; <PORTB<2> en sortie avant de sortir
         
C:000b4f 9508      	ret
         ; ---------
         
         ; ---------
         ; Propagation de la Carry et decalage d'un bit a droite
         ; sur les 'REG_TEMP_R19' bytes a partir de 'G_DS18B20_BYTES_RESP'
         ; ou a partir de 'G_DS18B20_BYTES_ROM'
         ; ---------
          ds18b20_shift_right_resp:
         ; ---------
C:000b50 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_RESP)
C:000b51 e7cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_RESP)
C:000b52 c002      	rjmp		ds18b20_shift_right
         
          ds18b20_shift_right_rom:
C:000b53 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_ROM)
C:000b54 e8cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_ROM)
         	;rjmp		ds18b20_shift_right
         
          ds18b20_shift_right:
         
C:000b55 933f      	push		REG_TEMP_R19
         
          ds18b20_shift_right_resp_loop:
          #if USE_DS18B20_TRACE
          #endif
         
C:000b56 8108      	ld			REG_TEMP_R16, Y
         
          #if USE_DS18B20_TRACE
          #endif
         
C:000b57 9507      	ror		REG_TEMP_R16
C:000b58 9309      	st			Y+, REG_TEMP_R16	
         
C:000b59 953a      	dec		REG_TEMP_R19
C:000b5a f7d9      	brne		ds18b20_shift_right_resp_loop
         
C:000b5b 913f      	pop		REG_TEMP_R19
C:000b5c 9508      	ret
         ; ---------
         
         ; ---------
         ; Propagation de la Carry et decalage d'un bit a droite
         ; sur les 'REG_TEMP_R19' bytes a partir de 'G_DS18B20_BYTES_SEND'
         ; ---------
          ds18b20_shift_right_send:
         ; ---------
C:000b5d e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_SEND)
C:000b5e e6cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_SEND)
         
C:000b5f 933f      	push		REG_TEMP_R19
         
          ds18b20_shift_right_send_loop:
C:000b60 8108      	ld			REG_TEMP_R16, Y
         
C:000b61 9507      	ror		REG_TEMP_R16
C:000b62 9309      	st			Y+, REG_TEMP_R16	
         
C:000b63 953a      	dec		REG_TEMP_R19
C:000b64 f7d9      	brne		ds18b20_shift_right_send_loop
         
C:000b65 913f      	pop		REG_TEMP_R19
C:000b66 9508      	ret
         ; ---------
         
         ; ---------
         ; Routines d'attente
         ;
         ; Remarque: Les routines d'attente de 1uS et 10uS sont implementees dans uOS
         ; ---------
          delay_65uS:
C:000b67 d00b      	rcall		delay_5uS
         
          delay_60uS:
C:000b68 d00a      	rcall		delay_5uS
         
          delay_55uS:
C:000b69   +  	_CALL		uos_delay_10uS
C:000b69 940e 00d9 call		uos_delay_10uS
C:000b6b   +  	_CALL		uos_delay_10uS
C:000b6b 940e 00d9 call		uos_delay_10uS
C:000b6d   +  	_CALL		uos_delay_10uS
C:000b6d 940e 00d9 call		uos_delay_10uS
C:000b6f   +  	_CALL		uos_delay_10uS
C:000b6f 940e 00d9 call		uos_delay_10uS
C:000b71   +  	_CALL		uos_delay_10uS
C:000b71 940e 00d9 call		uos_delay_10uS
         
          delay_5uS:
C:000b73   +  	_CALL		uos_delay_1uS
C:000b73 940e 00d4 call		uos_delay_1uS
C:000b75   +  	_CALL		uos_delay_1uS
C:000b75 940e 00d4 call		uos_delay_1uS
C:000b77   +  	_CALL		uos_delay_1uS
C:000b77 940e 00d4 call		uos_delay_1uS
C:000b79   +  	_CALL		uos_delay_1uS
C:000b79 940e 00d4 call		uos_delay_1uS
C:000b7b   +  	_CALL		uos_delay_1uS
C:000b7b 940e 00d4 call		uos_delay_1uS
         
C:000b7d 9508      	ret
         ; ---------
         
         ; End of file
         
          
         
          #ifndef USE_MINIMALIST_ADDONS
          .include		"ATtiny85_uOS+DS18B20_Button.asm"
         ; "$Id: ATtiny85_uOS+DS18B20_Button.asm,v 1.1 2025/12/08 18:51:48 administrateur Exp $"
         
         ; Prolongation de l'appui bouton
         
          .cseg
         
         ; ---------
          exec_button_ds18b20:
         ; Emission du prompt de l'appui button
C:000b7e e1f7      	ldi		REG_Z_MSB, ((text_ds18b20_button << 1) / 256)
C:000b7f e0e6      	ldi		REG_Z_LSB, ((text_ds18b20_button << 1) % 256)
C:000b80 d812      	rcall		push_text_in_fifo_tx
         
C:000b81 6490      	sbr		REG_FLAGS_1, FLG_1_UART_FIFO_TX_TO_SEND_MSK
         
C:000b82 9508      	ret
         ; ---------
         
          text_ds18b20_button:
          .db	"### DS18B20: Button action", CHAR_LF, CHAR_NULL
C:000B83 23232320445331384232303A20427574746F6E20616374696F6E0A00
         
         ; End of file
          
          #endif
         
          .include		"ATtiny85_DS18B20_1_Wire_Commands.asm"
         ; "$Id: ATtiny85_DS18B20_1_Wire_Commands.asm,v 1.23 2025/12/17 22:40:58 administrateur Exp $
         
          .include		"ATtiny85_DS18B20_1_Wire_Commands.h"
         ; "$Id: ATtiny85_DS18B20_1_Wire_Commands.h,v 1.3 2025/12/14 18:05:27 administrateur Exp $"
         
          #define	DS18B20_CMD_READ_ROM					0x33	; Lecture du registre ROM de 64 bits
          #define	DS18B20_CMD_MATCH_ROM				0x55	; Match du registre ROM de 64 bits
          #define	DS18B20_CMD_CONVERT_T				0x44	; Conversion de la temperature
          #define	DS18B20_CMD_COPY_SCRATCHPAD		0x48	; Recopie du Scratchpad dans l'EEPROM
          #define	DS18B20_CMD_WRITE_SCRATCHPAD		0x4E	; Ecriture de la Scratchpad
          #define	DS18B20_CMD_READ_POWER_SUPPLY		0xB4	; Lecture Power Mode
          #define	DS18B20_CMD_RECALL_EEPROM			0xB8	; Recopie de l'EEPROM dans le Scratchpad
          #define	DS18B20_CMD_READ_SCRATCHPAD		0xBE	; Lecture de la Scratchpad
         ;#define	DS18B20_CMD_SKIP_ROM					0xCC	; Skip du registre ROM de 64 bits
         
         ; Pas de recherche alarme si 'USE_MINIMALIST_ADDONS'
         ;#ifndef USE_MINIMALIST_ADDONS
          #define	DS18B20_CMD_SEARCH_ALARM			0xEC	; Recherche du registre ROM sur le bus qui est en alarme
         ;#endif
         
          #define	DS18B20_CMD_SEARCH_ROM				0xF0	; Recherche du registre ROM sur le bus
         
         ; End of file
         
          
         
         ; Gestion des commandes 1-Wire:
         ; * Commandes ROM standards
         ; - Read Rom [33h]
         ; - Match Rom [55H]
         ; - Search ROM [F0h]
         ;
         ; * Commandes specifiques au DS18B20
         ; - Convert T [44h]
         ; - Read Scratchpad [BEh]
         ; - Copy Scratchpad [48h]
         ; - Write Scratchpad [4Eh]
         ; - Alarm Search [ECh]
         ;
         
         ; ---------
         ; CMD_READ_ROM
         ; ---------
         ; Lecture du registre ROM de 64 bits disponible dans [G_DS18B20_BYTES_RESP, ..., (G_DS18B20_BYTES_RESP + 7)]
         ; ---------
          ds18b20_read_rom:
C:000b91 94f8      	cli
         
C:000b92 e303      	ldi		REG_TEMP_R16, DS18B20_CMD_READ_ROM
C:000b93 df91      	rcall		ds18b20_write_8_bits_command
C:000b94 df99      	rcall		ds18b20_read_response_64_bits
         
          #ifndef USE_MINIMALIST_ADDONS
C:000b95 e024      	ldi		REG_TEMP_R18, 4
C:000b96 dc70      	rcall		ds18b20_print_response
          #endif
         
         	; Test du CRC8
C:000b97 e008      	ldi		REG_TEMP_R16, NBR_BITS_TO_SHIFT			; 8 bytes pour le calcul sur les ROM
C:000b98 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_RESP)	; Adresse de 'G_DS18B20_BYTES_RESP'
C:000b99 e7cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_RESP)
         
C:000b9a 94e8      	clt															; Test du CRC8 avec non prise en compte du 1st byte
C:000b9b dd52      	rcall		ds18b20_crc8_bypass
         
C:000b9c 9468      	set															; A priori, CRC8 recu egal a celui attendu ...
C:000b9d 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
C:000b9f 9110 017f 	lds		REG_TEMP_R17, G_DS18B20_BYTES_RESP
C:000ba1 1301      	cpse		REG_TEMP_R16, REG_TEMP_R17
C:000ba2 94e8      	clt															; ... et non CRC8 recu different de celui attendu
         	; Fin: Test du CRC8
         
C:000ba3 9478      	sei
C:000ba4 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_CONVERT_T
         ; ---------
         ; Conversion de la temperature disponible dans [G_DS18B20_BYTES_RESP, ..., (G_DS18B20_BYTES_RESP + 7)]
         ; ---------
          ds18b20_convert_t:
C:000ba5 94f8      	cli
         
C:000ba6 e404      	ldi		REG_TEMP_R16, DS18B20_CMD_CONVERT_T
C:000ba7 df7d      	rcall		ds18b20_write_8_bits_command
C:000ba8 df82      	rcall		ds18b20_read_response_72_bits
         
          #ifndef USE_MINIMALIST_ADDONS
C:000ba9 e403      	ldi		REG_TEMP_R16, 'C'
C:000baa 940e 03a0 	call		uos_push_1_char_in_fifo_tx_skip
C:000bac e025      	ldi		REG_TEMP_R18, 5
C:000bad dc59      	rcall		ds18b20_print_response
          #endif
         
C:000bae 9478      	sei
C:000baf 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_READ_SCRATCHPAD
         ; ---------
         ; ---------
         ; Lecture de la Scratchpad disponible dans [G_DS18B20_BYTES_RESP, ..., (G_DS18B20_BYTES_RESP + 7)]
         ; ---------
          ds18b20_read_scratchpad:
C:000bb0 94f8      	cli
         
C:000bb1 eb0e      	ldi		REG_TEMP_R16, DS18B20_CMD_READ_SCRATCHPAD
C:000bb2 df72      	rcall		ds18b20_write_8_bits_command
C:000bb3 df77      	rcall		ds18b20_read_response_72_bits
         
          #ifndef USE_MINIMALIST_ADDONS
C:000bb4 e504      	ldi		REG_TEMP_R16, 'T'
C:000bb5 940e 03a0 	call		uos_push_1_char_in_fifo_tx_skip
C:000bb7 e025      	ldi		REG_TEMP_R18, 5
C:000bb8 dc4e      	rcall		ds18b20_print_response
          #endif
         
         	; Test du CRC8
C:000bb9 e009      	ldi		REG_TEMP_R16, 9								; 9 bytes pour le calcul sur les valeurs lues
C:000bba e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_RESP)	; Adresse de 'G_DS18B20_BYTES_RESP'
C:000bbb e7cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_RESP)
         
C:000bbc 94e8      	clt															; Test du CRC8 avec non prise en compte du 1st byte
C:000bbd dd30      	rcall		ds18b20_crc8_bypass
         
C:000bbe 9468      	set															; A priori, CRC8 recu egal a celui attendu ...
C:000bbf 9100 0068 	lds		REG_TEMP_R16, G_CALC_CRC8
C:000bc1 9110 017f 	lds		REG_TEMP_R17, G_DS18B20_BYTES_RESP
C:000bc3 1301      	cpse		REG_TEMP_R16, REG_TEMP_R17
C:000bc4 94e8      	clt															; ... et non CRC8 recu different de celui attendu
         
C:000bc5 f46e      	brtc		ds18b20_read_scratchpad_ko
         	; Fin: Test du CRC8
         
          ds18b20_read_scratchpad_ok:
         	; Construction de la trame 
C:000bc6 9110 0197 	lds		REG_TEMP_R17, G_BUS_1_WIRE_FLAGS
C:000bc8 fd12      	sbrc		REG_TEMP_R17, FLG_DS18B20_FRAMES_IDX
C:000bc9 ddbf      	rcall		build_frame_infos
         
          #ifndef USE_MINIMALIST_ADDONS
C:000bca e40f      	ldi		REG_TEMP_R16, 'O'
C:000bcb   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000bcb 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000bcd e60b      	ldi		REG_TEMP_R16, 'k'
C:000bce   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000bce 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000bd0 db0e      	rcall		uos_print_line_feed_skip
          #endif
         
C:000bd1 c008      	rjmp		ds18b20_read_scratchpad_end
C:000bd2 0000      	nop
         
          ds18b20_read_scratchpad_ko:
          #ifndef USE_MINIMALIST_ADDONS
C:000bd3 e40b      	ldi		REG_TEMP_R16, 'K'
C:000bd4   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000bd4 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000bd6 e60f      	ldi		REG_TEMP_R16, 'o'
C:000bd7   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000bd7 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000bd9 db05      	rcall		uos_print_line_feed_skip
          #endif
         
          ds18b20_read_scratchpad_end:
C:000bda 9478      	sei
C:000bdb 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_MATCH_ROM
         ; ---------
         ; Match d'un registre ROM de 64 bits depuis [G_DS18B20_BYTES_SEND, ..., (G_DS18B20_BYTES_SEND + 7)]
         ; => Test avec "0x53 08 22 53 97 80 B5 28 (1st capteur) 'ds18b20_match_rom_1'
         ;              "0x47 06 22 60 20 BB C8 28 (2nd capteur) 'ds18b20_match_rom_2'
         ;              "0x2B 06 22 60 43 40 56 28 (3rd capteur) 'ds18b20_match_rom_3'
         ; ---------
          ds18b20_match_rom:
         	; Emission de l'index du ROM #N
C:000bdc 93bf      	push		REG_X_MSB
C:000bdd 93af      	push		REG_X_LSB
         
         	; Get the index of ROM in alarm
C:000bde e0b1      	ldi		REG_X_MSB, high(G_DS18B20_BYTES_SEND)
C:000bdf e6af      	ldi		REG_X_LSB, low(G_DS18B20_BYTES_SEND)
C:000be0 dd6a      	rcall		ds18b20_get_rom_idx
         
         	; Update index of ROM for build frame
C:000be1 9300 01a3 	sts		G_DS18B20_ROM_IDX, REG_TEMP_R16
         
C:000be3 930f      	push		REG_TEMP_R16
C:000be4 930f      	push		REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_ADDONS
C:000be5 e40d      	ldi		REG_TEMP_R16, 'M'
C:000be6 940e 03a0 	call		uos_push_1_char_in_fifo_tx_skip
          #endif
         
C:000be8 91af      	pop		REG_X_LSB
         
          #ifndef USE_MINIMALIST_ADDONS
C:000be9 daff      	rcall		uos_print_1_byte_hexa_skip
C:000bea daf4      	rcall		uos_print_line_feed_skip
          #endif
         
C:000beb 910f      	pop		REG_TEMP_R16
C:000bec 91af      	pop		REG_X_LSB
C:000bed 91bf      	pop		REG_X_MSB
         	; Fin: Emission du ROM #N
         
          #ifndef USE_MINIMALIST_ADDONS
C:000bee dc21      	rcall		ds18b20_print_rom_send
          #endif
         
         	; Attente du vidage de la FIFO/Tx
C:000bef   +  	_CALL		uos_fifo_tx_to_send_sync
C:000bef 940e 03bd call		uos_fifo_tx_to_send_sync
         
C:000bf1 94f8      	cli
         
C:000bf2 e505      	ldi		REG_TEMP_R16, DS18B20_CMD_MATCH_ROM
C:000bf3 df31      	rcall		ds18b20_write_8_bits_command
         
C:000bf4 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_SEND + 8)
C:000bf5 e7c7      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_SEND + 8)
         
C:000bf6 910a      	ld			REG_TEMP_R16, -Y
C:000bf7 df2d      	rcall		ds18b20_write_8_bits_command
C:000bf8 910a      	ld			REG_TEMP_R16, -Y
C:000bf9 df2b      	rcall		ds18b20_write_8_bits_command
C:000bfa 910a      	ld			REG_TEMP_R16, -Y
C:000bfb df29      	rcall		ds18b20_write_8_bits_command
C:000bfc 910a      	ld			REG_TEMP_R16, -Y
C:000bfd df27      	rcall		ds18b20_write_8_bits_command
C:000bfe 910a      	ld			REG_TEMP_R16, -Y
C:000bff df25      	rcall		ds18b20_write_8_bits_command
C:000c00 910a      	ld			REG_TEMP_R16, -Y
C:000c01 df23      	rcall		ds18b20_write_8_bits_command
C:000c02 910a      	ld			REG_TEMP_R16, -Y
C:000c03 df21      	rcall		ds18b20_write_8_bits_command
C:000c04 910a      	ld			REG_TEMP_R16, -Y
C:000c05 df1f      	rcall		ds18b20_write_8_bits_command
         
C:000c06 9478      	sei
         
C:000c07 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_SEARCH_ROM
         ; ---------
         ; ds18b20_search_rom: Recherche des registres ROM sur le bus
         ; ---------
         ; - Chaque passe consiste a remplacer chaque bit "inconnu" (retour 0x00 des 2 'ds18b20_read_bit')
         ;   par celui du pattern (G_DS18B20_PATTERN) initialise a 0x00 et qui sera incremente
         ;   a la fin de la passe a l'issue de laquelle un ROM a ete identifie avec ses 64 bits
         ;
         ; - Le ROM est conserve apres sa verification @ CRC
         ;
         ; - Exemple de ROM determines avec 'G_DS18B20_NBR_BITS_RETRY' egal a 8
         ;   car apres tests, il est constates qu'il y a au plus 3 bits inconnues a discriminer
         ;   => Justification de l'initialisation a '((1 << 3) - 1)'
         ;
         ; 0x4706226020BBC828 1st capteur DS18B20 avec le pattern initial b0000 0000 -> 2 bits inconnus
         ;                                                                b0000 0100
         ; 0xCB062260451C7328 2rd capteur DS18B20 avec le pattern initial b0000 0111 -> 2 bits inconnus
         ;                                                                b0000 0011
         ; 0x2B06226043405628 3rd capteur DS18B20 avec le pattern initial b0000 0110 -> 2 bits inconnus
         ;                                                                b0000 0010
         ; 0x530822539780B528 4th capteur DS18B20 avec le pattern initial b0000 0101 -> 3 bits inconnus
         ; 0xE4062260238BB928 5th capteur DS18B20 avec le pattern initial b0000 0001 -> 3 bits inconnus
         ;
         ; ---------
          ds18b20_search_rom:
         	; Initilisation pour x passes durant lesquelles un meme ROM peut etre trouve plusieurs fois
C:000c08 e007      	ldi		REG_TEMP_R16, ((1 << 3) - 1)				; 8 passes + Pattern initial b0000 0111
C:000c09 9300 019c 	sts		G_DS18B20_NBR_BITS_RETRY, REG_TEMP_R16
C:000c0b 9300 019d 	sts		G_DS18B20_PATTERN, REG_TEMP_R16
         
C:000c0d 2700      	clr		REG_TEMP_R16
C:000c0e 9300 01a0 	sts		G_DS18B20_NBR_ROM_FOUND, REG_TEMP_R16
C:000c10 9300 01a2 	sts		G_DS18B20_ROM_IDX_WRK, REG_TEMP_R16
C:000c12 9300 019f 	sts		G_DS18B20_NBR_BITS_0_1_MAX, REG_TEMP_R16
         
         	; Effacement des ROM a rechercher
C:000c14 dc11      	rcall		ds18b20_clear_rom	
         
         	;lds		REG_TEMP_R16, DS18B20_NBR_ROM_GESTION
C:000c15 e008      	ldi		REG_TEMP_R16, DS18B20_NBR_ROM_GESTION
C:000c16 2300      	tst		REG_TEMP_R16
C:000c17 f401      	brne		ds18b20_search_rom_cont_d
         
          ds18b20_search_rom_cont_d:
C:000c18 2700      	clr		REG_TEMP_R16
C:000c19 9300 019e 	sts		G_DS18B20_NBR_BITS_0_1, REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_ADDONS
C:000c1b e500      	ldi		REG_TEMP_R16, 'P'
C:000c1c   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000c1c 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000c1e 91a0 019d 	lds		REG_X_LSB, G_DS18B20_PATTERN
C:000c20 dac8      	rcall		uos_print_1_byte_hexa_skip
         
C:000c21 dabd      	rcall		uos_print_line_feed_skip
C:000c22   +  	_CALL		uos_fifo_tx_to_send_sync
C:000c22 940e 03bd call		uos_fifo_tx_to_send_sync
          #endif
         
         	; Reset
C:000c24 dbc5      	rcall		ds18b20_reset
         
C:000c25 94f8      	cli
         
C:000c26 ef00      	ldi		REG_TEMP_R16, DS18B20_CMD_SEARCH_ROM
C:000c27 defd      	rcall		ds18b20_write_8_bits_command
         
C:000c28 e420      	ldi		REG_TEMP_R18, 64		; Searching the ROM register
         
          ds18b20_search_rom_loop:
C:000c29 2711      	clr		REG_TEMP_R17
         
C:000c2a df17      	rcall		ds18b20_read_bit
         
C:000c2b f408      	brcc		ds18b20_search_rom_loop_a
C:000c2c 6011      	sbr		REG_TEMP_R17, MSK_BIT0
         
          ds18b20_search_rom_loop_a:
C:000c2d e130      	ldi		REG_TEMP_R19, 16
C:000c2e df21      	rcall		ds18b20_shift_right_resp
         
C:000c2f df12      	rcall		ds18b20_read_bit
         
C:000c30 f408      	brcc		ds18b20_search_rom_loop_b
C:000c31 6012      	sbr		REG_TEMP_R17, MSK_BIT1
         
          ds18b20_search_rom_loop_b:
C:000c32 e130      	ldi		REG_TEMP_R19, 16
C:000c33 df1c      	rcall		ds18b20_shift_right_resp
         
C:000c34 3010      	cpi		REG_TEMP_R17, 0x00		; Presence de '0' et de '1'
C:000c35 f491      	brne		ds18b20_search_rom_loop_c
         
         	; Comptabilisation du nombre de bits inconnus
C:000c36 9130 019e 	lds		REG_TEMP_R19, G_DS18B20_NBR_BITS_0_1
C:000c38 9533      	inc		REG_TEMP_R19
C:000c39 9330 019e 	sts		G_DS18B20_NBR_BITS_0_1, REG_TEMP_R19
         
C:000c3b 9140 019f 	lds		REG_TEMP_R20, G_DS18B20_NBR_BITS_0_1_MAX
C:000c3d 1734      	cp			REG_TEMP_R19, REG_TEMP_R20
C:000c3e f012      	brmi		ds18b20_search_rom_loop_d
         
C:000c3f 9330 019f 	sts		G_DS18B20_NBR_BITS_0_1_MAX, REG_TEMP_R19
         
          ds18b20_search_rom_loop_d:
         
         	; Ecriture de 'G_DS18B20_PATTERN<0>'
C:000c41 9130 019d 	lds		REG_TEMP_R19, G_DS18B20_PATTERN
C:000c43 9536      	lsr		REG_TEMP_R19
C:000c44 9330 019d 	sts		G_DS18B20_PATTERN, REG_TEMP_R19
         
C:000c46 f440      	brcc		ds18b20_search_rom_loop_0
C:000c47 c00c      	rjmp		ds18b20_search_rom_loop_1
         
          ds18b20_search_rom_loop_c:
C:000c48 3012      	cpi		REG_TEMP_R17, 0x02		; Presence de '0' uniquement
C:000c49 f029      	breq		ds18b20_search_rom_loop_0
         
C:000c4a 3011      	cpi		REG_TEMP_R17, 0x01		; Presence de '1' uniquement
C:000c4b f041      	breq		ds18b20_search_rom_loop_1
         
C:000c4c 3013      	cpi		REG_TEMP_R17, 0x03		; No capteur
C:000c4d f071      	breq		ds18b20_search_rom_no_device
C:000c4e c018      	rjmp		ds18b20_search_rom_end
         
          ds18b20_search_rom_loop_0:
C:000c4f 9488      	clc
C:000c50 e038      	ldi		REG_TEMP_R19, NBR_BITS_TO_SHIFT
C:000c51 df01      	rcall		ds18b20_shift_right_rom
         
C:000c52 9488      	clc
C:000c53 c004      	rjmp		ds18b20_search_rom_loop_01
         
          ds18b20_search_rom_loop_1:
C:000c54 9408      	sec
C:000c55 e038      	ldi		REG_TEMP_R19, NBR_BITS_TO_SHIFT
C:000c56 defc      	rcall		ds18b20_shift_right_rom
         
C:000c57 9408      	sec
         	;rjmp		ds18b20_search_rom_loop_01
         
          ds18b20_search_rom_loop_01:
         
C:000c58 dedc      	rcall		ds18b20_write_bit	
         
C:000c59 952a      	dec		REG_TEMP_R18
C:000c5a f671      	brne		ds18b20_search_rom_loop
         
C:000c5b c00b      	rjmp		ds18b20_search_rom_end
         
          ds18b20_search_rom_no_device:
          #ifndef USE_MINIMALIST_ADDONS
C:000c5c e40e      	ldi		REG_TEMP_R16, 'N'
C:000c5d   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000c5d 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
          #endif
         
          ds18b20_search_rom_abort:
C:000c5f 9478      	sei
         
C:000c60 e4a0      	ldi		REG_X_LSB, 64
C:000c61 1ba2      	sub		REG_X_LSB, REG_TEMP_R18
         
          #ifndef USE_MINIMALIST_ADDONS
C:000c62 da86      	rcall		uos_print_1_byte_hexa_skip
          #endif
         
C:000c63 2fa1      	mov		REG_X_LSB, REG_TEMP_R17
         
          #ifndef USE_MINIMALIST_ADDONS
C:000c64 da84      	rcall		uos_print_1_byte_hexa_skip
C:000c65 da79      	rcall		uos_print_line_feed_skip
          #endif
         
C:000c66 c02b      	rjmp		ds18b20_search_rom_rtn
         
          ds18b20_search_rom_end:
C:000c67 9478      	sei
         
C:000c68 e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
         
          #ifndef USE_MINIMALIST_ADDONS
C:000c69 db9d      	rcall		ds18b20_print_response
          #endif
         
C:000c6a e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
         
          #ifndef USE_MINIMALIST_ADDONS
C:000c6b dbae      	rcall		ds18b20_print_rom
          #endif
         
         	; Copy of ROM found in 'G_DS18B20_BYTES_ROM' to 'G_DS18B20_ROM_0' @ 'G_DS18B20_ROM_IDX'
         	; => 'REG_TEMP_R16' contient le rang du CRC du ROM trouve ou 0xff si pas trouve
C:000c6c dbd3      	rcall		ds18b20_compare_rom
         
C:000c6d 3f0f      	cpi		REG_TEMP_R16, 0xff
C:000c6e f451      	brne		ds18b20_search_rom_found
         
C:000c6f dbbe      	rcall		ds18b20_copy_rom
         
C:000c70 9100 01a0 	lds		REG_TEMP_R16, G_DS18B20_NBR_ROM_FOUND
C:000c72 9503      	inc		REG_TEMP_R16
C:000c73 9300 01a0 	sts		G_DS18B20_NBR_ROM_FOUND, REG_TEMP_R16
         
C:000c75 9110 01a1 	lds		REG_TEMP_R17, G_DS18B20_NBR_ROM_MAX
C:000c77 1701      	cp			REG_TEMP_R16, REG_TEMP_R17
C:000c78 f4ca      	brpl		ds18b20_search_rom_rtn
         
          ds18b20_search_rom_found:
          #ifndef USE_MINIMALIST_ADDONS
C:000c79 e40e      	ldi		REG_TEMP_R16, 'N'
C:000c7a   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000c7a 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
          #endif
         
C:000c7c 91a0 019c 	lds		REG_X_LSB, G_DS18B20_NBR_BITS_RETRY
C:000c7e da6a      	rcall		uos_print_1_byte_hexa_skip
         
          #ifndef USE_MINIMALIST_ADDONS
C:000c7f e30f      	ldi		REG_TEMP_R16, '?'
C:000c80   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000c80 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
         
C:000c82 91a0 019e 	lds		REG_X_LSB, G_DS18B20_NBR_BITS_0_1
C:000c84 da64      	rcall		uos_print_1_byte_hexa_skip
         
C:000c85 da59      	rcall		uos_print_line_feed_skip
          #endif
         
C:000c86   +  	_CALL		uos_fifo_tx_to_send_sync
C:000c86 940e 03bd call		uos_fifo_tx_to_send_sync
         
C:000c88 9130 019c 	lds		REG_TEMP_R19, G_DS18B20_NBR_BITS_RETRY
C:000c8a 953a      	dec		REG_TEMP_R19
C:000c8b 9330 019c 	sts		G_DS18B20_NBR_BITS_RETRY, REG_TEMP_R19
C:000c8d 3f3f      	cpi		REG_TEMP_R19, 0xFF
C:000c8e f019      	breq		ds18b20_search_rom_rtn		
         
C:000c8f 9330 019d 	sts		G_DS18B20_PATTERN, REG_TEMP_R19
         
C:000c91 cf86      	rjmp		ds18b20_search_rom_cont_d
         
          ds18b20_search_rom_rtn:
         
C:000c92 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_WRITE_SCRATCHPAD
         ; ---------
          ds18b20_write_scratchpad:
C:000c93 94f8      	cli
         
C:000c94 932f      	push		REG_TEMP_R18
C:000c95 931f      	push		REG_TEMP_R17
C:000c96 930f      	push		REG_TEMP_R16
         
C:000c97 e40e      	ldi		REG_TEMP_R16, DS18B20_CMD_WRITE_SCRATCHPAD
C:000c98 de8c      	rcall		ds18b20_write_8_bits_command
         
C:000c99 910f      	pop		REG_TEMP_R16
C:000c9a de8a      	rcall		ds18b20_write_8_bits_command
         
C:000c9b 911f      	pop		REG_TEMP_R17
C:000c9c 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:000c9d de87      	rcall		ds18b20_write_8_bits_command
         
C:000c9e 912f      	pop		REG_TEMP_R18
C:000c9f 2f02      	mov		REG_TEMP_R16, REG_TEMP_R18
C:000ca0 de84      	rcall		ds18b20_write_8_bits_command
         
C:000ca1 9478      	sei
         
C:000ca2 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_COPY_SCRATCHPAD
         ; ---------
          ds18b20_copy_scratchpad:
C:000ca3 94f8      	cli
C:000ca4 e408      	ldi		REG_TEMP_R16, DS18B20_CMD_COPY_SCRATCHPAD
C:000ca5 de7f      	rcall		ds18b20_write_8_bits_command
C:000ca6 9478      	sei
         
C:000ca7 9508      	ret
         ; ---------
         
         ; ---------
         ; CMD_SEARCH_ALARM
         ; ---------
         ; Recherche des capteurs en "alarme"; cad si la temperature mesuree
         ; est inferieure a TL ou superieure a TH configurees
         ; ---------
          ds18b20_search_alarm:
         	; Initilisation pour x passes durant lesquelles un meme ROM peut etre trouve plusieurs fois
C:000ca8 e007      	ldi		REG_TEMP_R16, ((1 << 3) - 1)				; 8 passes + Pattern initial b0000 0111
C:000ca9 9300 01c4 	sts		G_DS18B20_ALR_NBR_BITS_RETRY, REG_TEMP_R16
C:000cab 9300 01c5 	sts		G_DS18B20_ALR_PATTERN, REG_TEMP_R16
         
C:000cad 2700      	clr		REG_TEMP_R16
C:000cae 9300 01c8 	sts		G_DS18B20_ALR_NBR_ROM, REG_TEMP_R16
C:000cb0 9300 01ca 	sts		G_DS18B20_ALR_ROM_IDX_WRK, REG_TEMP_R16
C:000cb2 9300 01c7 	sts		G_DS18B20_ALR_NBR_BITS_0_1_MAX, REG_TEMP_R16
C:000cb4 9300 0198 	sts		G_DS18B20_IN_ALARM, REG_TEMP_R16
         
         	; Effacement des ROM a rechercher
C:000cb6 dbd1      	rcall		ds18b20_clear_alr	
         
C:000cb7 9100 01c9 	lds		REG_TEMP_R16, G_DS18B20_ALR_NBR_ROM_MAX
C:000cb9 2300      	tst		REG_TEMP_R16
C:000cba f419      	brne		ds18b20_search_alr_cont_d
         
C:000cbb e008      	ldi		REG_TEMP_R16, DS18B20_NBR_ROM_GESTION
C:000cbc 9300 01c9 	sts		G_DS18B20_ALR_NBR_ROM_MAX, REG_TEMP_R16
         
          ds18b20_search_alr_cont_d:
C:000cbe 2700      	clr		REG_TEMP_R16
C:000cbf 9300 01c6 	sts		G_DS18B20_ALR_NBR_BITS_0_1, REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_ADDONS
C:000cc1 e500      	ldi		REG_TEMP_R16, 'P'
C:000cc2   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000cc2 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000cc4 91a0 01c5 	lds		REG_X_LSB, G_DS18B20_ALR_PATTERN
C:000cc6 da22      	rcall		uos_print_1_byte_hexa_skip
         
C:000cc7 da17      	rcall		uos_print_line_feed_skip
          #endif
         
C:000cc8   +  	_CALL		uos_fifo_tx_to_send_sync
C:000cc8 940e 03bd call		uos_fifo_tx_to_send_sync
         
         	; Reset
C:000cca db1f      	rcall		ds18b20_reset
         
C:000ccb 94f8      	cli
         
C:000ccc ee0c      	ldi		REG_TEMP_R16, DS18B20_CMD_SEARCH_ALARM
C:000ccd de57      	rcall		ds18b20_write_8_bits_command
         
C:000cce e420      	ldi		REG_TEMP_R18, 64		; Searching the ROM register
         
          ds18b20_search_alr_loop:
C:000ccf 2711      	clr		REG_TEMP_R17
         
C:000cd0 de71      	rcall		ds18b20_read_bit
         
C:000cd1 f408      	brcc		ds18b20_search_alr_loop_a
C:000cd2 6011      	sbr		REG_TEMP_R17, MSK_BIT0
         
          ds18b20_search_alr_loop_a:
C:000cd3 e130      	ldi		REG_TEMP_R19, 16
C:000cd4 de7b      	rcall		ds18b20_shift_right_resp
         
C:000cd5 de6c      	rcall		ds18b20_read_bit
         
C:000cd6 f408      	brcc		ds18b20_search_alr_loop_b
C:000cd7 6012      	sbr		REG_TEMP_R17, MSK_BIT1
         
          ds18b20_search_alr_loop_b:
C:000cd8 e130      	ldi		REG_TEMP_R19, 16
C:000cd9 de76      	rcall		ds18b20_shift_right_resp
         
C:000cda 3010      	cpi		REG_TEMP_R17, 0x00		; Presence de '0' et de '1'
C:000cdb f491      	brne		ds18b20_search_alr_loop_c
         
         	; Comptabilisation du nombre de bits inconnus
C:000cdc 9130 01c6 	lds		REG_TEMP_R19, G_DS18B20_ALR_NBR_BITS_0_1
C:000cde 9533      	inc		REG_TEMP_R19
C:000cdf 9330 01c6 	sts		G_DS18B20_ALR_NBR_BITS_0_1, REG_TEMP_R19
         
C:000ce1 9140 01c7 	lds		REG_TEMP_R20, G_DS18B20_ALR_NBR_BITS_0_1_MAX
C:000ce3 1734      	cp			REG_TEMP_R19, REG_TEMP_R20
C:000ce4 f012      	brmi		ds18b20_search_alr_loop_d
         
C:000ce5 9330 01c7 	sts		G_DS18B20_ALR_NBR_BITS_0_1_MAX, REG_TEMP_R19
         
          ds18b20_search_alr_loop_d:
         
         	; Ecriture de 'G_DS18B20_ALR_PATTERN<0>'
C:000ce7 9130 01c5 	lds		REG_TEMP_R19, G_DS18B20_ALR_PATTERN
C:000ce9 9536      	lsr		REG_TEMP_R19
C:000cea 9330 01c5 	sts		G_DS18B20_ALR_PATTERN, REG_TEMP_R19
         
C:000cec f440      	brcc		ds18b20_search_alr_loop_0
C:000ced c00c      	rjmp		ds18b20_search_alr_loop_1
         
          ds18b20_search_alr_loop_c:
C:000cee 3012      	cpi		REG_TEMP_R17, 0x02		; Presence de '0' uniquement
C:000cef f029      	breq		ds18b20_search_alr_loop_0
         
C:000cf0 3011      	cpi		REG_TEMP_R17, 0x01		; Presence de '1' uniquement
C:000cf1 f041      	breq		ds18b20_search_alr_loop_1
         
C:000cf2 3013      	cpi		REG_TEMP_R17, 0x03		; No capteur
C:000cf3 f071      	breq		ds18b20_search_alr_no_device
C:000cf4 c018      	rjmp		ds18b20_search_alr_end
         
          ds18b20_search_alr_loop_0:
C:000cf5 9488      	clc
C:000cf6 e038      	ldi		REG_TEMP_R19, NBR_BITS_TO_SHIFT
C:000cf7 de5b      	rcall		ds18b20_shift_right_rom
         
C:000cf8 9488      	clc
C:000cf9 c004      	rjmp		ds18b20_search_alr_loop_01
         
          ds18b20_search_alr_loop_1:
C:000cfa 9408      	sec
C:000cfb e038      	ldi		REG_TEMP_R19, NBR_BITS_TO_SHIFT
C:000cfc de56      	rcall		ds18b20_shift_right_rom
         
C:000cfd 9408      	sec
         	;rjmp		ds18b20_search_alr_loop_01
         
          ds18b20_search_alr_loop_01:
         
C:000cfe de36      	rcall		ds18b20_write_bit	
         
C:000cff 952a      	dec		REG_TEMP_R18
C:000d00 f671      	brne		ds18b20_search_alr_loop
         
C:000d01 c00b      	rjmp		ds18b20_search_alr_end
         
          ds18b20_search_alr_no_device:
          #ifndef USE_MINIMALIST_ADDONS
C:000d02 e40e      	ldi		REG_TEMP_R16, 'N'
C:000d03   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000d03 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
          #endif
         
          ds18b20_search_alr_abort:
C:000d05 9478      	sei
         
C:000d06 e4a0      	ldi		REG_X_LSB, 64
C:000d07 1ba2      	sub		REG_X_LSB, REG_TEMP_R18
         
          #ifndef USE_MINIMALIST_ADDONS
C:000d08 d9e0      	rcall		uos_print_1_byte_hexa_skip
          #endif
         
C:000d09 2fa1      	mov		REG_X_LSB, REG_TEMP_R17
         
          #ifndef USE_MINIMALIST_ADDONS
C:000d0a d9de      	rcall		uos_print_1_byte_hexa_skip
C:000d0b d9d3      	rcall		uos_print_line_feed_skip
          #endif
         
C:000d0c c048      	rjmp		ds18b20_search_alr_rtn
         
          ds18b20_search_alr_end:
C:000d0d 9478      	sei
         
C:000d0e e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
         
          #ifndef USE_MINIMALIST_ADDONS
C:000d0f daf7      	rcall		ds18b20_print_response
          #endif
         
C:000d10 e028      	ldi		REG_TEMP_R18, DS18B20_NBR_ROM_GESTION
         
          #ifndef USE_MINIMALIST_ADDONS
C:000d11 db08      	rcall		ds18b20_print_rom
          #endif
         
         	; Copy of ROM found in 'G_DS18B20_BYTES_ROM' to 'G_DS18B20_ALR_ROM_0' @ 'G_DS18B20_ALR_ROM_IDX'
         	; => 'REG_TEMP_R16' contient le rang du CRC du ROM trouve ou 0xff si pas trouve
C:000d12 db8f      	rcall		ds18b20_compare_alr_rom
         
C:000d13 3f0f      	cpi		REG_TEMP_R16, 0xff
C:000d14 f539      	brne		ds18b20_search_alr_found
         
         	; Emission de l'index du ROM #N en alarme
C:000d15 93bf      	push		REG_X_MSB
C:000d16 93af      	push		REG_X_LSB
         
         	; Get the index of ROM in alarm
C:000d17 e0b1      	ldi		REG_X_MSB, high(G_DS18B20_BYTES_ROM)
C:000d18 e8af      	ldi		REG_X_LSB, low(G_DS18B20_BYTES_ROM)
C:000d19 dc31      	rcall		ds18b20_get_rom_idx
         
C:000d1a 930f      	push		REG_TEMP_R16
C:000d1b 930f      	push		REG_TEMP_R16
         
          #ifndef USE_MINIMALIST_ADDONS
C:000d1c e203      	ldi		REG_TEMP_R16, '#'
C:000d1d   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000d1d 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000d1f 91af      	pop		REG_X_LSB
C:000d20 d9c8      	rcall		uos_print_1_byte_hexa_skip
C:000d21 d9bd      	rcall		uos_print_line_feed_skip
          #else
          #endif
         
C:000d22 910f      	pop		REG_TEMP_R16
C:000d23 91af      	pop		REG_X_LSB
C:000d24 91bf      	pop		REG_X_MSB
         	; Fin: Emission du ROM #N en alarme
         
         	; Cas ou le capteur #N n'est pas trouve dans la table des ROM detectes
         	; => Abort a la 1st occurence
C:000d25 3f0f      	cpi		REG_TEMP_R16, 0xff
C:000d26 f171      	breq		ds18b20_search_alr_rtn
         
         	; Update 'G_DS18B20_IN_ALARM' @ 'REG_TEMP_R16'
C:000d27 e1f4      	ldi		REG_Z_MSB, ((text_msk_table << 1) / 256)
C:000d28 ece2      	ldi		REG_Z_LSB, ((text_msk_table << 1) % 256)
C:000d29 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:000d2a 2711      	clr		REG_TEMP_R17
C:000d2b 1ff1      	adc		REG_Z_MSB, REG_TEMP_R17
C:000d2c 9124      	lpm		REG_TEMP_R18, Z
C:000d2d 9110 0198 	lds		REG_TEMP_R17, G_DS18B20_IN_ALARM
C:000d2f 2b12      	or			REG_TEMP_R17, REG_TEMP_R18
C:000d30 9310 0198 	sts		G_DS18B20_IN_ALARM, REG_TEMP_R17
         	; End: Update 'G_DS18B20_IN_ALARM' @ 'REG_TEMP_R16'
         
C:000d32 db5d      	rcall		ds18b20_alr_copy_rom
         
C:000d33 9100 01c8 	lds		REG_TEMP_R16, G_DS18B20_ALR_NBR_ROM
C:000d35 9503      	inc		REG_TEMP_R16
C:000d36 9300 01c8 	sts		G_DS18B20_ALR_NBR_ROM, REG_TEMP_R16
         
C:000d38 9110 01c9 	lds		REG_TEMP_R17, G_DS18B20_ALR_NBR_ROM_MAX
C:000d3a 1701      	cp			REG_TEMP_R16, REG_TEMP_R17
C:000d3b f4ca      	brpl		ds18b20_search_alr_rtn
         
          ds18b20_search_alr_found:
          #ifndef USE_MINIMALIST_ADDONS
C:000d3c e40e      	ldi		REG_TEMP_R16, 'N'
C:000d3d   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000d3d 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000d3f 91a0 01c4 	lds		REG_X_LSB, G_DS18B20_ALR_NBR_BITS_RETRY
C:000d41 d9a7      	rcall		uos_print_1_byte_hexa_skip
         
C:000d42 e30f      	ldi		REG_TEMP_R16, '?'
C:000d43   +  	_CALL		uos_push_1_char_in_fifo_tx_skip
C:000d43 940e 03a0 call		uos_push_1_char_in_fifo_tx_skip
C:000d45 91a0 01c6 	lds		REG_X_LSB, G_DS18B20_ALR_NBR_BITS_0_1
C:000d47 d9a1      	rcall		uos_print_1_byte_hexa_skip
         
C:000d48 d996      	rcall		uos_print_line_feed_skip
          #endif
         
C:000d49   +  	_CALL		uos_fifo_tx_to_send_sync
C:000d49 940e 03bd call		uos_fifo_tx_to_send_sync
         
C:000d4b 9130 01c4 	lds		REG_TEMP_R19, G_DS18B20_ALR_NBR_BITS_RETRY
C:000d4d 953a      	dec		REG_TEMP_R19
C:000d4e 9330 01c4 	sts		G_DS18B20_ALR_NBR_BITS_RETRY, REG_TEMP_R19
C:000d50 3f3f      	cpi		REG_TEMP_R19, 0xFF
C:000d51 f019      	breq		ds18b20_search_alr_rtn		
         
C:000d52 9330 01c5 	sts		G_DS18B20_ALR_PATTERN, REG_TEMP_R19
         
C:000d54 cf69      	rjmp		ds18b20_search_alr_cont_d
         
          ds18b20_search_alr_rtn:
C:000d55 9508      	ret
         ; ---------
         
         ; ---------
         ; Gestion du "scratchpad"
         ; ---------
         ; Code DS18B20 pour l'ecriture du 'scratchpad' #x et dans l'eeprom
         ; ---------
          ds18b20_write_scratchpad_x:
C:000d56 da93      	rcall		ds18b20_reset
         
C:000d57 9100 01cb 	lds		REG_TEMP_R16, (G_FRAME_ALL_INFOS + 0)		; Recuperation de l'Id du capteur
C:000d59 d00c      	rcall		ds18b20_match_rom_x
         
C:000d5a 9110 01cc 	lds		REG_TEMP_R17, (G_FRAME_ALL_INFOS + 1)		; Recuperation Tl
C:000d5c 9100 01cd 	lds		REG_TEMP_R16, (G_FRAME_ALL_INFOS + 2)		; Recuperation Th
C:000d5e 9120 01ce 	lds		REG_TEMP_R18, (G_FRAME_ALL_INFOS + 3)		; Recuperation Resolution
         
C:000d60 cf32      	rjmp		ds18b20_write_scratchpad
         ; ---------
         
         ; ---------
          ds18b20_copy_scratchpad_x:
C:000d61 da88      	rcall		ds18b20_reset
         
C:000d62 9100 01cb 	lds		REG_TEMP_R16, (G_FRAME_ALL_INFOS + 0)		; Recuperation de l'Id du capteur
C:000d64 d001      	rcall		ds18b20_match_rom_x
         
C:000d65 cf3d      	rjmp		ds18b20_copy_scratchpad
         ; ---------
         ; Fin: Gestion du "scratchpad"
         ; ---------
         
         ; ---------
          ds18b20_match_rom_x:
C:000d66 e0d1      	ldi		REG_Y_MSB, high(G_DS18B20_BYTES_SEND)
C:000d67 e6cf      	ldi		REG_Y_LSB, low(G_DS18B20_BYTES_SEND)
         
C:000d68 dbc1      	rcall		ds18b20_get_rom_detected_bypass	
C:000d69 f436      	brtc		ds18b20_match_rom_x_not_detect
         
          ds18b20_match_rom_x_cont_d:
C:000d6a e008      	ldi		REG_TEMP_R16, DS18B20_NBR_ROM_GESTION
         
          ds18b20_match_rom_x_loop:
C:000d6b 911d      	ld			REG_TEMP_R17, X+
C:000d6c 9319      	st			Y+, REG_TEMP_R17
C:000d6d 950a      	dec		REG_TEMP_R16
C:000d6e f7e1      	brne		ds18b20_match_rom_x_loop
         
C:000d6f ce6c      	rjmp		ds18b20_match_rom
         
          ds18b20_match_rom_x_not_detect:
          #ifndef USE_MINIMALIST_ADDONS
         	; ROM non detecte
C:000d70 e31f         ldi      REG_TEMP_R17, '?'
C:000d71 d997      	rcall		uos_print_mark_skip
          #endif
         
C:000d72 9100 0168 	lds		REG_TEMP_R16, G_DS18B20_FLAGS
C:000d74 6800      	sbr		REG_TEMP_R16, FLG_TEST_CONFIG_ERROR_MSK
C:000d75 9300 0168 	sts		G_DS18B20_FLAGS, REG_TEMP_R16
         
C:000d77 9508      	ret
         ; ---------
         
         ; End of file
         
          
          
          .dseg
D:00020b    G_SRAM_END_OF_USE:		.byte	1
         
         ; End of file
         
Used memory blocks:
   code      :  Start = 0x0000, End = 0x0068, Length = 0x0069 (105 words), Overlap=N
   code      :  Start = 0x0069, End = 0x0145, Length = 0x00DD (221 words), Overlap=N
   code      :  Start = 0x0146, End = 0x023C, Length = 0x00F7 (247 words), Overlap=N
   code      :  Start = 0x023D, End = 0x02FB, Length = 0x00BF (191 words), Overlap=N
   code      :  Start = 0x02FC, End = 0x03D2, Length = 0x00D7 (215 words), Overlap=N
   code      :  Start = 0x03D3, End = 0x0427, Length = 0x0055 (85 words), Overlap=N
   code      :  Start = 0x0428, End = 0x069D, Length = 0x0276 (630 words), Overlap=N
   code      :  Start = 0x069E, End = 0x0742, Length = 0x00A5 (165 words), Overlap=N
   code      :  Start = 0x0743, End = 0x0A64, Length = 0x0322 (802 words), Overlap=N
   code      :  Start = 0x0A65, End = 0x0A88, Length = 0x0024 (36 words), Overlap=N
   code      :  Start = 0x0A89, End = 0x0B7D, Length = 0x00F5 (245 words), Overlap=N
   code      :  Start = 0x0B7E, End = 0x0D77, Length = 0x01FA (506 words), Overlap=N
   data      :  Start = 0x0060, End = 0x0067, Length = 0x0008 (8 bytes), Overlap=N
   data      :  Start = 0x0068, End = 0x0068, Length = 0x0001 (1 byte), Overlap=N
   data      :  Start = 0x0069, End = 0x00A8, Length = 0x0040 (64 bytes), Overlap=N
   data      :  Start = 0x00A9, End = 0x011B, Length = 0x0073 (115 bytes), Overlap=N
   data      :  Start = 0x011C, End = 0x0165, Length = 0x004A (74 bytes), Overlap=N
   data      :  Start = 0x0166, End = 0x0167, Length = 0x0002 (2 bytes), Overlap=N
   data      :  Start = 0x0168, End = 0x020A, Length = 0x00A3 (163 bytes), Overlap=N
   data      :  Start = 0x020B, End = 0x020B, Length = 0x0001 (1 byte), Overlap=N


Segment usage:
   Code      :      3448 words (6896 bytes)
   Data      :       428 bytes
   EEPROM    :         0 bytes

Assembly completed with no errors.
